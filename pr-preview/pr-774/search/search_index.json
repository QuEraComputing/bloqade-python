{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Bloqade -- QuEra's Neutral Atom SDK","text":""},{"location":"#what-is-bloqade","title":"What is Bloqade?","text":"<p>Bloqade is an SDK designed to be a simple, easy-to-use interface for writing, submitting, and analyzing results of analog quantum programs on QuEra's neutral atom quantum computers. Currently, QuEra's hardware is on Amazon Braket, the primary method of accessing QuEra's quantum hardware. Over the alpha phase, we plan to expand the emulator capabilities to include a performance Python emulator but also a direct integration with Julia via Bloqade.jl.</p>"},{"location":"#what-does-bloqade-do","title":"What does Bloqade do?","text":"<p>Bloqade is primarily a language for writing analog quantum programs for neutral atom quantum computers. Our interface is designed to guide our users through the process of defining a analog quantum program as well as different methods to run the program, whether it is on a real quantum computer or a simulator. Bloqade also provides a simple interface for analyzing the results of the program, whether it is a single run or a batch of runs or even some types of hybrid quantum-classical algorithms.</p>"},{"location":"#how-do-i-get-started","title":"How do I get started?","text":""},{"location":"#installation","title":"Installation","text":"<p>You can install the latest version of Bloqade using pip:</p> <pre><code>pip install bloqade\n</code></pre>"},{"location":"#usage-and-philosophy","title":"Usage and Philosophy","text":"<p>In Bloqade we use the <code>.</code> to separate the different parts of your quantum program.  The reason for this is to guide you through how to build a neutral atom simulation. If you are using an IDE like PyCharm or VSCode you can see the available options for building your program along with the documentation associated with each option. Similarly in Jupyter notebook environments you can also access this information via tab completion feature in Jupyter notebooks! That being said, we will go through a simple example of how to build a program in Bloqade. We will start with a simple program that does nothing.</p> <pre><code>from bloqade import start\n\ncalculation = (\n    start\n)\n</code></pre> <p>From here there will be different methods and properties that you can use to build your program. For example, you can start to add atom sites to your program by selecting the <code>add_position</code> method.</p> <pre><code>from bloqade import start\n\ncalculation = (\n    start\n    .add_position((0, 0))\n    .add_position((0, 6.8))\n    .add_position([(6.8, 0), (6.8, 6.8)])\n)\n</code></pre> <p>You can also start from a predefined geometry in the <code>bloqade.atom_arrangements</code> submodule. If you want to start to build the Rydberg drive you can select the <code>rydberg</code> property. You can also skip creating a geometry and just build a rydberg pulse as well, in more advanced use cases you can extract the given drive and apply it to a different geometry.</p> <p><pre><code>from bloqade import start\n\ncalculation = (\n    start\n    .add_position((0, 0))\n    .add_position((0, 6.8))\n    .add_position([(6.8, 0), (6.8, 6.8)])\n    .rydberg\n)\n</code></pre> Note that from here on out, you can no longer add to your geometry as the <code>rydberg</code> property is terminal (i.e. the addition of <code>rydberg</code> blocks you from further configuring your geometry). This is another advantage of using the <code>.</code> to separate the different parts of your program and guide you through the build process.</p> <p>Continuing with our example, you can select the different parts of the Rydberg drive. For example, if you want to build the detuning part of the drive, you can choose the <code>detuning</code> property.</p> <pre><code>from bloqade import start\n\ncalculation = (\n    start\n    .add_position((0, 0))\n    .add_position((0, 6.8))\n    .add_position([(6.8, 0), (6.8, 6.8)])\n    .rydberg.detuning\n)\n</code></pre> <p>In the code above, <code>rydberg.detuning</code> indicates that the following set of methods and properties will be related to the Detuning of the Rydberg drive. You can also select <code>rabi.amplitude</code> or <code>rabi.phase</code> To build the amplitude and phase parts of the drive. Next, we will select the spatial modulation of the driving field.</p> <pre><code>from bloqade import start\n\ncalculation = (\n    start\n    .add_position((0, 0))\n    .add_position((0, 6.8))\n    .add_position([(6.8, 0), (6.8, 6.8)])\n    .rydberg.detuning.uniform\n)\n</code></pre> <p>Here, we selected the <code>uniform</code> property, indicating that the detuning will be uniform across the atoms. You can also select <code>scale(value)</code> where <code>value</code> is a string to indicate a that you want to specify the value later or a list for the lattice site scaling. Having variables will allow you to define a spatially varying detuning as a list of real numbers. You can also select individual atoms using the <code>location(index, scale)</code> method, where <code>index</code> is the integer associated with the lattice. Now that we have the drive's spatial modulation, we can start to build the time dependence of the detuning field. Continuing with the example, we can add individual segments to the time function using <code>linear</code> or <code>constant</code> methods, or we have shortcuts to common waveforms like <code>piecewise_linear</code> or <code>piecewise_constant</code>. We use a piecewise linear function to define the Detuning waveform on Aquila.</p> <pre><code>from bloqade import start\n\ncalculation = (\n    start\n    .add_position((0, 0))\n    .add_position((0, 6.8))\n    .add_position([(6.8, 0), (6.8, 6.8)])\n    .rydberg.detuning.uniform\n    .piecewise_linear(\n        durations = [0.1, 1.0, 0.1],\n        values = [-10, -10, 10, 10]\n    )\n)\n</code></pre> <p>One can continue using the <code>.</code> to append more time-dependent segments to the uniform detuning waveform or select a different spatial modulation of the detuning field. The results will be that the new spatial modulation will be added to the existing spatial modulation. You can also start to build another field within the Rydberg drive by selecting the <code>amplitude</code> or <code>phase</code> properties.</p> <pre><code>from bloqade import start\n\ncalculation = (\n    start\n    .add_position((0, 0))\n    .add_position((0, 6.8))\n    .add_position([(6.8, 0), (6.8, 6.8)])\n    .rydberg.detuning.uniform\n    .piecewise_linear(\n        durations = [0.1, 1.0, 0.1],\n        values = [-10, -10, 10, 10]\n    )\n    .amplitude.uniform\n    .piecewise_linear(\n        durations = [0.1, 1.0, 0.1],\n        values = [0, 10, 10, 0]\n    )\n)\n</code></pre> <p>Depending on the next property selected: 1. <code>hyperfine</code> will switch the build context to build the Hyperfine driving transition 2. <code>amplitude</code> or <code>rabi.amplitude</code> will start to build the rabi amplitude in the current context, e.g. rydberg 3. <code>phase</code> or <code>rabi.phase</code> will start to build the rabi phase in the current context e.g. rydberg 4. Selecting a new spatial modulation will add a new channel to the current field, e.g. detuning 5. Repeating the previously specified spatial modulations will add that waveform with the previously defined waveform in that spatial modulation.</p> <pre><code>from bloqade import start\n\ncalculation = (\n    start\n    .add_position((0, 0))\n    .add_position((0, 6.8))\n    .add_position([(6.8, 0), (6.8, 6.8)])\n    .rydberg.detuning.uniform\n    .piecewise_linear(\n        durations = [0.1, 1.0, 0.1],\n        values = [-10, -10, \"final_detuning\", \"final_detuning\"]\n    )\n    .amplitude.uniform\n    .piecewise_linear(\n        durations = [0.1, 1.0, 0.1],\n        values = [0, 10, 10, 0]\n    )\n)\n</code></pre> <p>A string can parameterize continuous values inside the program. These are known as \"run-time parameters\". There are three ways to specify the value for these parameters; the first is to set the value via <code>assign</code>, which means that the variable will have the same assignment regardless of the run. The second is to specify the value via <code>batch_assign</code>, which assigns that parameter to a batch. When specifying a batch, the program will automatically execute a quantum task for each parameter in the batch. The other method to define the variable is through <code>args</code>. This instruction will delay the specification of the variable until the running/submitting of the tasks, which is helpful for certain kinds of hybrid quantum-classical applications. Combined with the callable nature of the backends, this makes it very easy to create a quantum-classical loop. You can mix and match some of these methods, and the available options should pop up if you are using an IDE.</p> <p>Another helpful feature for small clusters of atoms is the <code>parallelize</code> option. The idea here is that the atoms are arranged in 2D space in some bounded square region for Aquila and other Neutral Atom machines. You can run multiple copies of that calculation in parallel for small clusters of atoms by spacing those clusters apart by some sufficiently large distance. Our infrastructure will automatically detect the area of the QPU and use that to generate the appropriate number of copies of the calculation. Also, when processing the results, it is possible to automatically stitch the results from the different copies together so that the analysis is unified on the original cluster.</p> <p>Now that we have specified all the options, we can think about how to run our program. We only support <code>braket</code>, which tells Bloqade to submit your tasks to the braket service. The credentials are handled entirely by the Braket SDK, so we suggest you look at their documentation for how to set that up. However, setting up your AWS credentials in your environment variables is the easiest way. To execute the program on Aquila, you select the <code>aquila</code> backend after the <code>braket</code> property.</p> <p><pre><code>from bloqade import start\n\ncalculation = (\n    start\n    .add_position((0, 0))\n    .add_position((0, 6.8))\n    .add_position([(6.8, 0), (6.8, 6.8)])\n    .rydberg.detuning.uniform\n    .piecewise_linear(\n        durations = [0.1, 1.0, 0.1],\n        values = [-10, -10, \"final_detuning\", \"final_detuning\"]\n    )\n    .amplitude.uniform\n    .piecewise_linear(\n        durations = [0.1, 1.0, 0.1],\n        values = [0, 10, 10, 0]\n    )\n    .batch_assign(final_detuning=[0,1,2,3,4])\n    .braket.aquila()\n)\n</code></pre> For tasks executed through a remote API, there are three options to run your job. The first is an asynchronous call via <code>submit</code>, which will return a <code>RemoteBatch</code> object. This object has various methods to <code>fetch</code> and or <code>pull</code> results from the remote API, along with some other tools that can query the status of the task(s) in this batch. <code>run</code> is another method that blocks the script and makes it wait for all the tasks to finish, subsequently returning the <code>RemoteBatch</code>. The final option is to use the <code>__call__</code> method of the <code>calculation</code> object for hybrid workflows. The call object is effectively the same as calling <code>run</code>. However, specifying the <code>args</code> option will allow you to call <code>__call__</code> with arguments corresponding to the list of strings provided by <code>args</code>.</p> <p>The <code>RemoteBatch</code> object can be saved in JSON format using the <code>save</code> and reloaded back into Python using the <code>load</code> functions. This capability is useful for the asynchronous case, where you can save the batch and load it back later to retrieve the results.</p> <p>The braket service also provides a local emulator, which can be run by selecting the <code>local_emulator()</code> options after the <code>braket</code> property. There is no asynchronous option for local emulator jobs, so you can only call <code>run</code> or <code>__call__</code> methods, and the return result is a <code>LocalBatch</code>.</p> <p>The batch objects also have a method <code>report</code> that returns a <code>Report</code> object. This object will contain all the data inside the batch object, so if no results are present in the <code>RemoteBatch</code>, then the <code>Report</code> will not have any data either. A common pattern would be first to call <code>fetch</code> and then create the <code>Report</code> by calling <code>report</code>. That way, the generated report will have the most up-to-date results. Similarly, if you are willing to wait, you can call <code>pull</code>, which will block until all tasks have stopped running.</p> <p>Here is what a final calculation might look like for running a parameter scan and comparing hardware to a classical emulator:</p> <pre><code>from bloqade import start, save\n\nprogram = (\n    start\n    .add_position((0, 0))\n    .add_position((0, 6.8))\n    .add_position([(6.8, 0), (6.8, 6.8)])\n    .rydberg.detuning.uniform\n    .piecewise_linear(\n        durations = [0.1, 1.0, 0.1],\n        values = [-10, -10, \"final_detuning\", \"final_detuning\"]\n    )\n    .amplitude.uniform\n    .piecewise_linear(\n        durations = [0.1, 1.0, 0.1],\n        values = [0, 10, 10, 0]\n    )\n    .batch_assign(final_detuning=[0,1,2,3,4])\n)\n\nemulator_batch = program.bloqade.python().run(1000)\n\nhardware_batch = program.parallelize(20).braket.aquila().submit(1000)\n\nsave(emulator_batch, \"emulator_results.json\")\nsave(hardware_batch, \"hardware_results.json\")\n\n# Analysis script\n\nfrom bloqade import load\n\nemulator_batch = load(\"emulator_results.json\")\nhardware_batch = load(\"hardware_results.json\")\n\nemulator_batch.report().show()\nhardware_batch.fetch().report().show()\n</code></pre> <p>An excellent place to start for examples is the Aquila whitepaper examples found here. Also, a flow diagram can be found here that discusses the entire build process.</p>"},{"location":"blog/2023/","title":"Bloqade Blog Posts 2023","text":"<p>Sept. 21, 2023 - Introducing Bloqade SDK for Python</p>"},{"location":"blog/2023/posts/bloqade-release/","title":"Introducing Bloqade SDK for Python","text":"<p>Greetings Neutral Atom QC experts, enthusiasts, and newcomers!</p> <p>We are excited to the Rydberg state thrilled to announce the Python version of our cutting-edge SDK, Bloqade. Originally developed in Julia, Bloqade has been a game-changer in the realm of Neutral Atom quantum computing. With the introduction of the Python version, we aim to make this revolutionary technology more accessible and user-friendly than ever before.</p>"},{"location":"blog/2023/posts/bloqade-release/#why-python","title":"Why Python?","text":"<p>Python is one of the most widely used programming languages, especially in the quantum computing community and broader scientific communities. By extending Bloqade to Python, we are opening doors to a broader audience, enabling more developers, researchers, and organizations to harness the power of Neutral Atom quantum computing.</p>"},{"location":"blog/2023/posts/bloqade-release/#neutral-atom-quantum-computing","title":"Neutral Atom Quantum Computing","text":"<p>Recently, the Neutral Atom platform has come on the QC scene in the form of Analog Hamiltonian Simulators that have a broad set of use cases beyond quantum circuits. Ranging from simulating unique quantum phases of matter, solving combinatorical optimization problems, and machine learning applications, the analog mode provides strong values in solving practical, interesting problems in the near term.</p> <p>These advances are crucial milestones on the way towards scalable digital gate-based architecture using atom shuttling. This new technology and its novel applications demand a paradigm shift in the way we not only think about quantum computing, but translate those ideas to real hardware. Enter Bloqade, a next-generation SDK designed to put the power of neutral atoms at your fingertips.</p>"},{"location":"blog/2023/posts/bloqade-release/#why-bloqade","title":"Why Bloqade?","text":"<p>Bloqade is designed with the primary goal of making it easier to compose programs for QuEra\u2019s hardware and analyze results.</p> <p>We've gained valuable insights into how users have used our neutral-atom hardware and with it, their struggles with existing tools. We took advantage of this knowledge to produce a tool that could take the \"hard\" out of \"hardware\". Bloqade is precision-balanced in both flexibility to empower novices to experiment with ease and power to let experts perform cutting-edge work without breaking a sweat.</p>"},{"location":"blog/2023/posts/bloqade-release/#highlights","title":"Highlights","text":""},{"location":"blog/2023/posts/bloqade-release/#smart-documentation","title":"Smart Documentation","text":"<p>With our commitment to enabling more seamless program development, we've put the relevant documentation you need right where and when you need it.</p> <p>No more obnoxious switching between your favorite coding environment and documentation in a separate window. Let Bloqade guide you where you'd like to go:</p> <p></p>"},{"location":"blog/2023/posts/bloqade-release/#fully-parameterized-analog-programs","title":"Fully Parameterized Analog Programs","text":"<p>Parameter sweeps are a common theme of programs for analog quantum computers, where a user would like to observe differences in output results by varying a value or values in their program.</p> <p>You used to have to manually crank out variations of your program with different values and then keep track of all the individual submissions to the emulator and hardware, a mess to keep track of and process the results of afterwards.</p> <p>Bloqade eliminates this with its own support for variables that can later be assigned single values or a whole sequence of values for trivial parameter sweeping. This isn't some feature that's constrained to a certain backend, you can take your program with all its variables and submit it to your choice of emulator or our hardware directly.</p> <pre><code>from bloqade import var\nfrom bloqade.atom_arrangement import Square\n\nimport numpy as np\n\nadiabatic_durations = [0.4, 3.2, 0.4]\n\n# create variables explicitly...\nmax_detuning = var(\"max_detuning\")\n# ...or implicitly inside the program definition.\nadiabatic_program = (\n    Square(3, \"lattice_spacing\")\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(\n        durations=adiabatic_durations, values=[0.0, \"max_rabi\", \"max_rabi\", 0.0]\n    )\n    .detuning.uniform.piecewise_linear(\n        durations=adiabatic_durations,\n        values=[\n            -max_detuning, # scalar variables support direct arithmetic operations\n            -max_detuning,\n            max_detuning,\n            max_detuning,\n        ],\n    )\n    .assign(max_rabi=15.8, max_detuning=16.33)\n    .batch_assign(lattice_spacing=np.arange(4.0, 7.0, 0.5))\n)\n\n# Launch your program on your choice of Braket or in-house emulator...\nemu_results = adiabatic_program.braket.local_emulator().run(10000)\nfaster_emu_results = adiabatic_program.bloqade.python().run(10000)\n# ...as well as hardware without stress\nhw_results = adiabatic_program.parallelize(24).braket.aquila().run_async(100)\n</code></pre>"},{"location":"blog/2023/posts/bloqade-release/#integrated-visualization-tools","title":"Integrated Visualization Tools","text":"<p>Instantly understand what your programs are doing faster than you can say \"neutral atoms rock!\" with Bloqade's built-in visualization tools:</p> <p></p> <p></p> <p>For your results, no more obnoxious manual compilation of results across different parameters or wrangling them into more useful forms. Get insights of experiment outcomes in the blink of an eye:</p> <p></p> <p></p> <p>Now that's what we call having your cake AND eating it.</p>"},{"location":"blog/2023/posts/bloqade-release/#bloqade-roadmap","title":"Bloqade Roadmap","text":""},{"location":"blog/2023/posts/bloqade-release/#bloqade-alpha-phase","title":"Bloqade Alpha Phase","text":"<p>During the next year, we plan on continuing development of Bloqade's python interface. If you are as excited about Neutral Atom quantum computing as us, or heck, even just quantum physics in general, give Bloqade a try! This is your opportunity to influence the direction of Bloqade and get in on the ground floor of the next Quantum Computing revolution.</p>"},{"location":"blog/2023/posts/bloqade-release/#but-what-about-julia","title":"But what about Julia?","text":"<p>Don't you guys already HAVE an SDK in Julia? Why do you need two SDKs?</p> <p>That's right! However, there's a key motivating factor for the reason we created Bloqade Python that's distinct for Bloqade.jl's existence.</p> <p>Bloqade.jl is primarily geared as a high-performance emulator. It allows you to design complex neutral-atom algorithms that may not necessarily run on our hardware BUT are excellent if you're exploring novel physical phenonema/algorithms or as a tool for pedagogical purposes.</p> <p>Bloqade.jl does have the ability to submit to Aquila, our flagship quantum computer, but for more complex tasks such as sweeping parameters (e.g. running the same program on hardware with slightly different parameters each time) or advanced post-processing, it becomes cumbersome quite quickly.</p> <p>There are no plans to drop support any time soon though. On the contrary, we plan on fully integrating Bloqade.jl into the Python package, which will enable you to program Neutral Atom quantum hardware without having to choose.</p> <p>We very much look forward to you trying out Bloqade!</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for your interest in contributing to the project! We welcome all contributions. There are many different ways to contribute to Bloqade, and we are always looking for more help. We accept contributions in the form of bug reports, feature requests, documentation improvements, and code contributions. For more information about how to contribute, please read the following sections.</p>"},{"location":"contributing/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Reporting a Bug </li> <li>Reporting Documentation Issues</li> <li>Feature Requests</li> <li>Developing Bloqade</li> <li>Design Philosophy and Architecture</li> <li>Community Slack</li> <li>Ask a Question</li> <li>Providing Feedback</li> </ul>"},{"location":"contributing/asking-a-question/","title":"Ask a Question","text":"<p>If you're interested in contributing to Bloqade, or just want to discuss the project, join the discussion on GitHub Discussions at https://github.com/QuEraComputing/bloqade-python/discussions</p>"},{"location":"contributing/code-of-conduct/","title":"Design Philosophy and Architecture","text":"<p>Given the heterogeneous nature of the hardware we target, We have decided to use a compiler-based approach to our software stack, allowing us to target different hardware backends with the same high-level language. Below is a diagram of the software stack in Bloqade.</p> <pre><code>graph TD\n    Builder[\"Builder Representation\"]\n    PythonAST[\"Bloqade AST Python\"]\n    JuliaAST[\"Bloqade AST Julia\"]\n\n    EmulatorPy[\"Emulator IR Python\"]\n    EmulatorJL[\"Emulator IR Julia\"]\n\n    QuEra[\"QuEra IR\"]\n    Braket[\"Braket IR\"]\n    JuliaEmulator[\"Bloqade.jl\"]\n    PythonEmulator[\"Python Emulator\"]\n\n    Aquila[\"Aquila\"]\n\n    Builder --&gt;|parse| PythonAST\n    PythonAST --&gt;|lower| EmulatorPy\n    PythonAST --&gt;|lower| QuEra\n    PythonAST --&gt;|lower| Braket\n    PythonAST --&gt;|transpile| JuliaAST\n\n    QuEra --&gt;|execute| Aquila\n    Braket --&gt;|execute| Aquila\n\n    JuliaAST --&gt;|lower| EmulatorJL\n    EmulatorPy --&gt;|execute| PythonEmulator\n    EmulatorJL --&gt;|execute| JuliaEmulator\n</code></pre>"},{"location":"contributing/code-of-conduct/#high-level-builder-representation","title":"High-Level Builder Representation","text":"<p>When programming Bloqade using the Python API, the user constructs a representation of an analog quantum circuit. This representation is a flattened version of the actual analog circuit. Flattened means that the user input is a linear sequence of operations where the context of neighboring nodes in the sequence of instructions can determine the program tree structure. The Bloqade AST describes the actual analog circuit.</p>"},{"location":"contributing/code-of-conduct/#bloqade-ast","title":"Bloqade AST","text":"<p>The Bloqade AST is a representation of a quantum analog circuit for neutral atom computing. It is a directed acyclic graph (DAG) with nodes for different hierarchical levels of the circuit. The base node is the <code>AnalogCircuit</code> which contains the geometry of the atoms stored as a <code>AtomArragment</code> or <code>ParallelRegister</code> objects. The other part of the circuit is the <code>Sequence</code>, which contains the waveforms that describe the drives for the Ryberg/Hyperfine transitions of each Rydberg atom. Each transition is represented by a <code>Pulse</code> including a <code>Field</code> for the drive's detuning, Rabi amplitude, and Rabi phase . A <code>Field</code> relates the spatial and temporal dependence of a drive. The spatial modulates the temporal dependence of the waveform. A DAG also describes the <code>Waveform</code> object. Finally, we have basic <code>Scalar</code> expressions as well for describing the syntax of real-valued continuous numbers.</p>"},{"location":"contributing/code-of-conduct/#bloqade-compilers-and-transpilers","title":"Bloqade Compilers and Transpilers","text":"<p>Given a user program expressed as the Bloqade AST, we can target various backends by transforming from the Bloqade AST to other kinds of IR. For example, when submitting a task to QuEra's hardware, we transform the Bloqade AST to the IR that describes a valid program for the hardware.</p> <p>This process is referred to as <code>lowering</code>, which in a general sense is a transformation that takes you from one IR to another where the target IR is specialized or has a smaller syntactical structure. <code>Transpiling</code> corresponds to a transformation that takes you from one language to equivalent expressions in another. For example, we can transpile from the Bloqade AST in Python to the Bloqade AST in Julia. The generic term for both of these types of transformation in Bloqade is Code Generation. You will find various code generation implementations in various <code>codegen</code> modules.</p>"},{"location":"contributing/community-slack/","title":"Community Slack","text":"<p>You can join QuEra's Slack workspace with this link. Join the <code>#bloqade</code> channel to discuss anything related to Bloqade.</p>"},{"location":"contributing/design-philosophy-and-architecture/","title":"Design Philosophy and Architecture","text":"<p>Given the heterogeneous nature of the hardware we target, We have decided to use a compiler-based approach to our software stack, allowing us to target different hardware backends with the same high-level language. Below is a diagram of the software stack in Bloqade.</p> <pre><code>graph TD\n    Builder[\"Builder Representation\"]\n    PythonAST[\"Bloqade AST Python\"]\n    JuliaAST[\"Bloqade AST Julia\"]\n\n    EmulatorPy[\"Emulator IR Python\"]\n    EmulatorJL[\"Emulator IR Julia\"]\n\n    QuEra[\"QuEra IR\"]\n    Braket[\"Braket IR\"]\n    JuliaEmulator[\"Bloqade.jl\"]\n    PythonEmulator[\"Python Emulator\"]\n\n    Aquila[\"Aquila\"]\n\n    Builder --&gt;|parse| PythonAST\n    PythonAST --&gt;|lower| EmulatorPy\n    PythonAST --&gt;|lower| QuEra\n    PythonAST --&gt;|lower| Braket\n    PythonAST --&gt;|transpile| JuliaAST\n\n    QuEra --&gt;|execute| Aquila\n    Braket --&gt;|execute| Aquila\n\n    JuliaAST --&gt;|lower| EmulatorJL\n    EmulatorPy --&gt;|execute| PythonEmulator\n    EmulatorJL --&gt;|execute| JuliaEmulator\n</code></pre>"},{"location":"contributing/design-philosophy-and-architecture/#high-level-builder-representation","title":"High-Level Builder Representation","text":"<p>When programming Bloqade using the Python API, the user constructs a representation of an analog quantum circuit. This representation is a flattened version of the actual analog circuit. Flattened means that the user input is a linear sequence of operations where the context of neighboring nodes in the sequence of instructions can determine the program tree structure. The Bloqade AST describes the actual analog circuit.</p>"},{"location":"contributing/design-philosophy-and-architecture/#bloqade-ast","title":"Bloqade AST","text":"<p>The Bloqade AST is a representation of a quantum analog circuit for neutral atom computing. It is a directed acyclic graph (DAG) with nodes for different hierarchical levels of the circuit. The base node is the <code>AnalogCircuit</code> which contains the geometry of the atoms stored as a <code>AtomArragment</code> or <code>ParallelRegister</code> objects. The other part of the circuit is the <code>Sequence</code>, which contains the waveforms that describe the drives for the Ryberg/Hyperfine transitions of each Rydberg atom. Each transition is represented by a <code>Pulse</code> including a <code>Field</code> for the drive's detuning, Rabi amplitude, and Rabi phase . A <code>Field</code> relates the spatial and temporal dependence of a drive. The spatial modulates the temporal dependence of the waveform. A DAG also describes the <code>Waveform</code> object. Finally, we have basic <code>Scalar</code> expressions as well for describing the syntax of real-valued continuous numbers.</p>"},{"location":"contributing/design-philosophy-and-architecture/#bloqade-compilers-and-transpilers","title":"Bloqade Compilers and Transpilers","text":"<p>Given a user program expressed as the Bloqade AST, we can target various backends by transforming from the Bloqade AST to other kinds of IR. For example, when submitting a task to QuEra's hardware, we transform the Bloqade AST to the IR that describes a valid program for the hardware.</p> <p>This process is referred to as <code>lowering</code>, which in a general sense is a transformation that takes you from one IR to another where the target IR is specialized or has a smaller syntactical structure. <code>Transpiling</code> corresponds to a transformation that takes you from one language to equivalent expressions in another. For example, we can transpile from the Bloqade AST in Python to the Bloqade AST in Julia. The generic term for both of these types of transformation in Bloqade is Code Generation. You will find various code generation implementations in various <code>codegen</code> modules.</p>"},{"location":"contributing/developing-bloqade/","title":"Setting up your Development Environment","text":"<p>Before You Get Started</p> <p>Depending on the complexity of the contribution you'd like to make to Bloqade, it may be worth reading the Design Philosophy and Architecture section to get an idea of why Bloqade is structured the way that it is and how to make your contribution adhere to this philosophy.</p> <p>Our development environment contains a set of tools we use for development, testing, and documentation. This section describes how to set up the development environment. We primarily use pdm to manage python environments and dependencies.</p>"},{"location":"contributing/developing-bloqade/#setting-up-python","title":"Setting up Python","text":"<p>We use pdm to manage dependencies and virtual environment. After cloning the repository, run the following command to install dependencies:</p> <pre><code>pdm install\n</code></pre> <p>You can also install different dependency groups:</p> <ul> <li>dev: dependencies for development</li> </ul> <pre><code>pdm install --dev\n# or\npdm install -d\n</code></pre> <ul> <li>doc: dependencies for building documentation</li> </ul> <pre><code>pdm install -G doc\n</code></pre>"},{"location":"contributing/developing-bloqade/#useful-pdm-scripts","title":"Useful PDM scripts","text":""},{"location":"contributing/developing-bloqade/#tests","title":"Tests","text":"<p>You can run tests via</p> <pre><code>pdm run test\n</code></pre> <p>Or run tests and generate coverage via</p> <pre><code>pdm run coverage\n</code></pre> <p>will print out the coverage file level report in terminal.</p> <pre><code>pdm run coverage-html\n</code></pre> <p>This command generates an interactive html report in <code>htmlcov</code> folder. This will show which specific lines are not covered by tests.</p>"},{"location":"contributing/developing-bloqade/#documentation","title":"Documentation","text":"<p>You can build documentation via</p> <pre><code>pdm run doc_build\n</code></pre> <p>Or run a local server to preview documentation via</p> <pre><code>pdm run doc\n</code></pre>"},{"location":"contributing/developing-bloqade/#jupytext","title":"Jupytext","text":"<p>You can sync jupyter notebooks and python scripts via</p> <pre><code>pdm run jupytext\n</code></pre> <p>this will help you development examples in jupyter notebook and python scripts simultaneously.</p>"},{"location":"contributing/developing-bloqade/#lint","title":"Lint","text":"<p>We primarily use ruff - an extremely fast linter for Python, and black as formatter. These have been configured into pre-commit hooks. After installing pre-commit on your own system, you can install pre-commit hooks to git via</p> <pre><code>pre-commit install\n</code></pre>"},{"location":"contributing/documentation-issues/","title":"Reporting a Documentation Issue","text":"<p>We are always looking to improve our documentation. If you find a typo or think something is unclear, please open an issue on our GitHub page: https://github.com/QuEraComputing/bloqade-python/issues</p> <p>For typos or other minor problems, create an issue that contains a link to the specific page that includes the problem, along with a description of the problem and possibly a solution.</p> <p>For a request for new documentation content, please open up an issue and describe what you think is missing from the documentation.</p>"},{"location":"contributing/feature-requests/","title":"Requesting new Features","text":"<p>Given that we are currently at the beginning of the development of the Bloqade python interface, we are open to suggestions about what features would be helpful to include in future package iterations. If you have a request for a new feature, please open an issue on our GitHub page: https://github.com/QuEraComputing/bloqade-python/issues</p> <p>We ask that the feature requests be as specific as possible. Please include the following information in your feature request:</p> <ol> <li> <p>A short, descriptive title.</p> </li> <li> <p>A detailed description of the feature, including your attempt to solve the problem with the current version of Bloqade.</p> </li> <li> <p>A minimal code example that demonstrates the need for the feature.</p> </li> <li> <p>The version of Bloqade you are using.</p> </li> <li> <p>The version of Python you are using.</p> </li> <li> <p>The version of your operating system.</p> </li> </ol>"},{"location":"contributing/providing-feedback/","title":"Providing Feedback","text":"<p>While Github Issues are a great way for us to better understand any issues your having with Bloqade as well as provide us with feature requests, we're always looking for ways to collect more general feedback about what the user experience with Bloqade is like.</p> <p>To do that we have this form where you can provide your thoughts after using/experimenting/tinkering/hacking with Bloqade.</p> <p>Your feedback will help guide the future of Bloqade's design so be honest and know that you're contributing to the future of Quantum Computing with Neutral Atoms!</p>"},{"location":"contributing/reporting-a-bug/","title":"Reporting a Bug","text":"<p>Bloqade is currently in the alpha phase of development, meaning bugs most likely exist in the current implementation. We are continuously striving to improve the stability of Bloqade. As such, we encourage our users to report all bugs they find. To do this, we ask you to submit an issue to our GitHub page: https://github.com/QuEraComputing/bloqade-python/issues</p> <p>Please include the following information in your bug report:</p> <ol> <li> <p>A short, descriptive title.</p> </li> <li> <p>A detailed description of the bug, including the expected behavior and what happened.</p> </li> <li> <p>A minimal code example that reproduces the bug.</p> </li> <li> <p>The version of Bloqade you are using.</p> </li> <li> <p>The version of Python you are using.</p> </li> <li> <p>The version of your operating system.</p> </li> </ol>"},{"location":"reference/hardware-capabilities/","title":"Hardware Capabilities","text":"<p>During program development, it can be quite handy to know what true hardware capabilities are and incorporate that information programmaticaly. Bloqade offers the ability to do this via <code>get_capabilities()</code>.</p>"},{"location":"reference/hardware-capabilities/#programmatic-access","title":"Programmatic Access","text":"<p><code>get_capabilities()</code> (importable directly from <code>bloqade</code>) returns a <code>QuEraCapabilities</code> object. This object contains all the hardware constraints in <code>Decimal</code> format for the Aquila machine, our publically-accessible QPU on AWS Braket.</p> <p>An example of using <code>get_capabilities()</code> is presented below:</p> <pre><code>from bloqade import get_capabilities, piecewise_linear\n\n# get capabilities for Aquila\naquila_capabilities = get_capabilities()\n\n# obtain maximum Rabi frequency as Decimal\nmax_rabi = aquila_capabilities.capabilities.rydberg.global_.rabi_frequency_max\n\n# use that value in constructing a neat Rabi waveform \nrabi_wf = piecewise_linear(durations = [0.5, 1.0, 0.5], values = [0, max_rabi, max_rabi, 0])\n</code></pre> <p>The attribute names for each value have been provided below but will require you to provide the proper prefix like in the example above (e.g. the maximum number of qubits lives under the <code>number_qubits_max</code> attribute which can be navigated to via <code>*your_QuEra_Capabilities_Object*.lattice.number_qubits_max</code>).</p>"},{"location":"reference/hardware-capabilities/#aquila-capabilities","title":"Aquila Capabilities","text":""},{"location":"reference/hardware-capabilities/#task","title":"Task","text":"<ul> <li>Use prefix <code>your_capabilities_object.capabilities.task</code> for:<ul> <li>minimum number of shots</li> <li>maximum number of shots</li> </ul> </li> </ul> Capability Attribute Value Minimum Number of Shots <code>number_shots_min</code> 1 Maximum Number of Shots <code>number_shots_max</code> 1000"},{"location":"reference/hardware-capabilities/#lattice-geometry","title":"Lattice Geometry","text":"<ul> <li>Use prefix <code>your_capabilities_object.capabilities.lattice</code> for:<ul> <li>maximum number of qubits</li> </ul> </li> <li>Use prefix <code>your_capabilities_object.capabilities.lattice.area</code> for:<ul> <li>maximum lattice area width</li> <li>maximum lattice area height</li> </ul> </li> <li>Use prefix <code>your_capabilities_object.capabilities.lattice.geometry</code> for:<ul> <li>maximum number of sites</li> <li>position resolution</li> <li>minimum radial spacing</li> <li>minimum vertical spacing</li> </ul> </li> </ul> Capability Attribute Value Maximum Number of Qubits <code>number_qubits_max</code> 256 Maximum Lattice Area Width <code>width</code> 75.0 \u00b5m Maximum Lattice Area Height <code>height</code> 76.0 \u00b5m Minimum Radial Spacing between Qubits <code>spacing_radial_min</code> 4.0 \u00b5m Minimum Vertical Spacing between Qubits <code>spacing_vertical_min</code> 4.0 \u00b5m Position Resolution <code>position_resolution</code> 0.1 \u00b5m Maximum Number of Sites <code>number_sites_max</code> 256"},{"location":"reference/hardware-capabilities/#global-rydberg-values","title":"Global Rydberg Values","text":"<ul> <li>Use prefix <code>your_capabilities_object.capabilities.rydberg</code> for:<ul> <li>C6 Coefficient</li> </ul> </li> <li>Use prefix <code>your_capabilities_object.capabilities.rydberg.global_</code> for:<ul> <li>Everything else related to global (applied to all atom) capabilities</li> </ul> </li> </ul> Capability Attribute Value Rydberg Interaction Constant <code>c6_coefficient</code> 5.42\u00d710\u2076 rad/\u03bcs \u00d7 \u00b5m\u2076 Minimum Rabi Frequency <code>rabi_frequency_min</code> 0.00 rad/\u03bcs Maximum Rabi Frequency <code>rabi_frequency_max</code> 15.8 rad/\u03bcs Rabi Frequency Resolution <code>rabi_frequency_resolution</code> 0.0004 rad/\u03bcs Maximum Rabi Frequency Slew Rate <code>rabi_frequency_slew_rate_max</code> 250.0 rad/\u00b5s\u00b2 Minimum Detuning <code>detuning_min</code> -125.0 rad/\u03bcs Maximum Detuning <code>detuning_max</code> 125.0 rad/\u03bcs Detuning Resolution <code>detuning_resolution</code> 2.0\u00d710\u207b\u2077 rad/\u03bcs Maximum Detuning Slew Rate <code>detuning_slew_rate_max</code> 2500.0 rad/\u00b5s\u00b2 Minimum Phase <code>phase_min</code> -99.0 rad Maximum Phase <code>phase_max</code> 99.0 rad Phase Resolution <code>phase_resolution</code> 5.0\u00d710\u207b\u2077 rad Minimum Time <code>time_min</code> 0.0 \u00b5s Maximum Time <code>time_max</code> 4.0 \u00b5s Time Resolution <code>time_resolution</code> 0.001 \u00b5s Minimum \u0394t <code>time_delta_min</code> 0.05 \u00b5s"},{"location":"reference/hardware-capabilities/#local-detuning-values","title":"Local Detuning Values","text":"<ul> <li>Use prefix <code>your_capabilities_object.capabilities.rydberg.local</code> for the following values:</li> </ul> Capability Attribute Value Maximum Detuning <code>detuning_max</code> 125.0 rad/\u03bcs Minimum Detuning <code>detuning_min</code> 0 rad/\u03bcs Maximum Detuning Slew Rate <code>detuning_slew_rate_max</code> 1256.0 rad/\u00b5s\u00b2 Maximum Number of Local Detuning Sites <code>number_local_detuning_sites</code> 200 Maximum Site Coefficient <code>site_coefficient_max</code> 1.0 Minimum Site Coefficient <code>site_ceofficient_min</code> 0.0 Minimum Radial Spacing <code>spacing_radial_min</code> 5 \u00b5m Minimum \u0394t <code>time_delta_min</code> 0.05 \u03bcs Time Resolution <code>time_resolution</code> 0.001 \u00b5s"},{"location":"reference/overview/","title":"Builder Overview","text":"<p>You may have noticed from the Usage and Tutorials that Bloqade uses this interesting, dot-intensive syntax.</p> <p><pre><code>from bloqade import start\n\nprog = start.add_position((0,0)).rydberg.rabi.amplitude.uniform.constant(1,1)\n</code></pre> Exhibit A: Lots of Dots</p> <p>In fact, it might look remniscent of what you see in some gate-based Quantum Computing SDKs:</p> <pre><code># this is strictly pseudocode\ncircuit = init_qubits(n_qubits)\n# note the dots!\ncircuit.x(0).z(1).cnot(0, 1)...\n</code></pre> <p>What's the deal with that?</p>"},{"location":"reference/overview/#syntax-motivations","title":"Syntax Motivations","text":"<p>We call this syntax the builder or builder syntax and as its name implies, it is designed to let you build programs for Analog Hamiltonian Simulation hardware as easily and as straightforward as possible.</p> <p>The linear structure implies a natural hiearchy in how you think about targeting the various degrees of freedom (detuning, atom positions, Rabi amplitude, etc.) your program will have. In the beginning you have unrestricted access to all these degrees of freedom but in order to do something useful you need to:</p> <ol> <li>Narrow down and explicitly identify what you want to control</li> <li>Provide the instructions on how you want to control what your focused on</li> </ol> <p>Context is a strong component of the builder syntax, as you are both actively restricted from doing certain things that can introduce ambiguity based on where you are in your program and repeating the same action in different parts of the program yields different results.</p>"},{"location":"reference/overview/#visual-guides","title":"Visual Guides","text":"<p>While we hope the Smart Documentation (the ability to instantly see all your next possible steps and their capabilities in your favorite IDE/IPython) is sufficient to get you where you need to go, we undestand it's particularly beneficial to get a high-level overview of things before diving in.</p> <p>The Standard Representation is a nice flow chart that gives a high-level overview of the different steps and components in the builder syntax.</p>"},{"location":"reference/standard/","title":"Build Workflow","text":"<pre><code>\nflowchart TD\n  ProgramStart([\"start\"])\n\n  Geometry(\"Geometry or Lattice\")\n\n  Coupling[\"Coupling\n  -----------\n  rydberg\n  hyperfine\"]\n\n  Detuning[\"detuning\"]\n  Rabi[\"rabi\"]\n\n  Amplitude[\"amplitude\"]\n  Phase[\"phase\"]\n\n  SpaceModulation(\"SpatialModulation\n  ----------------------\n  uniform\n  scale\n  location\n  \")\n  Waveform{\"Waveform\n  ------------\n  piecewise_linear\n  piecewise_constant\n  constant\n  linear\n  poly\n  fn\n  \"}\n\n  Options([\"Options\n  ---------\n  assign\n  batch_assign\n  args\n  parallelize\n  \"])\n\n  Services([\"Services\n  ----------\n  bloqade\n  quera\n  braket\"])\n\n  QuEraBackends([\"Backends\n  ------------\n  mock\n  cloud_mock\n  aquila\n  device\"])\n\n  BraketBackends([\"Backends\n  ------------\n  aquila\n  local_emulator\"])\n\n  BloqadeBackends([\"Backends\n  ------------\n  python\n  julia\"])\n\n  Execution(\"\n  Execution hardware only\n  -------------------------------\n  run_async()\n\n  Hardware and simulation\n  -------------------------------\n  run()\n  __call__\")\n\n  ProgramStart --&gt;|add_position| Geometry;\n  Geometry --&gt; Coupling;\n  ProgramStart --&gt; Coupling;\n\n  Coupling --&gt; Detuning;\n  Coupling --&gt; Rabi;\n\n  Rabi --&gt; Amplitude;\n  Rabi --&gt; Phase;\n\n  Detuning --&gt; SpaceModulation;\n  Amplitude --&gt; SpaceModulation;\n  Phase --&gt; SpaceModulation;\n\n  SpaceModulation --&gt; Waveform;\n\n  Waveform --&gt; Coupling;\n  Waveform --&gt; Services;\n  Waveform --&gt; Options;\n  Options --&gt; Services;\n\n  Services --&gt;|quera| QuEraBackends;\n  Services --&gt;|braket| BraketBackends;\n  Services --&gt;|bloqade| BloqadeBackends;\n  QuEraBackends --&gt; Execution;\n  BraketBackends --&gt; Execution;\n  BloqadeBackends --&gt; Execution;\n\n  click ProgramStart \"../bloqade/#bloqade.start\";\n  click Geometry \"../bloqade/atom_arrangement/\";\n  click Coupling \"../bloqade/builder/drive/\";\n  click Detuning \"../bloqade/builder/field/#bloqade.builder.field.Detuning\";\n  click Rabi \"../bloqade/builder/field/#bloqade.builder.field.Rabi\";\n  click Amplitude \"../bloqade/builder/field/#bloqade.builder.field.Amplitude\";\n  click Phase \"../bloqade/builder/field/#bloqade.builder.field.Phase\";\n  click SpaceModulation \"../bloqade/builder/spatial/\";\n  click Waveform \"../bloqade/builder/waveform/\";\n  click Options \"../bloqade/builder/pragmas/\";\n  click Services \"../bloqade/builder/backend/\";\n  click QuEraBackends \"../bloqade/builder/backend/quera/#bloqade.builder.backend.quera.QuEraDeviceRoute\";\n  click BraketBackends \"../bloqade/builder/backend/braket/#bloqade.builder.backend.braket.BraketDeviceRoute\";\n  click BloqadeBackends \"../bloqade/builder/backend/bloqade/#bloqade.builder.backend.bloqade.BloqadeBackend\";\n  click Execution \"../bloqade/ir/routine/braket/#bloqade.ir.routine.braket.BraketRoutine\";\n</code></pre>"},{"location":"reference/bloqade/","title":"Index","text":""},{"location":"reference/bloqade/#bloqade.RB_C6","title":"RB_C6  <code>module-attribute</code>","text":"<pre><code>RB_C6 = 2 * pi * 862690\n</code></pre> <p>The C6 constant for the Rydberg Interaction of two Rubidium atoms in units of: rad \u03bcm^6/\u03bcs</p>"},{"location":"reference/bloqade/#bloqade.start","title":"start  <code>module-attribute</code>","text":"<pre><code>start = ListOfLocations()\n</code></pre> <p>A Program starting point, alias of empty <code>ListOfLocations</code>.</p> <ul> <li>Next possible steps to build your program are:</li> <li>Specify which level coupling to address with:<ul> <li><code>start.rydberg</code>: for <code>Rydberg</code>     Level coupling</li> <li><code>start.hyperfine</code>: for <code>Hyperfine</code>     Level coupling</li> <li>LOCKOUT: You cannot add atoms to your geometry after specifying level coupling.</li> </ul> </li> <li>continue/start building your geometry with:<ul> <li><code>start.add_position()</code>: to add atom(s) to current register. It will accept:<ul> <li>A single coordinate, represented as a tuple (e.g. <code>(5,6)</code>) with a value that   can either be:<ul> <li>integers: <code>(5,6)</code></li> <li>floats: <code>(5.1, 2.5)</code></li> <li>strings (for later variable assignment): <code>(\"x\", \"y\")</code></li> <li><code>Scalar</code> objects: <code>(2*cast(\"x\"), 5+cast(\"y\"))</code></li> </ul> </li> <li>A list of coordinates, represented as a list of types mentioned previously.</li> <li>A numpy array with shape (n, 2) where n is the total number of atoms</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/bloqade/#bloqade.Literal","title":"Literal","text":"<p>             Bases: <code>Real</code></p>"},{"location":"reference/bloqade/#bloqade.Literal.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value\n</code></pre> <p>Scalar Literal, which stores a decimaal value instance.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Decimal</code> <p>decimal value instance</p> required"},{"location":"reference/bloqade/#bloqade.Variable","title":"Variable","text":"<p>             Bases: <code>Real</code></p> <p>Variable, which stores a variable name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>variable instance.</p> required"},{"location":"reference/bloqade/#bloqade.cast","title":"cast","text":"<pre><code>cast(py)\n</code></pre> <ol> <li> <p>cast Real number (or list/tuple of Real numbers) to <code>Scalar Literal</code>.</p> </li> <li> <p>cast str (or list/tuple of Real numbers) to <code>Scalar Variable</code>.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>py</code> <code>Union[str, Real, Tuple[Real], List[Real]]</code> <p>python object to cast</p> required <p>Returns:</p> Type Description <code>Scalar</code> <p>Scalar</p> Source code in <code>src/bloqade/ir/scalar.py</code> <pre><code>def cast(py) -&gt; \"Scalar\":\n    \"\"\"\n    1. cast Real number (or list/tuple of Real numbers)\n    to [`Scalar Literal`][bloqade.ir.scalar.Literal].\n\n    2. cast str (or list/tuple of Real numbers)\n    to [`Scalar Variable`][bloqade.ir.scalar.Variable].\n\n    Args:\n        py (Union[str,Real,Tuple[Real],List[Real]]): python object to cast\n\n    Returns:\n        Scalar\n    \"\"\"\n    ret = trycast(py)\n    if ret is None:\n        raise TypeError(f\"Cannot cast {type(py)} to Scalar Literal\")\n\n    return ret\n</code></pre>"},{"location":"reference/bloqade/#bloqade.constant","title":"constant","text":"<pre><code>constant(duration, value)\n</code></pre> <p>Create a Constant waveform.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>ScalarType</code> <p>Duration of the Constant waveform.</p> required <code>value</code> <code>ScalarType</code> <p>Value of the Constant waveform.s</p> required <p>Returns:</p> Name Type Description <code>Constant</code> <code>Constant</code> <p>A Constant waveform.</p> Source code in <code>src/bloqade/factory.py</code> <pre><code>@beartype\ndef constant(duration: ScalarType, value: ScalarType) -&gt; Constant:\n    \"\"\"Create a Constant waveform.\n\n    Args:\n        duration (ScalarType): Duration of the Constant waveform.\n        value (ScalarType): Value of the Constant waveform.s\n\n    Returns:\n        Constant: A Constant waveform.\n    \"\"\"\n    return Constant(value, duration)\n</code></pre>"},{"location":"reference/bloqade/#bloqade.dumps","title":"dumps","text":"<pre><code>dumps(o, use_decimal=True, **json_kwargs)\n</code></pre> <p>Serialize object to string</p> <p>Parameters:</p> Name Type Description Default <code>o</code> <code>Any</code> <p>the object to serialize</p> required <code>use_decimal</code> <code>bool</code> <p>use decimal.Decimal for numbers. Defaults to True.</p> <code>True</code> <code>**json_kwargs</code> <p>other arguments passed to json.dumps</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the serialized object as a string</p> Source code in <code>src/bloqade/serialize.py</code> <pre><code>@beartype\ndef dumps(\n    o: Any,\n    use_decimal: bool = True,\n    **json_kwargs,\n) -&gt; str:\n    \"\"\"Serialize object to string\n\n    Args:\n        o (Any): the object to serialize\n        use_decimal (bool, optional): use decimal.Decimal for numbers. Defaults to True.\n        **json_kwargs: other arguments passed to json.dumps\n\n    Returns:\n        str: the serialized object as a string\n    \"\"\"\n    if not isinstance(o, Serializer.types):\n        raise TypeError(\n            f\"Object of type {type(o)} is not JSON serializable. \"\n            f\"Only {Serializer.types} are supported.\"\n        )\n    return json.dumps(o, cls=Serializer, use_decimal=use_decimal, **json_kwargs)\n</code></pre>"},{"location":"reference/bloqade/#bloqade.get_capabilities","title":"get_capabilities","text":"<pre><code>get_capabilities()\n</code></pre> <p>Get the device capabilities for Aquila</p> <p>Returns:</p> Name Type Description <code>QuEraCapabilities</code> <code>QuEraCapabilities</code> <p>capabilities object for Aquila device.</p> Note <p>Units of time, distance, and energy are microseconds (us), micrometers (um), and rad / us, respectively.</p> <p>For a comprehensive list of capabilities, see the Hardware Reference page</p> Source code in <code>src/bloqade/factory.py</code> <pre><code>def get_capabilities() -&gt; \"QuEraCapabilities\":\n    \"\"\"Get the device capabilities for Aquila\n\n    Returns:\n        QuEraCapabilities: capabilities object for Aquila device.\n\n\n    Note:\n        Units of time, distance, and energy are microseconds (us),\n        micrometers (um), and rad / us, respectively.\n\n        For a comprehensive list of capabilities,\n        see the [Hardware Reference](../../hardware-reference/hardware-capabilities.md)\n        page\n    \"\"\"\n\n    from bloqade.submission.capabilities import get_capabilities\n    import bloqade.submission.ir.capabilities as cp\n\n    capabilities_schema = get_capabilities()\n\n    capabilities = capabilities_schema.capabilities\n\n    # manually convert to units\n    return cp.QuEraCapabilities(\n        version=capabilities_schema.version,\n        capabilities=cp.DeviceCapabilities(\n            task=cp.TaskCapabilities(\n                number_shots_max=capabilities.task.number_shots_max,\n                number_shots_min=capabilities.task.number_shots_min,\n            ),\n            lattice=cp.LatticeCapabilities(\n                number_qubits_max=capabilities.lattice.number_qubits_max,\n                area=cp.LatticeAreaCapabilities(\n                    width=(capabilities.lattice.area.width * Decimal(\"1e6\")),  # m\n                    height=(capabilities.lattice.area.height * Decimal(\"1e6\")),  # m\n                ),\n                geometry=cp.LatticeGeometryCapabilities(\n                    number_sites_max=capabilities.lattice.geometry.number_sites_max,\n                    spacing_radial_min=(\n                        capabilities.lattice.geometry.spacing_radial_min\n                        * Decimal(\"1e6\")\n                    ),  # m\n                    spacing_vertical_min=(\n                        capabilities.lattice.geometry.spacing_vertical_min\n                        * Decimal(\"1e6\")\n                    ),  # m\n                    position_resolution=(\n                        capabilities.lattice.geometry.position_resolution\n                        * Decimal(\"1e6\")\n                    ),  # m\n                ),\n            ),\n            rydberg=cp.RydbergCapabilities(\n                c6_coefficient=capabilities.rydberg.c6_coefficient\n                * Decimal(\"1e30\"),  # rad * m^6 / s\n                global_=cp.RydbergGlobalCapabilities(\n                    phase_max=(capabilities.rydberg.global_.phase_max),  # rad\n                    phase_min=(capabilities.rydberg.global_.phase_min),  # rad\n                    phase_resolution=(\n                        capabilities.rydberg.global_.phase_resolution\n                    ),  # rad\n                    rabi_frequency_max=(\n                        capabilities.rydberg.global_.rabi_frequency_max / Decimal(\"1e6\")\n                    ),  # rad / s\n                    rabi_frequency_min=(\n                        capabilities.rydberg.global_.rabi_frequency_min / Decimal(\"1e6\")\n                    ),  # rad / s\n                    rabi_frequency_resolution=(\n                        capabilities.rydberg.global_.rabi_frequency_resolution\n                        / Decimal(\"1e6\")\n                    ),  # rad / s\n                    rabi_frequency_slew_rate_max=(\n                        capabilities.rydberg.global_.rabi_frequency_slew_rate_max\n                        / Decimal(\"1e6\") ** 2\n                    ),  # rad / s^2\n                    detuning_max=(\n                        capabilities.rydberg.global_.detuning_max / Decimal(\"1e6\")\n                    ),  # rad / s\n                    detuning_min=(\n                        capabilities.rydberg.global_.detuning_min / Decimal(\"1e6\")\n                    ),  # rad / s\n                    detuning_resolution=(\n                        capabilities.rydberg.global_.detuning_resolution\n                        / Decimal(\"1e6\")\n                    ),  # rad / s\n                    detuning_slew_rate_max=(\n                        capabilities.rydberg.global_.detuning_slew_rate_max\n                        / Decimal(\"1e6\") ** 2\n                    ),  # rad / s^2\n                    time_min=(\n                        capabilities.rydberg.global_.time_min * Decimal(\"1e6\")\n                    ),  # s\n                    time_max=(\n                        capabilities.rydberg.global_.time_max * Decimal(\"1e6\")\n                    ),  # s\n                    time_resolution=(\n                        capabilities.rydberg.global_.time_resolution * Decimal(\"1e6\")\n                    ),  # s\n                    time_delta_min=(\n                        capabilities.rydberg.global_.time_delta_min * Decimal(\"1e6\")\n                    ),  # s\n                ),\n                local=cp.RydbergLocalCapabilities(\n                    number_local_detuning_sites=(\n                        capabilities.rydberg.local.number_local_detuning_sites\n                    ),\n                    site_coefficient_max=(\n                        capabilities.rydberg.local.site_coefficient_max\n                    ),\n                    site_coefficient_min=(\n                        capabilities.rydberg.local.site_coefficient_min\n                    ),\n                    spacing_radial_min=(\n                        capabilities.rydberg.local.spacing_radial_min * Decimal(\"1e6\")\n                    ),  # rad / s\n                    detuning_min=(\n                        capabilities.rydberg.local.detuning_min / Decimal(\"1e6\")\n                    ),  # rad / s\n                    detuning_max=(\n                        capabilities.rydberg.local.detuning_max / Decimal(\"1e6\")\n                    ),  # rad / s\n                    detuning_slew_rate_max=(\n                        capabilities.rydberg.local.detuning_slew_rate_max\n                        / Decimal(\"1e6\") ** 2\n                    ),  # rad / s^2\n                    time_delta_min=(\n                        capabilities.rydberg.local.time_delta_min * Decimal(\"1e6\")\n                    ),  # s\n                    time_resolution=(\n                        capabilities.rydberg.local.time_resolution * Decimal(\"1e6\")\n                    ),  # s\n                ),\n            ),\n        ),\n    )\n</code></pre>"},{"location":"reference/bloqade/#bloqade.linear","title":"linear","text":"<pre><code>linear(duration, start, stop)\n</code></pre> <p>Create a Linear waveform.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>ScalarType</code> <p>Duration of linear waveform</p> required <code>start</code> <code>ScalarType</code> <p>Starting value of linear waveform</p> required <code>stop</code> <code>ScalarType</code> <p>Ending value of linear waveform</p> required <p>Returns:</p> Name Type Description <code>Linear</code> <code>Linear</code> <p>Linear waveform</p> Source code in <code>src/bloqade/factory.py</code> <pre><code>@beartype\ndef linear(duration: ScalarType, start: ScalarType, stop: ScalarType) -&gt; Linear:\n    \"\"\"Create a Linear waveform.\n\n    Args:\n        duration (ScalarType): Duration of linear waveform\n        start (ScalarType): Starting value of linear waveform\n        stop (ScalarType): Ending value of linear waveform\n\n    Returns:\n        Linear: Linear waveform\n    \"\"\"\n    return Linear(start, stop, duration)\n</code></pre>"},{"location":"reference/bloqade/#bloqade.load","title":"load","text":"<pre><code>load(fp, use_decimal=True, **json_kwargs)\n</code></pre> <p>Load object from file</p> <p>Parameters:</p> Name Type Description Default <code>fp</code> <code>Union[TextIO, str]</code> <p>the file path or file object</p> required <code>use_decimal</code> <code>bool</code> <p>use decimal.Decimal for numbers. Defaults to True.</p> <code>True</code> <code>**json_kwargs</code> <p>other arguments passed to json.load</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>the deserialized object</p> Source code in <code>src/bloqade/serialize.py</code> <pre><code>@beartype\ndef load(fp: Union[TextIO, str], use_decimal: bool = True, **json_kwargs):\n    \"\"\"Load object from file\n\n    Args:\n        fp (Union[TextIO, str]): the file path or file object\n        use_decimal (bool, optional): use decimal.Decimal for numbers. Defaults to True.\n        **json_kwargs: other arguments passed to json.load\n\n    Returns:\n        Any: the deserialized object\n    \"\"\"\n    load_bloqade()\n    if isinstance(fp, str):\n        with open(fp, \"r\") as f:\n            return json.load(\n                f,\n                object_hook=Serializer.object_hook,\n                use_decimal=use_decimal,\n                **json_kwargs,\n            )\n    else:\n        return json.load(\n            fp,\n            object_hook=Serializer.object_hook,\n            use_decimal=use_decimal,\n            **json_kwargs,\n        )\n</code></pre>"},{"location":"reference/bloqade/#bloqade.loads","title":"loads","text":"<pre><code>loads(s, use_decimal=True, **json_kwargs)\n</code></pre> <p>Load object from string</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>the string to load</p> required <code>use_decimal</code> <code>bool</code> <p>use decimal.Decimal for numbers. Defaults to True.</p> <code>True</code> <code>**json_kwargs</code> <p>other arguments passed to json.loads</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>the deserialized object</p> Source code in <code>src/bloqade/serialize.py</code> <pre><code>@beartype\ndef loads(s: str, use_decimal: bool = True, **json_kwargs):\n    \"\"\"Load object from string\n\n    Args:\n        s (str): the string to load\n        use_decimal (bool, optional): use decimal.Decimal for numbers. Defaults to True.\n        **json_kwargs: other arguments passed to json.loads\n\n    Returns:\n        Any: the deserialized object\n    \"\"\"\n    load_bloqade()\n    return json.loads(\n        s, object_hook=Serializer.object_hook, use_decimal=use_decimal, **json_kwargs\n    )\n</code></pre>"},{"location":"reference/bloqade/#bloqade.piecewise_constant","title":"piecewise_constant","text":"<pre><code>piecewise_constant(durations, values)\n</code></pre> <p>Create a piecewise linear waveform.</p> <p>Create a piecewise constant waveform from a list of durations and values. The value <code>duration[i]</code> corresponds to the length of time for the i'th segment with a value of <code>values[i]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>durations</code> <code>List[ScalarType]</code> <p>The duration of each segment</p> required <code>values</code> <code>List[ScalarType]</code> <p>The values for each segment</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the length of <code>values</code> is not the same as the length of</p> <p>Returns:</p> Name Type Description <code>Waveform</code> <code>Waveform</code> <p>The piecewise linear waveform.</p> Source code in <code>src/bloqade/factory.py</code> <pre><code>@beartype\ndef piecewise_constant(\n    durations: List[ScalarType], values: List[ScalarType]\n) -&gt; Waveform:\n    \"\"\"Create a piecewise linear waveform.\n\n    Create a piecewise constant waveform from a list of durations and values. The\n    value `duration[i]` corresponds to the length of time for the i'th segment\n    with a value of `values[i]`.\n\n    Args:\n        durations (List[ScalarType]): The duration of each segment\n        values (List[ScalarType]): The values for each segment\n\n    Raises:\n        ValueError: If the length of `values` is not the same as the length of\n        `durations`.\n\n    Returns:\n        Waveform: The piecewise linear waveform.\n    \"\"\"\n    if len(durations) != len(values):\n        raise ValueError(\n            \"The length of values must be the same as the length of durations\"\n        )\n\n    pwc_wf = None\n    for duration, value in zip(durations, values):\n        if pwc_wf is None:\n            pwc_wf = Constant(value, duration)\n        else:\n            pwc_wf = pwc_wf.append(Constant(value, duration))\n\n    return pwc_wf\n</code></pre>"},{"location":"reference/bloqade/#bloqade.piecewise_linear","title":"piecewise_linear","text":"<pre><code>piecewise_linear(durations, values)\n</code></pre> <p>Create a piecewise linear waveform.</p> <p>Create a piecewise linear waveform from a list of durations and values. The value <code>duration[i]</code> is of the linear segment between <code>values[i]</code> and <code>values[i+1]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>durations</code> <code>List[ScalarType]</code> <p>The duration of each segment</p> required <code>values</code> <code>List[ScalarType]</code> <p>The values for each segment</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the length of <code>values</code> is not one greater than the length of</p> <p>Returns:</p> Name Type Description <code>Waveform</code> <code>Waveform</code> <p>The piecewise linear waveform.</p> Source code in <code>src/bloqade/factory.py</code> <pre><code>@beartype\ndef piecewise_linear(durations: List[ScalarType], values: List[ScalarType]) -&gt; Waveform:\n    \"\"\"Create a piecewise linear waveform.\n\n    Create a piecewise linear waveform from a list of durations and values. The\n    value `duration[i]` is of the linear segment between `values[i]` and `values[i+1]`.\n\n    Args:\n        durations (List[ScalarType]): The duration of each segment\n        values (List[ScalarType]): The values for each segment\n\n    Raises:\n        ValueError: If the length of `values` is not one greater than the length of\n        `durations`.\n\n    Returns:\n        Waveform: The piecewise linear waveform.\n    \"\"\"\n\n    if len(durations) + 1 != len(values):\n        raise ValueError(\n            \"The length of values must be one greater than the length of durations\"\n        )\n\n    pwl_wf = None\n    for duration, start, stop in zip(durations, values[:-1], values[1:]):\n        if pwl_wf is None:\n            pwl_wf = Linear(start, stop, duration)\n        else:\n            pwl_wf = pwl_wf.append(Linear(start, stop, duration))\n\n    return pwl_wf\n</code></pre>"},{"location":"reference/bloqade/#bloqade.rydberg_h","title":"rydberg_h","text":"<pre><code>rydberg_h(\n    atoms_positions,\n    detuning=None,\n    amplitude=None,\n    phase=None,\n    static_params={},\n    batch_params=[],\n    args=[],\n)\n</code></pre> <p>Create a rydberg program with uniform detuning, amplitude, and phase.</p> <p>Parameters:</p> Name Type Description Default <code>atoms_positions</code> <code>Any</code> <p>Description of geometry of atoms in system.</p> required <code>detuning</code> <code>Optional[Waveform]</code> <p>Waveform for detuning. Defaults to None.</p> <code>None</code> <code>amplitude</code> <code>Optional[Waveform]</code> <p>Waveform describing the amplitude of the rabi term. Defaults to None.</p> <code>None</code> <code>phase</code> <code>Optional[Waveform]</code> <p>Waveform describing the phase of rabi term. Defaults to None.</p> <code>None</code> <code>static_params</code> <code>Dict[str, Any]</code> <p>Define static parameters of your program. Defaults to {}.</p> <code>{}</code> <code>batch_params</code> <code>Union[List[Dict[str, Any]], Dict[str, Any]]</code> <p>Parmaters for a batch of tasks. Defaults to [].</p> <code>[]</code> <code>args</code> <code>List[str]</code> <p>List of arguments to leave till runtime. Defaults to [].</p> <code>[]</code> <p>Returns:</p> Name Type Description <code>Routine</code> <code>Routine</code> <p>An object that can be used to dispatch a rydberg program to multiple backends.</p> Source code in <code>src/bloqade/factory.py</code> <pre><code>@beartype\ndef rydberg_h(\n    atoms_positions: Any,\n    detuning: Optional[Waveform] = None,\n    amplitude: Optional[Waveform] = None,\n    phase: Optional[Waveform] = None,\n    static_params: Dict[str, Any] = {},\n    batch_params: Union[List[Dict[str, Any]], Dict[str, Any]] = [],\n    args: List[str] = [],\n) -&gt; Routine:\n    \"\"\"Create a rydberg program with uniform detuning, amplitude, and phase.\n\n    Args:\n        atoms_positions (Any): Description of geometry of atoms in system.\n        detuning (Optional[Waveform], optional): Waveform for detuning.\n            Defaults to None.\n        amplitude (Optional[Waveform], optional): Waveform describing the amplitude of\n            the rabi term. Defaults to None.\n        phase (Optional[Waveform], optional): Waveform describing the phase of rabi\n            term. Defaults to None.\n        static_params (Dict[str, Any], optional): Define static parameters of your\n            program. Defaults to {}.\n        batch_params (Union[List[Dict[str, Any]], Dict[str, Any]], optional):\n            Parmaters for a batch of tasks. Defaults to [].\n        args (List[str], optional): List of arguments to leave till runtime.\n            Defaults to [].\n\n    Returns:\n        Routine: An object that can be used to dispatch a rydberg program to\n            multiple backends.\n    \"\"\"\n    from bloqade import start\n    from bloqade.atom_arrangement import AtomArrangement\n\n    if isinstance(atoms_positions, AtomArrangement):\n        prog = atoms_positions\n    else:\n        prog = start.add_position(atoms_positions)\n\n    if detuning is not None:\n        prog = prog.rydberg.detuning.uniform.apply(detuning)\n\n    if amplitude is not None:\n        prog = prog.amplitude.uniform.apply(amplitude)\n\n    if phase is not None:\n        prog = prog.phase.uniform.apply(phase)\n\n    prog = prog.assign(**static_params)\n\n    if isinstance(batch_params, dict):\n        prog = prog.batch_assign(**batch_params)\n    else:\n        prog = prog.batch_assign(batch_params)\n\n    prog = prog.args(args)\n\n    return prog.parse()\n</code></pre>"},{"location":"reference/bloqade/#bloqade.save","title":"save","text":"<pre><code>save(o, fp, use_decimal=True, **json_kwargs)\n</code></pre> <p>Serialize object to file</p> <p>Parameters:</p> Name Type Description Default <code>o</code> <code>Any</code> <p>the object to serialize</p> required <code>fp</code> <code>Union[TextIO, str]</code> <p>the file path or file object</p> required <code>use_decimal</code> <code>bool</code> <p>use decimal.Decimal for numbers. Defaults to True.</p> <code>True</code> <code>**json_kwargs</code> <p>other arguments passed to json.dump</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/bloqade/serialize.py</code> <pre><code>@beartype\ndef save(\n    o: Any,\n    fp: Union[TextIO, str],\n    use_decimal=True,\n    **json_kwargs,\n) -&gt; None:\n    \"\"\"Serialize object to file\n\n    Args:\n        o (Any): the object to serialize\n        fp (Union[TextIO, str]): the file path or file object\n        use_decimal (bool, optional): use decimal.Decimal for numbers. Defaults to True.\n        **json_kwargs: other arguments passed to json.dump\n\n    Returns:\n        None\n    \"\"\"\n    if not isinstance(o, Serializer.types):\n        raise TypeError(\n            f\"Object of type {type(o)} is not JSON serializable. \"\n            f\"Only {Serializer.types} are supported.\"\n        )\n    if isinstance(fp, str):\n        with open(fp, \"w\") as f:\n            json.dump(o, f, cls=Serializer, use_decimal=use_decimal, **json_kwargs)\n    else:\n        json.dump(o, fp, cls=Serializer, use_decimal=use_decimal, **json_kwargs)\n</code></pre>"},{"location":"reference/bloqade/#bloqade.tree_depth","title":"tree_depth","text":"<pre><code>tree_depth(depth=None)\n</code></pre> <p>Setting globally maximum depth for tree printing</p> <p>If <code>depth=None</code>, return current depth. If <code>depth</code> is provided, setting current depth to <code>depth</code></p> <p>Parameters:</p> Name Type Description Default <code>depth</code> <code>int</code> <p>the user specified depth. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <p>current updated depth</p> Source code in <code>src/bloqade/__init__.py</code> <pre><code>def tree_depth(depth: int = None):\n    \"\"\"Setting globally maximum depth for tree printing\n\n    If `depth=None`, return current depth.\n    If `depth` is provided, setting current depth to `depth`\n\n    Args:\n        depth (int, optional): the user specified depth. Defaults to None.\n\n    Returns:\n        int: current updated depth\n    \"\"\"\n    if depth is not None:\n        _ir.tree_print.max_tree_depth = depth\n    return _ir.tree_print.max_tree_depth\n</code></pre>"},{"location":"reference/bloqade/#bloqade.var","title":"var","text":"<pre><code>var(py)\n</code></pre> <p>cast string (or list/tuple of strings) to <code>Variable</code>.</p> <p>Parameters:</p> Name Type Description Default <code>py</code> <code>Union[str, List[str]]</code> <p>a string or list/tuple of strings</p> required <p>Returns:</p> Type Description <code>Variable</code> <p>Union[Variable]</p> Source code in <code>src/bloqade/ir/scalar.py</code> <pre><code>def var(py: str) -&gt; \"Variable\":\n    \"\"\"cast string (or list/tuple of strings)\n    to [`Variable`][bloqade.ir.scalar.Variable].\n\n    Args:\n        py (Union[str, List[str]]): a string or list/tuple of strings\n\n    Returns:\n       Union[Variable]\n    \"\"\"\n    ret = tryvar(py)\n    if ret is None:\n        raise TypeError(f\"Cannot cast {type(py)} to Variable\")\n\n    return ret\n</code></pre>"},{"location":"reference/bloqade/atom_arrangement/","title":"Atom arrangement","text":""},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.AtomArrangement","title":"AtomArrangement","text":"<p>             Bases: <code>ProgramStart</code>, <code>TransformTrait</code></p>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.AtomArrangement.n_atoms","title":"n_atoms  <code>property</code>","text":"<pre><code>n_atoms\n</code></pre> <p>number of atoms (filled sites) in the register.</p>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.AtomArrangement.n_dims","title":"n_dims  <code>property</code>","text":"<pre><code>n_dims\n</code></pre> <p>number of dimensions in the register.</p>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.AtomArrangement.n_sites","title":"n_sites  <code>property</code>","text":"<pre><code>n_sites\n</code></pre> <p>number of sites in the register.</p>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.AtomArrangement.n_vacant","title":"n_vacant  <code>property</code>","text":"<pre><code>n_vacant\n</code></pre> <p>number of vacant sites in the register.</p>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.AtomArrangement.enumerate","title":"enumerate","text":"<pre><code>enumerate()\n</code></pre> <p>enumerate all locations in the register.</p> Source code in <code>src/bloqade/ir/location/base.py</code> <pre><code>def enumerate(self) -&gt; Generator[LocationInfo, None, None]:\n    \"\"\"enumerate all locations in the register.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.AtomArrangement.figure","title":"figure","text":"<pre><code>figure(fig_kwargs=None, **assignments)\n</code></pre> <p>obtain a figure object from the atom arrangement.</p> Source code in <code>src/bloqade/ir/location/base.py</code> <pre><code>def figure(self, fig_kwargs=None, **assignments):\n    \"\"\"obtain a figure object from the atom arrangement.\"\"\"\n    return get_atom_arrangement_figure(self, fig_kwargs, **assignments)\n</code></pre>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.AtomArrangement.rydberg_interaction","title":"rydberg_interaction","text":"<pre><code>rydberg_interaction(**assignments)\n</code></pre> <p>calculate the Rydberg interaction matrix.</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>the values to assign to the variables in the register.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>the Rydberg interaction matrix in the lower triangular form.</p> Source code in <code>src/bloqade/ir/location/base.py</code> <pre><code>def rydberg_interaction(self, **assignments) -&gt; NDArray:\n    \"\"\"calculate the Rydberg interaction matrix.\n\n    Args:\n        **assignments: the values to assign to the variables in the register.\n\n    Returns:\n        NDArray: the Rydberg interaction matrix in the lower triangular form.\n\n    \"\"\"\n\n    from bloqade.constants import RB_C6\n\n    # calculate the Interaction matrix\n    V_ij = np.zeros((self.n_sites, self.n_sites))\n    for i, site_i in enumerate(self.enumerate()):\n        pos_i = np.array([float(ele(**assignments)) for ele in site_i.position])\n\n        for j, site_j in enumerate(self.enumerate()):\n            if j &gt;= i:\n                break  # enforce lower triangular form\n\n            pos_j = np.array([float(ele(**assignments)) for ele in site_j.position])\n            r_ij = np.linalg.norm(pos_i - pos_j)\n\n            V_ij[i, j] = RB_C6 / r_ij**6\n\n    return V_ij\n</code></pre>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.Chain","title":"Chain","text":"<pre><code>Chain(L, lattice_spacing=1.0, vertical_chain=False)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Chain lattice.</p> <ul> <li>1D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0).</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in the chain</p> required <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L: int, lattice_spacing: ScalarType = 1.0, vertical_chain: bool = False\n):\n    self.vertical = vertical_chain\n    super().__init__(L, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.Honeycomb","title":"Honeycomb","text":"<pre><code>Honeycomb(L1, L2=None, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Honeycomb lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (\u00bd, sqrt(3)/2)</li> </ul> </li> <li>unit cell (2 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (\u00bd, 1/(2*sqrt(3))</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of unit cells in linear direction. n_atoms = L1 * L1 * 2.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of unit cells in direction a2. n_atoms = L1 * L2 * 2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    super().__init__(L1, L2, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.Kagome","title":"Kagome","text":"<pre><code>Kagome(L1, L2=None, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Kagome lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (\u00bd, sqrt(3)/2)</li> </ul> </li> <li>unit cell (3 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (0.5, 0)</li> <li>loc3 (0.25 ,0.25sqrt(3))</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of sites in linear direction. n_atoms = 3 * L1 * L1.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of unit cells along a2 direction, n_atoms = 3 * L1 * L2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    super().__init__(L1, L2, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.Lieb","title":"Lieb","text":"<pre><code>Lieb(L1, L2=None, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Lieb lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (0, 1)</li> </ul> </li> <li>unit cell (3 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (0.5, 0)</li> <li>loc3 (0 ,0.5)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of unit cells in linear direction. n_atoms = 3* L1 * L1.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of unit cells along a2 direction, n_atoms = 3 * L1 * L2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    super().__init__(L1, L2, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.Rectangular","title":"Rectangular","text":"<pre><code>Rectangular(\n    width,\n    height,\n    lattice_spacing_x=1.0,\n    lattice_spacing_y=None,\n)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Rectangular lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0)</li> <li>a2 = (0,1)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>number of sites in x direction.</p> required <code>height</code> <code>int</code> <p>number of sites in y direction.</p> required <code>lattice_spacing_x</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <code>lattice_spacing_y</code> <code>(Scalar, Real)</code> <p>lattice spacing in y direction. optional.</p> <code>None</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    width: int,\n    height: int,\n    lattice_spacing_x: ScalarType = 1.0,\n    lattice_spacing_y: Optional[ScalarType] = None,\n):\n    super().__init__(width, height, lattice_spacing=lattice_spacing_x)\n\n    if lattice_spacing_y is None:\n        self.ratio = cast(1.0) / cast(lattice_spacing_x)\n    else:\n        self.ratio = cast(lattice_spacing_y) / cast(lattice_spacing_x)\n\n    super().__init__(width, height, lattice_spacing=lattice_spacing_x)\n</code></pre>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.Square","title":"Square","text":"<pre><code>Square(L1, L2=None, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Square lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0)</li> <li>a2 = (0,1)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L1 * L1.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of sites in direction a2. n_atoms = L1 * L2, default is L1</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    super().__init__(L1, L2, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/atom_arrangement/#bloqade.atom_arrangement.Triangular","title":"Triangular","text":"<pre><code>Triangular(L1, L2=None, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Triangular lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (\u00bd, sqrt(3)/2)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0, 0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L * L.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of sites along a2 direction, n_atoms = L1 * L2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    super().__init__(L1, L2, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/constants/","title":"Constants","text":""},{"location":"reference/bloqade/constants/#bloqade.constants.RB_C6","title":"RB_C6  <code>module-attribute</code>","text":"<pre><code>RB_C6 = 2 * pi * 862690\n</code></pre> <p>The C6 constant for the Rydberg Interaction of two Rubidium atoms in units of: rad \u03bcm^6/\u03bcs</p>"},{"location":"reference/bloqade/factory/","title":"Factory","text":""},{"location":"reference/bloqade/factory/#bloqade.factory.constant","title":"constant","text":"<pre><code>constant(duration, value)\n</code></pre> <p>Create a Constant waveform.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>ScalarType</code> <p>Duration of the Constant waveform.</p> required <code>value</code> <code>ScalarType</code> <p>Value of the Constant waveform.s</p> required <p>Returns:</p> Name Type Description <code>Constant</code> <code>Constant</code> <p>A Constant waveform.</p> Source code in <code>src/bloqade/factory.py</code> <pre><code>@beartype\ndef constant(duration: ScalarType, value: ScalarType) -&gt; Constant:\n    \"\"\"Create a Constant waveform.\n\n    Args:\n        duration (ScalarType): Duration of the Constant waveform.\n        value (ScalarType): Value of the Constant waveform.s\n\n    Returns:\n        Constant: A Constant waveform.\n    \"\"\"\n    return Constant(value, duration)\n</code></pre>"},{"location":"reference/bloqade/factory/#bloqade.factory.get_capabilities","title":"get_capabilities","text":"<pre><code>get_capabilities()\n</code></pre> <p>Get the device capabilities for Aquila</p> <p>Returns:</p> Name Type Description <code>QuEraCapabilities</code> <code>QuEraCapabilities</code> <p>capabilities object for Aquila device.</p> Note <p>Units of time, distance, and energy are microseconds (us), micrometers (um), and rad / us, respectively.</p> <p>For a comprehensive list of capabilities, see the Hardware Reference page</p> Source code in <code>src/bloqade/factory.py</code> <pre><code>def get_capabilities() -&gt; \"QuEraCapabilities\":\n    \"\"\"Get the device capabilities for Aquila\n\n    Returns:\n        QuEraCapabilities: capabilities object for Aquila device.\n\n\n    Note:\n        Units of time, distance, and energy are microseconds (us),\n        micrometers (um), and rad / us, respectively.\n\n        For a comprehensive list of capabilities,\n        see the [Hardware Reference](../../hardware-reference/hardware-capabilities.md)\n        page\n    \"\"\"\n\n    from bloqade.submission.capabilities import get_capabilities\n    import bloqade.submission.ir.capabilities as cp\n\n    capabilities_schema = get_capabilities()\n\n    capabilities = capabilities_schema.capabilities\n\n    # manually convert to units\n    return cp.QuEraCapabilities(\n        version=capabilities_schema.version,\n        capabilities=cp.DeviceCapabilities(\n            task=cp.TaskCapabilities(\n                number_shots_max=capabilities.task.number_shots_max,\n                number_shots_min=capabilities.task.number_shots_min,\n            ),\n            lattice=cp.LatticeCapabilities(\n                number_qubits_max=capabilities.lattice.number_qubits_max,\n                area=cp.LatticeAreaCapabilities(\n                    width=(capabilities.lattice.area.width * Decimal(\"1e6\")),  # m\n                    height=(capabilities.lattice.area.height * Decimal(\"1e6\")),  # m\n                ),\n                geometry=cp.LatticeGeometryCapabilities(\n                    number_sites_max=capabilities.lattice.geometry.number_sites_max,\n                    spacing_radial_min=(\n                        capabilities.lattice.geometry.spacing_radial_min\n                        * Decimal(\"1e6\")\n                    ),  # m\n                    spacing_vertical_min=(\n                        capabilities.lattice.geometry.spacing_vertical_min\n                        * Decimal(\"1e6\")\n                    ),  # m\n                    position_resolution=(\n                        capabilities.lattice.geometry.position_resolution\n                        * Decimal(\"1e6\")\n                    ),  # m\n                ),\n            ),\n            rydberg=cp.RydbergCapabilities(\n                c6_coefficient=capabilities.rydberg.c6_coefficient\n                * Decimal(\"1e30\"),  # rad * m^6 / s\n                global_=cp.RydbergGlobalCapabilities(\n                    phase_max=(capabilities.rydberg.global_.phase_max),  # rad\n                    phase_min=(capabilities.rydberg.global_.phase_min),  # rad\n                    phase_resolution=(\n                        capabilities.rydberg.global_.phase_resolution\n                    ),  # rad\n                    rabi_frequency_max=(\n                        capabilities.rydberg.global_.rabi_frequency_max / Decimal(\"1e6\")\n                    ),  # rad / s\n                    rabi_frequency_min=(\n                        capabilities.rydberg.global_.rabi_frequency_min / Decimal(\"1e6\")\n                    ),  # rad / s\n                    rabi_frequency_resolution=(\n                        capabilities.rydberg.global_.rabi_frequency_resolution\n                        / Decimal(\"1e6\")\n                    ),  # rad / s\n                    rabi_frequency_slew_rate_max=(\n                        capabilities.rydberg.global_.rabi_frequency_slew_rate_max\n                        / Decimal(\"1e6\") ** 2\n                    ),  # rad / s^2\n                    detuning_max=(\n                        capabilities.rydberg.global_.detuning_max / Decimal(\"1e6\")\n                    ),  # rad / s\n                    detuning_min=(\n                        capabilities.rydberg.global_.detuning_min / Decimal(\"1e6\")\n                    ),  # rad / s\n                    detuning_resolution=(\n                        capabilities.rydberg.global_.detuning_resolution\n                        / Decimal(\"1e6\")\n                    ),  # rad / s\n                    detuning_slew_rate_max=(\n                        capabilities.rydberg.global_.detuning_slew_rate_max\n                        / Decimal(\"1e6\") ** 2\n                    ),  # rad / s^2\n                    time_min=(\n                        capabilities.rydberg.global_.time_min * Decimal(\"1e6\")\n                    ),  # s\n                    time_max=(\n                        capabilities.rydberg.global_.time_max * Decimal(\"1e6\")\n                    ),  # s\n                    time_resolution=(\n                        capabilities.rydberg.global_.time_resolution * Decimal(\"1e6\")\n                    ),  # s\n                    time_delta_min=(\n                        capabilities.rydberg.global_.time_delta_min * Decimal(\"1e6\")\n                    ),  # s\n                ),\n                local=cp.RydbergLocalCapabilities(\n                    number_local_detuning_sites=(\n                        capabilities.rydberg.local.number_local_detuning_sites\n                    ),\n                    site_coefficient_max=(\n                        capabilities.rydberg.local.site_coefficient_max\n                    ),\n                    site_coefficient_min=(\n                        capabilities.rydberg.local.site_coefficient_min\n                    ),\n                    spacing_radial_min=(\n                        capabilities.rydberg.local.spacing_radial_min * Decimal(\"1e6\")\n                    ),  # rad / s\n                    detuning_min=(\n                        capabilities.rydberg.local.detuning_min / Decimal(\"1e6\")\n                    ),  # rad / s\n                    detuning_max=(\n                        capabilities.rydberg.local.detuning_max / Decimal(\"1e6\")\n                    ),  # rad / s\n                    detuning_slew_rate_max=(\n                        capabilities.rydberg.local.detuning_slew_rate_max\n                        / Decimal(\"1e6\") ** 2\n                    ),  # rad / s^2\n                    time_delta_min=(\n                        capabilities.rydberg.local.time_delta_min * Decimal(\"1e6\")\n                    ),  # s\n                    time_resolution=(\n                        capabilities.rydberg.local.time_resolution * Decimal(\"1e6\")\n                    ),  # s\n                ),\n            ),\n        ),\n    )\n</code></pre>"},{"location":"reference/bloqade/factory/#bloqade.factory.linear","title":"linear","text":"<pre><code>linear(duration, start, stop)\n</code></pre> <p>Create a Linear waveform.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>ScalarType</code> <p>Duration of linear waveform</p> required <code>start</code> <code>ScalarType</code> <p>Starting value of linear waveform</p> required <code>stop</code> <code>ScalarType</code> <p>Ending value of linear waveform</p> required <p>Returns:</p> Name Type Description <code>Linear</code> <code>Linear</code> <p>Linear waveform</p> Source code in <code>src/bloqade/factory.py</code> <pre><code>@beartype\ndef linear(duration: ScalarType, start: ScalarType, stop: ScalarType) -&gt; Linear:\n    \"\"\"Create a Linear waveform.\n\n    Args:\n        duration (ScalarType): Duration of linear waveform\n        start (ScalarType): Starting value of linear waveform\n        stop (ScalarType): Ending value of linear waveform\n\n    Returns:\n        Linear: Linear waveform\n    \"\"\"\n    return Linear(start, stop, duration)\n</code></pre>"},{"location":"reference/bloqade/factory/#bloqade.factory.piecewise_constant","title":"piecewise_constant","text":"<pre><code>piecewise_constant(durations, values)\n</code></pre> <p>Create a piecewise linear waveform.</p> <p>Create a piecewise constant waveform from a list of durations and values. The value <code>duration[i]</code> corresponds to the length of time for the i'th segment with a value of <code>values[i]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>durations</code> <code>List[ScalarType]</code> <p>The duration of each segment</p> required <code>values</code> <code>List[ScalarType]</code> <p>The values for each segment</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the length of <code>values</code> is not the same as the length of</p> <p>Returns:</p> Name Type Description <code>Waveform</code> <code>Waveform</code> <p>The piecewise linear waveform.</p> Source code in <code>src/bloqade/factory.py</code> <pre><code>@beartype\ndef piecewise_constant(\n    durations: List[ScalarType], values: List[ScalarType]\n) -&gt; Waveform:\n    \"\"\"Create a piecewise linear waveform.\n\n    Create a piecewise constant waveform from a list of durations and values. The\n    value `duration[i]` corresponds to the length of time for the i'th segment\n    with a value of `values[i]`.\n\n    Args:\n        durations (List[ScalarType]): The duration of each segment\n        values (List[ScalarType]): The values for each segment\n\n    Raises:\n        ValueError: If the length of `values` is not the same as the length of\n        `durations`.\n\n    Returns:\n        Waveform: The piecewise linear waveform.\n    \"\"\"\n    if len(durations) != len(values):\n        raise ValueError(\n            \"The length of values must be the same as the length of durations\"\n        )\n\n    pwc_wf = None\n    for duration, value in zip(durations, values):\n        if pwc_wf is None:\n            pwc_wf = Constant(value, duration)\n        else:\n            pwc_wf = pwc_wf.append(Constant(value, duration))\n\n    return pwc_wf\n</code></pre>"},{"location":"reference/bloqade/factory/#bloqade.factory.piecewise_linear","title":"piecewise_linear","text":"<pre><code>piecewise_linear(durations, values)\n</code></pre> <p>Create a piecewise linear waveform.</p> <p>Create a piecewise linear waveform from a list of durations and values. The value <code>duration[i]</code> is of the linear segment between <code>values[i]</code> and <code>values[i+1]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>durations</code> <code>List[ScalarType]</code> <p>The duration of each segment</p> required <code>values</code> <code>List[ScalarType]</code> <p>The values for each segment</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the length of <code>values</code> is not one greater than the length of</p> <p>Returns:</p> Name Type Description <code>Waveform</code> <code>Waveform</code> <p>The piecewise linear waveform.</p> Source code in <code>src/bloqade/factory.py</code> <pre><code>@beartype\ndef piecewise_linear(durations: List[ScalarType], values: List[ScalarType]) -&gt; Waveform:\n    \"\"\"Create a piecewise linear waveform.\n\n    Create a piecewise linear waveform from a list of durations and values. The\n    value `duration[i]` is of the linear segment between `values[i]` and `values[i+1]`.\n\n    Args:\n        durations (List[ScalarType]): The duration of each segment\n        values (List[ScalarType]): The values for each segment\n\n    Raises:\n        ValueError: If the length of `values` is not one greater than the length of\n        `durations`.\n\n    Returns:\n        Waveform: The piecewise linear waveform.\n    \"\"\"\n\n    if len(durations) + 1 != len(values):\n        raise ValueError(\n            \"The length of values must be one greater than the length of durations\"\n        )\n\n    pwl_wf = None\n    for duration, start, stop in zip(durations, values[:-1], values[1:]):\n        if pwl_wf is None:\n            pwl_wf = Linear(start, stop, duration)\n        else:\n            pwl_wf = pwl_wf.append(Linear(start, stop, duration))\n\n    return pwl_wf\n</code></pre>"},{"location":"reference/bloqade/factory/#bloqade.factory.rydberg_h","title":"rydberg_h","text":"<pre><code>rydberg_h(\n    atoms_positions,\n    detuning=None,\n    amplitude=None,\n    phase=None,\n    static_params={},\n    batch_params=[],\n    args=[],\n)\n</code></pre> <p>Create a rydberg program with uniform detuning, amplitude, and phase.</p> <p>Parameters:</p> Name Type Description Default <code>atoms_positions</code> <code>Any</code> <p>Description of geometry of atoms in system.</p> required <code>detuning</code> <code>Optional[Waveform]</code> <p>Waveform for detuning. Defaults to None.</p> <code>None</code> <code>amplitude</code> <code>Optional[Waveform]</code> <p>Waveform describing the amplitude of the rabi term. Defaults to None.</p> <code>None</code> <code>phase</code> <code>Optional[Waveform]</code> <p>Waveform describing the phase of rabi term. Defaults to None.</p> <code>None</code> <code>static_params</code> <code>Dict[str, Any]</code> <p>Define static parameters of your program. Defaults to {}.</p> <code>{}</code> <code>batch_params</code> <code>Union[List[Dict[str, Any]], Dict[str, Any]]</code> <p>Parmaters for a batch of tasks. Defaults to [].</p> <code>[]</code> <code>args</code> <code>List[str]</code> <p>List of arguments to leave till runtime. Defaults to [].</p> <code>[]</code> <p>Returns:</p> Name Type Description <code>Routine</code> <code>Routine</code> <p>An object that can be used to dispatch a rydberg program to multiple backends.</p> Source code in <code>src/bloqade/factory.py</code> <pre><code>@beartype\ndef rydberg_h(\n    atoms_positions: Any,\n    detuning: Optional[Waveform] = None,\n    amplitude: Optional[Waveform] = None,\n    phase: Optional[Waveform] = None,\n    static_params: Dict[str, Any] = {},\n    batch_params: Union[List[Dict[str, Any]], Dict[str, Any]] = [],\n    args: List[str] = [],\n) -&gt; Routine:\n    \"\"\"Create a rydberg program with uniform detuning, amplitude, and phase.\n\n    Args:\n        atoms_positions (Any): Description of geometry of atoms in system.\n        detuning (Optional[Waveform], optional): Waveform for detuning.\n            Defaults to None.\n        amplitude (Optional[Waveform], optional): Waveform describing the amplitude of\n            the rabi term. Defaults to None.\n        phase (Optional[Waveform], optional): Waveform describing the phase of rabi\n            term. Defaults to None.\n        static_params (Dict[str, Any], optional): Define static parameters of your\n            program. Defaults to {}.\n        batch_params (Union[List[Dict[str, Any]], Dict[str, Any]], optional):\n            Parmaters for a batch of tasks. Defaults to [].\n        args (List[str], optional): List of arguments to leave till runtime.\n            Defaults to [].\n\n    Returns:\n        Routine: An object that can be used to dispatch a rydberg program to\n            multiple backends.\n    \"\"\"\n    from bloqade import start\n    from bloqade.atom_arrangement import AtomArrangement\n\n    if isinstance(atoms_positions, AtomArrangement):\n        prog = atoms_positions\n    else:\n        prog = start.add_position(atoms_positions)\n\n    if detuning is not None:\n        prog = prog.rydberg.detuning.uniform.apply(detuning)\n\n    if amplitude is not None:\n        prog = prog.amplitude.uniform.apply(amplitude)\n\n    if phase is not None:\n        prog = prog.phase.uniform.apply(phase)\n\n    prog = prog.assign(**static_params)\n\n    if isinstance(batch_params, dict):\n        prog = prog.batch_assign(**batch_params)\n    else:\n        prog = prog.batch_assign(batch_params)\n\n    prog = prog.args(args)\n\n    return prog.parse()\n</code></pre>"},{"location":"reference/bloqade/serialize/","title":"Serialize","text":""},{"location":"reference/bloqade/serialize/#bloqade.serialize.dumps","title":"dumps","text":"<pre><code>dumps(o, use_decimal=True, **json_kwargs)\n</code></pre> <p>Serialize object to string</p> <p>Parameters:</p> Name Type Description Default <code>o</code> <code>Any</code> <p>the object to serialize</p> required <code>use_decimal</code> <code>bool</code> <p>use decimal.Decimal for numbers. Defaults to True.</p> <code>True</code> <code>**json_kwargs</code> <p>other arguments passed to json.dumps</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the serialized object as a string</p> Source code in <code>src/bloqade/serialize.py</code> <pre><code>@beartype\ndef dumps(\n    o: Any,\n    use_decimal: bool = True,\n    **json_kwargs,\n) -&gt; str:\n    \"\"\"Serialize object to string\n\n    Args:\n        o (Any): the object to serialize\n        use_decimal (bool, optional): use decimal.Decimal for numbers. Defaults to True.\n        **json_kwargs: other arguments passed to json.dumps\n\n    Returns:\n        str: the serialized object as a string\n    \"\"\"\n    if not isinstance(o, Serializer.types):\n        raise TypeError(\n            f\"Object of type {type(o)} is not JSON serializable. \"\n            f\"Only {Serializer.types} are supported.\"\n        )\n    return json.dumps(o, cls=Serializer, use_decimal=use_decimal, **json_kwargs)\n</code></pre>"},{"location":"reference/bloqade/serialize/#bloqade.serialize.load","title":"load","text":"<pre><code>load(fp, use_decimal=True, **json_kwargs)\n</code></pre> <p>Load object from file</p> <p>Parameters:</p> Name Type Description Default <code>fp</code> <code>Union[TextIO, str]</code> <p>the file path or file object</p> required <code>use_decimal</code> <code>bool</code> <p>use decimal.Decimal for numbers. Defaults to True.</p> <code>True</code> <code>**json_kwargs</code> <p>other arguments passed to json.load</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>the deserialized object</p> Source code in <code>src/bloqade/serialize.py</code> <pre><code>@beartype\ndef load(fp: Union[TextIO, str], use_decimal: bool = True, **json_kwargs):\n    \"\"\"Load object from file\n\n    Args:\n        fp (Union[TextIO, str]): the file path or file object\n        use_decimal (bool, optional): use decimal.Decimal for numbers. Defaults to True.\n        **json_kwargs: other arguments passed to json.load\n\n    Returns:\n        Any: the deserialized object\n    \"\"\"\n    load_bloqade()\n    if isinstance(fp, str):\n        with open(fp, \"r\") as f:\n            return json.load(\n                f,\n                object_hook=Serializer.object_hook,\n                use_decimal=use_decimal,\n                **json_kwargs,\n            )\n    else:\n        return json.load(\n            fp,\n            object_hook=Serializer.object_hook,\n            use_decimal=use_decimal,\n            **json_kwargs,\n        )\n</code></pre>"},{"location":"reference/bloqade/serialize/#bloqade.serialize.loads","title":"loads","text":"<pre><code>loads(s, use_decimal=True, **json_kwargs)\n</code></pre> <p>Load object from string</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>the string to load</p> required <code>use_decimal</code> <code>bool</code> <p>use decimal.Decimal for numbers. Defaults to True.</p> <code>True</code> <code>**json_kwargs</code> <p>other arguments passed to json.loads</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>the deserialized object</p> Source code in <code>src/bloqade/serialize.py</code> <pre><code>@beartype\ndef loads(s: str, use_decimal: bool = True, **json_kwargs):\n    \"\"\"Load object from string\n\n    Args:\n        s (str): the string to load\n        use_decimal (bool, optional): use decimal.Decimal for numbers. Defaults to True.\n        **json_kwargs: other arguments passed to json.loads\n\n    Returns:\n        Any: the deserialized object\n    \"\"\"\n    load_bloqade()\n    return json.loads(\n        s, object_hook=Serializer.object_hook, use_decimal=use_decimal, **json_kwargs\n    )\n</code></pre>"},{"location":"reference/bloqade/serialize/#bloqade.serialize.save","title":"save","text":"<pre><code>save(o, fp, use_decimal=True, **json_kwargs)\n</code></pre> <p>Serialize object to file</p> <p>Parameters:</p> Name Type Description Default <code>o</code> <code>Any</code> <p>the object to serialize</p> required <code>fp</code> <code>Union[TextIO, str]</code> <p>the file path or file object</p> required <code>use_decimal</code> <code>bool</code> <p>use decimal.Decimal for numbers. Defaults to True.</p> <code>True</code> <code>**json_kwargs</code> <p>other arguments passed to json.dump</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/bloqade/serialize.py</code> <pre><code>@beartype\ndef save(\n    o: Any,\n    fp: Union[TextIO, str],\n    use_decimal=True,\n    **json_kwargs,\n) -&gt; None:\n    \"\"\"Serialize object to file\n\n    Args:\n        o (Any): the object to serialize\n        fp (Union[TextIO, str]): the file path or file object\n        use_decimal (bool, optional): use decimal.Decimal for numbers. Defaults to True.\n        **json_kwargs: other arguments passed to json.dump\n\n    Returns:\n        None\n    \"\"\"\n    if not isinstance(o, Serializer.types):\n        raise TypeError(\n            f\"Object of type {type(o)} is not JSON serializable. \"\n            f\"Only {Serializer.types} are supported.\"\n        )\n    if isinstance(fp, str):\n        with open(fp, \"w\") as f:\n            json.dump(o, f, cls=Serializer, use_decimal=use_decimal, **json_kwargs)\n    else:\n        json.dump(o, fp, cls=Serializer, use_decimal=use_decimal, **json_kwargs)\n</code></pre>"},{"location":"reference/bloqade/analysis/","title":"Index","text":""},{"location":"reference/bloqade/analysis/common/","title":"Index","text":""},{"location":"reference/bloqade/analysis/common/assignment_scan/","title":"Assignment scan","text":""},{"location":"reference/bloqade/analysis/common/is_constant/","title":"Is constant","text":""},{"location":"reference/bloqade/analysis/common/is_hyperfine/","title":"Is hyperfine","text":""},{"location":"reference/bloqade/analysis/common/scan_variables/","title":"Scan variables","text":""},{"location":"reference/bloqade/analysis/python/","title":"Index","text":""},{"location":"reference/bloqade/analysis/python/waveform/","title":"Waveform","text":""},{"location":"reference/bloqade/builder/","title":"Index","text":""},{"location":"reference/bloqade/builder/args/","title":"Args","text":""},{"location":"reference/bloqade/builder/assign/","title":"Assign","text":""},{"location":"reference/bloqade/builder/coupling/","title":"Coupling","text":""},{"location":"reference/bloqade/builder/coupling/#bloqade.builder.coupling.Hyperfine","title":"Hyperfine","text":"<p>             Bases: <code>LevelCoupling</code></p> <p>This node represent level coupling between hyperfine state.</p> <p>Examples:</p> <pre><code>- To reach the node from the start node:\n\n&gt;&gt;&gt; node = bloqade.start.hyperfine\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.coupling.Hyperfine'&gt;\n\n- Hyperfine level coupling have two reachable field nodes:\n\n    - detuning term (See also [`Detuning`][bloqade.builder.field.Detuning])\n    - rabi term (See also [`Rabi`][bloqade.builder.field.Rabi])\n\n&gt;&gt;&gt; hyp_detune = bloqade.start.hyperfine.detuning\n&gt;&gt;&gt; hyp_rabi = bloqade.start.hyperfine.rabi\n</code></pre>"},{"location":"reference/bloqade/builder/coupling/#bloqade.builder.coupling.LevelCoupling","title":"LevelCoupling","text":"<p>             Bases: <code>Builder</code></p>"},{"location":"reference/bloqade/builder/coupling/#bloqade.builder.coupling.LevelCoupling.detuning","title":"detuning  <code>property</code>","text":"<pre><code>detuning\n</code></pre> <p>Specify the <code>Detuning</code> <code>Field</code> of your program.</p> <p>A \"field\" is a summation of one or more \"drives\", with a drive being the sum of a waveform and spatial modulation.</p> <p>You are currently building the spatial modulation component and will be able to specify a waveform.</p> <ul> <li>You can do this by:<ul> <li><code>...detuning.uniform</code>: To address all atoms in the field</li> <li><code>...detuning.location(locations, scales)</code>: To address atoms at specific     locations via indices</li> <li><code>...detuning.scale(coeffs)</code><ul> <li>To address all atoms with an individual scale factor</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/bloqade/builder/coupling/#bloqade.builder.coupling.LevelCoupling.rabi","title":"rabi  <code>property</code>","text":"<pre><code>rabi\n</code></pre> <p>Specify the complex-valued <code>Rabi</code> field of your program.</p> <p>The Rabi field is composed of a real-valued Amplitude and Phase field.</p> <ul> <li>Next possible steps to build your program are   creating the <code>RabiAmplitude</code> field   and <code>RabiPhase</code> field of the field:<ul> <li><code>...rabi.amplitude</code>: To create the Rabi amplitude field</li> <li><code>...rabi.phase</code>: To create the Rabi phase field</li> </ul> </li> </ul>"},{"location":"reference/bloqade/builder/coupling/#bloqade.builder.coupling.Rydberg","title":"Rydberg","text":"<p>             Bases: <code>LevelCoupling</code></p> <p>This node represent level coupling of rydberg state.</p> <p>Examples:</p> <pre><code>- To reach the node from the start node:\n\n&gt;&gt;&gt; node = bloqade.start.rydberg\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.coupling.Rydberg'&gt;\n\n- Rydberg level coupling have two reachable field nodes:\n\n    - detuning term (See also [`Detuning`][bloqade.builder.field.Detuning])\n    - rabi term (See also [`Rabi`][bloqade.builder.field.Rabi])\n\n&gt;&gt;&gt; ryd_detune = bloqade.start.rydberg.detuning\n&gt;&gt;&gt; ryd_rabi = bloqade.start.rydberg.rabi\n</code></pre>"},{"location":"reference/bloqade/builder/drive/","title":"Drive","text":""},{"location":"reference/bloqade/builder/drive/#bloqade.builder.drive.Drive","title":"Drive","text":""},{"location":"reference/bloqade/builder/drive/#bloqade.builder.drive.Drive.hyperfine","title":"hyperfine  <code>property</code>","text":"<pre><code>hyperfine\n</code></pre> <p>Address the Hyperfine level coupling in your program.</p> <ul> <li>Next possible steps to build your program are specifying the   <code>Rabi</code> field or   <code>Detuning</code> field.<ul> <li><code>...hyperfine.rabi</code>: for Rabi field</li> <li><code>...hyperfine.detuning</code>: for Detuning field</li> </ul> </li> <li>In the absence of a field you the value is set to zero by default.</li> </ul>"},{"location":"reference/bloqade/builder/drive/#bloqade.builder.drive.Drive.rydberg","title":"rydberg  <code>property</code>","text":"<pre><code>rydberg\n</code></pre> <p>Address the Rydberg level coupling in your program.</p> <ul> <li>Next possible steps to build your program are specifying the   <code>Rabi</code> field or   <code>Detuning</code> field.<ul> <li><code>...rydberg.rabi</code>: for Rabi field</li> <li><code>...rydberg.detuning</code>: for Detuning field</li> </ul> </li> <li>In the absence of a field you the value is set to zero by default.</li> </ul>"},{"location":"reference/bloqade/builder/field/","title":"Field","text":""},{"location":"reference/bloqade/builder/field/#bloqade.builder.field.Detuning","title":"Detuning","text":"<p>             Bases: <code>Field</code></p> <p>This node represent detuning field of a specified level coupling (rydberg or hyperfine) type.</p> <p>Examples:</p> <pre><code>- To specify detuning of rydberg coupling:\n\n&gt;&gt;&gt; node = bloqade.start.rydberg.detuning\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.field.Detuning'&gt;\n\n- To specify detuning of hyperfine coupling:\n\n&gt;&gt;&gt; node = bloqade.start.hyperfine.detuning\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.field.Detuning'&gt;\n</code></pre> Note <p>This node is a SpatialModulation node. See <code>SpatialModulation</code> for additional options.</p>"},{"location":"reference/bloqade/builder/field/#bloqade.builder.field.Field","title":"Field","text":"<p>             Bases: <code>Builder</code></p>"},{"location":"reference/bloqade/builder/field/#bloqade.builder.field.Field.uniform","title":"uniform  <code>property</code>","text":"<pre><code>uniform\n</code></pre> <p>Address all atoms as part of defining the spatial modulation component of a drive.</p> <p>Next steps to build your program include choosing the waveform that will be summed with the spatial modulation to create a drive.</p> <p>The drive by itself, or the sum of subsequent drives (created by just chaining the construction of drives) will become the field (e.g. Detuning Field, Real-Valued Rabi Amplitude/Rabi Phase Field, etc.).</p> <ul> <li>You can now do:<ul> <li><code>...uniform.linear(start, stop, duration)</code> : to apply a linear waveform</li> <li><code>...uniform.constant(value, duration)</code> : to apply a constant waveform</li> <li><code>...uniform.poly([coefficients], duration)</code> : to apply a     polynomial waveform</li> <li><code>...uniform.apply(wf:bloqade.ir.Waveform)</code>: to apply a pre-defined waveform</li> <li><code>...uniform.piecewise_linear([durations], [values])</code>:  to apply a piecewise linear waveform</li> <li><code>...uniform.piecewise_constant([durations], [values])</code>: to apply a piecewise constant waveform</li> <li><code>...uniform.fn(f(t,...))</code>: to apply a function as a waveform</li> </ul> </li> </ul>"},{"location":"reference/bloqade/builder/field/#bloqade.builder.field.Field.location","title":"location","text":"<pre><code>location(labels, scales=None)\n</code></pre> <p>Address a single atom (or multiple) atoms.</p> <p>Address a single atom (or multiple) as part of defining the spatial modulation component of a drive. You can specify the atoms to target as a list of labels and a list of scales. The scales are used to multiply the waveform that is applied to the atom. You can also specify a single label and scale to target a single atom.</p> <p>Next steps to build your program include choosing the waveform that will be summed with the spatial modulation to create a drive.</p> <p>The drive by itself, or the sum of subsequent drives (created by just chaining the construction of drives) will become the field. (e.g. Detuning Field, Real-Valued Rabi Amplitude/Rabi Phase Field, etc.)</p>"},{"location":"reference/bloqade/builder/field/#bloqade.builder.field.Field.location--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; prog = start.add_position([(0,0),(1,4),(2,8)]).rydberg.rabi\n# to target a single atom with a waveform\n&gt;&gt;&gt; one_location_prog = prog.location(0)\n# to target a single atom with a scale\n&gt;&gt;&gt; one_location_prog = prog.location(0, 0.5)\n# to target multiple atoms with same waveform\n&gt;&gt;&gt; multi_location_prog = prog.location([0, 2])\n# to target multiple atoms with different scales\n&gt;&gt;&gt; multi_location_prog = prog.location([0, 2], [0.5, \"scale\"])\n</code></pre> <ul> <li>You can now do:<ul> <li><code>...location(labels, scales).linear(start, stop, duration)</code> : to apply     a linear waveform</li> <li><code>...location(labels, scales).constant(value, duration)</code> : to apply     a constant waveform</li> <li><code>...location(labels, scales).poly([coefficients], duration)</code> : to apply     a polynomial waveform</li> <li><code>...location(labels, scales).apply(wf:bloqade.ir.Waveform)</code>: to apply     a pre-defined waveform</li> <li><code>...location(labels, scales).piecewise_linear([durations], [values])</code>:     to apply     a piecewise linear waveform</li> <li><code>...location(labels, scales).piecewise_constant([durations], [values])</code>:     to apply     a piecewise constant waveform</li> <li><code>...location(labels, scales).fn(f(t,..))</code>: to apply a function as a     waveform</li> </ul> </li> </ul> Source code in <code>src/bloqade/builder/field.py</code> <pre><code>def location(\n    self,\n    labels: Union[List[int], int],\n    scales: Union[List[ScalarType], ScalarType, None] = None,\n) -&gt; \"Location\":\n    \"\"\"Address a single atom (or multiple) atoms.\n\n    Address a single atom (or multiple) as part of defining the spatial\n    modulation component of a drive. You can specify the atoms to target\n    as a list of labels and a list of scales. The scales are used to\n    multiply the waveform that is applied to the atom. You can also specify\n    a single label and scale to target a single atom.\n\n    Next steps to build your program include choosing the waveform that\n    will be summed with the spatial modulation to create a drive.\n\n    The drive by itself, or the sum of subsequent drives (created by just\n    chaining the construction of drives) will become the field.\n    (e.g. Detuning Field, Real-Valued Rabi Amplitude/Rabi Phase Field, etc.)\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; prog = start.add_position([(0,0),(1,4),(2,8)]).rydberg.rabi\n    # to target a single atom with a waveform\n    &gt;&gt;&gt; one_location_prog = prog.location(0)\n    # to target a single atom with a scale\n    &gt;&gt;&gt; one_location_prog = prog.location(0, 0.5)\n    # to target multiple atoms with same waveform\n    &gt;&gt;&gt; multi_location_prog = prog.location([0, 2])\n    # to target multiple atoms with different scales\n    &gt;&gt;&gt; multi_location_prog = prog.location([0, 2], [0.5, \"scale\"])\n    ```\n\n    - You can now do:\n        - `...location(labels, scales).linear(start, stop, duration)` : to apply\n            a linear waveform\n        - `...location(labels, scales).constant(value, duration)` : to apply\n            a constant waveform\n        - `...location(labels, scales).poly([coefficients], duration)` : to apply\n            a polynomial waveform\n        - `...location(labels, scales).apply(wf:bloqade.ir.Waveform)`: to apply\n            a pre-defined waveform\n        - `...location(labels, scales).piecewise_linear([durations], [values])`:\n            to apply\n            a piecewise linear waveform\n        - `...location(labels, scales).piecewise_constant([durations], [values])`:\n            to apply\n            a piecewise constant waveform\n        - `...location(labels, scales).fn(f(t,..))`: to apply a function as a\n            waveform\n\n    \"\"\"\n    return self._location(labels, scales)\n</code></pre>"},{"location":"reference/bloqade/builder/field/#bloqade.builder.field.Field.scale","title":"scale","text":"<pre><code>scale(coeffs)\n</code></pre> <p>Address all the atoms scaling each atom with an element of the list or define a variable name for the scale list to be assigned later by defining a <code>name</code> and using <code>assign</code> or <code>batch_assign</code> later.</p> <p>Next steps to build your program include choosing the waveform that will be summed with the spatial modulation to create a drive.</p> <p>The drive by itself, or the sum of subsequent drives (created by just chaining the construction of drives) will become the field (e.g. Detuning Field, Real-Valued Rabi Amplitude/Rabi Phase Field, etc.)</p>"},{"location":"reference/bloqade/builder/field/#bloqade.builder.field.Field.scale--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; prog = start.add_position([(0,0),(1,4),(2,8)]).rydberg.rabi\n\n# assign a literal list of values to scale each atom\n&gt;&gt;&gt; one_location_prog = prog.scale([0.1, 0.2, 0.3])\n# assign a variable name to be assigned later\n&gt;&gt;&gt; one_location_prog = prog.scale(\"a\")\n# \"a\" can be assigned in the END of the program during variable assignment\n# using a list of values, indicating the scaling for each atom\n&gt;&gt;&gt; single_assignment = ...assign(a = [0.1, 0.2, 0.3])\n# a list of lists, indicating a set of atoms should be targeted\n# for each task in a batch.\n&gt;&gt;&gt; batch_assignment = ...batch_assign(a = [list_1, list_2, list_3,...])\n</code></pre> <ul> <li>You can now do:<ul> <li><code>...scale(coeffs).linear(start, stop, duration)</code> : to apply     a linear waveform</li> <li><code>...scale(coeffs).constant(value, duration)</code> : to apply     a constant waveform</li> <li><code>...scale(coeffs).poly([coefficients], duration)</code> : to apply     a polynomial waveform</li> <li><code>...scale(coeffs).apply(wf:bloqade.ir.Waveform)</code>: to apply     a pre-defined waveform</li> <li><code>...scale(coeffs).piecewise_linear(durations, values)</code>:  to     apply a piecewise linear waveform</li> <li><code>...scale(coeffs).piecewise_constant(durations, values)</code>: to     apply a piecewise constant waveform</li> <li><code>...scale(coeffs).fn(f(t,..))</code>: to apply a function as a waveform</li> </ul> </li> </ul> Source code in <code>src/bloqade/builder/field.py</code> <pre><code>def scale(self, coeffs: Union[str, List[ScalarType]]) -&gt; \"Scale\":\n    \"\"\"\n    Address all the atoms scaling each atom with an element of the list\n    or define a variable name for the scale list to be assigned later by\n    defining a `name` and using `assign` or `batch_assign` later.\n\n    Next steps to build your program include choosing the waveform that\n    will be summed with the spatial modulation to create a drive.\n\n    The drive by itself, or the sum of subsequent drives (created by just\n    chaining the construction of drives) will become the field\n    (e.g. Detuning Field, Real-Valued Rabi Amplitude/Rabi Phase Field, etc.)\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; prog = start.add_position([(0,0),(1,4),(2,8)]).rydberg.rabi\n\n    # assign a literal list of values to scale each atom\n    &gt;&gt;&gt; one_location_prog = prog.scale([0.1, 0.2, 0.3])\n    # assign a variable name to be assigned later\n    &gt;&gt;&gt; one_location_prog = prog.scale(\"a\")\n    # \"a\" can be assigned in the END of the program during variable assignment\n    # using a list of values, indicating the scaling for each atom\n    &gt;&gt;&gt; single_assignment = ...assign(a = [0.1, 0.2, 0.3])\n    # a list of lists, indicating a set of atoms should be targeted\n    # for each task in a batch.\n    &gt;&gt;&gt; batch_assignment = ...batch_assign(a = [list_1, list_2, list_3,...])\n\n    ```\n\n    - You can now do:\n        - `...scale(coeffs).linear(start, stop, duration)` : to apply\n            a linear waveform\n        - `...scale(coeffs).constant(value, duration)` : to apply\n            a constant waveform\n        - `...scale(coeffs).poly([coefficients], duration)` : to apply\n            a polynomial waveform\n        - `...scale(coeffs).apply(wf:bloqade.ir.Waveform)`: to apply\n            a pre-defined waveform\n        - `...scale(coeffs).piecewise_linear(durations, values)`:  to\n            apply a piecewise linear waveform\n        - `...scale(coeffs).piecewise_constant(durations, values)`: to\n            apply a piecewise constant waveform\n        - `...scale(coeffs).fn(f(t,..))`: to apply a function as a waveform\n\n    \"\"\"\n    from bloqade.builder.spatial import Scale\n\n    return Scale(coeffs, self)\n</code></pre>"},{"location":"reference/bloqade/builder/field/#bloqade.builder.field.Rabi","title":"Rabi","text":"<p>             Bases: <code>Builder</code></p> <p>This node represent rabi field of a specified level coupling (rydberg or hyperfine) type.</p> <p>Examples:</p> <pre><code>- To specify rabi of rydberg coupling:\n\n&gt;&gt;&gt; node = bloqade.start.rydberg.rabi\n&lt;class 'bloqade.builder.field.Rabi'&gt;\n\n- To specify rabi of hyperfine coupling:\n\n&gt;&gt;&gt; node = bloqade.start.hyperfine.rabi\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.field.Rabi'&gt;\n</code></pre>"},{"location":"reference/bloqade/builder/field/#bloqade.builder.field.Rabi.amplitude","title":"amplitude  <code>property</code>","text":"<pre><code>amplitude\n</code></pre> <p>Specify the real-valued Rabi Amplitude field.</p> <p>Next steps to build your program focus on specifying a spatial modulation.</p> <p>The spatial modulation, when coupled with a waveform, completes the specification of a \"Drive\". One or more drives can be summed together automatically to create a field such as the Rabi Amplitude here.</p> <ul> <li>You can now<ul> <li><code>...amplitude.uniform</code>: Address all atoms in the field</li> <li><code>...amplitude.location(...)</code>: Scale atoms by their indices</li> <li><code>...amplitude.scale(...)</code>: Scale each atom with a value from a     list or assign a variable name to be assigned later</li> </ul> </li> </ul>"},{"location":"reference/bloqade/builder/field/#bloqade.builder.field.Rabi.phase","title":"phase  <code>property</code>","text":"<pre><code>phase\n</code></pre> <p>Specify the real-valued Rabi Phase field.</p> <p>Next steps to build your program focus on specifying a spatial modulation.</p> <p>The spatial modulation, when coupled with a waveform, completes the specification of a \"Drive\". One or more drives can be summed together automatically to create a field such as the Rabi Phase here.</p> <ul> <li>You can now<ul> <li><code>...amplitude.uniform</code>: Address all atoms in the field</li> <li><code>...amplitude.location(...)</code>: Scale atoms by their indices</li> <li><code>...amplitude.scale(...)</code>: Scale each atom with a value from a     list or assign a variable name to be assigned later</li> </ul> </li> </ul>"},{"location":"reference/bloqade/builder/field/#bloqade.builder.field.RabiAmplitude","title":"RabiAmplitude","text":"<p>             Bases: <code>Field</code></p> <p>This node represent amplitude of a rabi field.</p> <p>Examples:</p> <pre><code>- To specify rabi amplitude of rydberg coupling:\n\n&gt;&gt;&gt; node = bloqade.start.rydberg.rabi.amplitude\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.field.Amplitude'&gt;\n\n- To specify rabi amplitude of hyperfine coupling:\n\n&gt;&gt;&gt; node = bloqade.start.hyperfine.rabi.amplitude\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.field.Amplitude'&gt;\n</code></pre> Note <p>This node is a SpatialModulation node. See <code>SpatialModulation</code> for additional options.</p>"},{"location":"reference/bloqade/builder/field/#bloqade.builder.field.RabiPhase","title":"RabiPhase","text":"<p>             Bases: <code>Field</code></p> <p>This node represent phase of a rabi field.</p> <p>Examples:</p> <pre><code>- To specify rabi phase of rydberg coupling:\n\n&gt;&gt;&gt; node = bloqade.start.rydberg.rabi.phase\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.field.Phase'&gt;\n\n- To specify rabi phase of hyperfine coupling:\n\n&gt;&gt;&gt; node = bloqade.start.hyperfine.rabi.phase\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.field.Phase'&gt;\n</code></pre> Note <p>This node is a SpatialModulation node. See <code>SpatialModulation</code> for additional options.</p>"},{"location":"reference/bloqade/builder/parallelize/","title":"Parallelize","text":""},{"location":"reference/bloqade/builder/pragmas/","title":"Pragmas","text":""},{"location":"reference/bloqade/builder/pragmas/#bloqade.builder.pragmas.Assignable","title":"Assignable","text":""},{"location":"reference/bloqade/builder/pragmas/#bloqade.builder.pragmas.Assignable.assign","title":"assign","text":"<pre><code>assign(**assignments)\n</code></pre> <p>Assign values to variables declared previously in the program.</p> <p>This is reserved for variables that should only take single values OR for spatial modulations that were created with <code>.scale(str)</code> in which case you can pass in a list. This is the ONLY circumstance in which multiple values are allowed.</p>"},{"location":"reference/bloqade/builder/pragmas/#bloqade.builder.pragmas.Assignable.assign--usage-examples","title":"Usage Examples:","text":"<pre><code># define geometry\n&gt;&gt;&gt; reg = bloqade.start\n...       .add_position([(0,0),(1,1),(2,2),(3,3)])\n# define variables in program\n&gt;&gt;&gt; seq = reg.rydberg.detuning.uniform\n...       .linear(start=\"ival\",stop=1,duration=\"span_time\")\n# assign values to variables\n&gt;&gt;&gt; seq = seq.assign(span_time = 0.5, ival = 0.0)\n</code></pre> <ul> <li>You can now:<ul> <li><code>...assign(assignments).bloqade</code>: select the bloqade local     emulator backend</li> <li><code>...assign(assignments).braket</code>: select braket local emulator or     QuEra hardware</li> <li><code>...assign(assignments).device(specifier_string)</code>: select backend     by specifying a string</li> </ul> </li> <li>Assign multiple values to a single variable for a parameter sweep:<ul> <li><code>...assign(assignments).batch_assign(assignments)</code>:</li> </ul> </li> <li>Parallelize the program register, duplicating the geometry and waveform     sequence to take advantage of all available   space/qubits on the QPU:<ul> <li><code>...assign(assignments).parallelize(cluster_spacing)</code></li> </ul> </li> <li>Defer value assignment of certain variables to runtime:<ul> <li><code>...assign(assignments).args([previously_defined_vars])</code></li> </ul> </li> </ul> Source code in <code>src/bloqade/builder/pragmas.py</code> <pre><code>def assign(self, **assignments) -&gt; \"Assign\":\n    \"\"\"\n    Assign values to variables declared previously in the program.\n\n    This is reserved for variables that should only take single values OR\n    for spatial modulations that were created with `.scale(str)` in which case\n    you can pass in a list. This is the ONLY circumstance in which multiple\n    values are allowed.\n\n    ### Usage Examples:\n    ```\n    # define geometry\n    &gt;&gt;&gt; reg = bloqade.start\n    ...       .add_position([(0,0),(1,1),(2,2),(3,3)])\n    # define variables in program\n    &gt;&gt;&gt; seq = reg.rydberg.detuning.uniform\n    ...       .linear(start=\"ival\",stop=1,duration=\"span_time\")\n    # assign values to variables\n    &gt;&gt;&gt; seq = seq.assign(span_time = 0.5, ival = 0.0)\n    ```\n\n    - You can now:\n        - `...assign(assignments).bloqade`: select the bloqade local\n            emulator backend\n        - `...assign(assignments).braket`: select braket local emulator or\n            QuEra hardware\n        - `...assign(assignments).device(specifier_string)`: select backend\n            by specifying a string\n    - Assign multiple values to a single variable for a parameter sweep:\n        - `...assign(assignments).batch_assign(assignments)`:\n    - Parallelize the program register, duplicating the geometry and waveform\n        sequence to take advantage of all available\n      space/qubits on the QPU:\n        - `...assign(assignments).parallelize(cluster_spacing)`\n    - Defer value assignment of certain variables to runtime:\n        - `...assign(assignments).args([previously_defined_vars])`\n\n    \"\"\"\n    from bloqade.builder.assign import Assign\n\n    return Assign(assignments, parent=self)\n</code></pre>"},{"location":"reference/bloqade/builder/pragmas/#bloqade.builder.pragmas.BatchAssignable","title":"BatchAssignable","text":""},{"location":"reference/bloqade/builder/pragmas/#bloqade.builder.pragmas.BatchAssignable.batch_assign","title":"batch_assign","text":"<pre><code>batch_assign(__batch_params=[], **assignments)\n</code></pre> <p>Assign multiple values to a single variable to create a parameter sweep.</p> <p>Bloqade automatically handles the multiple programs this would generate and treats it as object with unified results for easy post-processing.</p> <p>NOTE: if you assign multiple values to multiple variables in your program, the values must be of the same length. Bloqade will NOT do a Cartesian product (e.g. if \"var1\" is assigned [1,2,3] and \"var2\" is assigned [4,5,6] then the resulting programs will have assignments [1,4], [2,5], [3,6]).</p>"},{"location":"reference/bloqade/builder/pragmas/#bloqade.builder.pragmas.BatchAssignable.batch_assign--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; reg = start.add_position([(0,0), (0, \"atom_distance\")])\n&gt;&gt;&gt; prog = reg.rydberg.rabi.amplitude.uniform.constant(\"value\", 5.0)\n&gt;&gt;&gt; var_assigned_prog = prog.batch_assign(value = [1.0, 2.0, 3.0],\natom_distance = [1.0, 2.0, 3.0])\n</code></pre> <ul> <li>Next steps are:<ul> <li><code>...batch_assign(assignments).bloqade</code>: select the bloqade     local emulator backend</li> <li><code>...batch_assign(assignments).braket</code>: select braket local emulator or QuEra hardware</li> <li><code>...batch_assign(assignments).device(specifier_string)</code>: select backend by specifying a string</li> </ul> </li> <li>Parallelize the program register, duplicating the geometry and waveform   sequence to take advantage of all available   space/qubits on the QPU:<ul> <li><code>...batch_assign(assignments).parallelize(cluster_spacing)</code></li> </ul> </li> <li>Defer value assignment of certain variables to runtime:<ul> <li><code>...batch_assign(assignments).args([previously_defined_vars])</code></li> </ul> </li> </ul> Source code in <code>src/bloqade/builder/pragmas.py</code> <pre><code>def batch_assign(\n    self,\n    __batch_params: List[Dict[str, ParamType]] = [],\n    **assignments: List[ParamType],\n) -&gt; Union[\"BatchAssign\", \"ListAssign\"]:\n    \"\"\"\n\n    Assign multiple values to a single variable to create a parameter sweep.\n\n    Bloqade automatically handles the multiple programs this would generate\n    and treats it as object with unified results for easy post-processing.\n\n    NOTE: if you assign multiple values to multiple variables in your program,\n    the values must be of the same length. Bloqade will NOT do a Cartesian product\n    (e.g. if \"var1\" is assigned [1,2,3] and \"var2\" is assigned [4,5,6] then the\n    resulting programs will have assignments [1,4], [2,5], [3,6]).\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; reg = start.add_position([(0,0), (0, \"atom_distance\")])\n    &gt;&gt;&gt; prog = reg.rydberg.rabi.amplitude.uniform.constant(\"value\", 5.0)\n    &gt;&gt;&gt; var_assigned_prog = prog.batch_assign(value = [1.0, 2.0, 3.0],\n    atom_distance = [1.0, 2.0, 3.0])\n    ```\n\n    - Next steps are:\n        - `...batch_assign(assignments).bloqade`: select the bloqade\n            local emulator backend\n        - `...batch_assign(assignments).braket`: select braket local\n        emulator or QuEra hardware\n        - `...batch_assign(assignments).device(specifier_string)`: select\n        backend by specifying a string\n    - Parallelize the program register, duplicating the geometry and waveform\n      sequence to take advantage of all available\n      space/qubits on the QPU:\n        - `...batch_assign(assignments).parallelize(cluster_spacing)`\n    - Defer value assignment of certain variables to runtime:\n        - `...batch_assign(assignments).args([previously_defined_vars])`\n\n    \"\"\"\n    from bloqade.builder.assign import BatchAssign, ListAssign\n\n    if len(__batch_params) &gt; 0 and assignments:\n        raise ValueError(\"batch_params and assignments cannot be used together.\")\n\n    if len(__batch_params) &gt; 0:\n        return ListAssign(__batch_params, parent=self)\n    else:\n        return BatchAssign(assignments, parent=self)\n</code></pre>"},{"location":"reference/bloqade/builder/pragmas/#bloqade.builder.pragmas.Parallelizable","title":"Parallelizable","text":""},{"location":"reference/bloqade/builder/pragmas/#bloqade.builder.pragmas.Parallelizable.parallelize","title":"parallelize","text":"<pre><code>parallelize(cluster_spacing)\n</code></pre> <p>Parallelize the current problem (register and sequence) by duplicating the geometry to take advantage of all available space/qubits on hardware.</p> <p>The singular argument lets you specify how far apart the clusters should be in micrometers.</p>"},{"location":"reference/bloqade/builder/pragmas/#bloqade.builder.pragmas.Parallelizable.parallelize--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; reg = start.add_position((0,0)).rydberg.rabi.uniform.amplitude\n.constant(1.0, 1.0)\n# copy-paste the geometry and waveforms\n&gt;&gt;&gt; parallelized_prog = reg.parallelize(24)\n</code></pre> <ul> <li>Your next steps are:      <code>...parallelize(cluster_spacing).bloqade</code>: select the bloqade         local emulator backend      <code>...parallelize(cluster_spacing).braket</code>: select braket         local emulator or QuEra hardware on the cloud      <code>...parallelize(cluster_spacing).device(specifier_string)</code>: select         backend by specifying a string</li> </ul> Source code in <code>src/bloqade/builder/pragmas.py</code> <pre><code>def parallelize(self, cluster_spacing: LiteralType) -&gt; \"Parallelize\":\n    \"\"\"\n\n    Parallelize the current problem (register and sequence) by duplicating\n    the geometry to take advantage of all available space/qubits on hardware.\n\n    The singular argument lets you specify how far apart the clusters\n    should be in micrometers.\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; reg = start.add_position((0,0)).rydberg.rabi.uniform.amplitude\n    .constant(1.0, 1.0)\n    # copy-paste the geometry and waveforms\n    &gt;&gt;&gt; parallelized_prog = reg.parallelize(24)\n    ```\n\n    - Your next steps are:\n         `...parallelize(cluster_spacing).bloqade`: select the bloqade\n            local emulator backend\n         `...parallelize(cluster_spacing).braket`: select braket\n            local emulator or QuEra hardware on the cloud\n         `...parallelize(cluster_spacing).device(specifier_string)`: select\n            backend by specifying a string\n\n    \"\"\"\n    from bloqade.builder.parallelize import Parallelize\n\n    return Parallelize(cluster_spacing, self)\n</code></pre>"},{"location":"reference/bloqade/builder/route/","title":"Route","text":""},{"location":"reference/bloqade/builder/sequence_builder/","title":"Sequence builder","text":""},{"location":"reference/bloqade/builder/spatial/","title":"Spatial","text":""},{"location":"reference/bloqade/builder/spatial/#bloqade.builder.spatial.Location","title":"Location","text":"<pre><code>Location(labels, scales, parent=None)\n</code></pre> <p>             Bases: <code>SpatialModulation</code></p> Source code in <code>src/bloqade/builder/spatial.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    labels: List[int],\n    scales: List[ScalarType],\n    parent: Optional[Builder] = None,\n) -&gt; None:\n    from bloqade.ir.scalar import cast\n\n    super().__init__(parent)\n    self._scaled_locations = {\n        label: cast(scale) for label, scale in zip(labels, scales)\n    }\n</code></pre>"},{"location":"reference/bloqade/builder/spatial/#bloqade.builder.spatial.Uniform","title":"Uniform","text":"<p>             Bases: <code>SpatialModulation</code></p> <p>The node specify a uniform spacial modulation. Which is ready to apply waveform (See <code>Waveform</code> for available waveform options)</p> <p>Examples:</p> <pre><code>- To hit this node from the start node:\n\n&gt;&gt;&gt; reg = bloqade.start.add_position([(0,0),(1,1),(2,2),(3,3)])\n&gt;&gt;&gt; loc = reg.rydberg.detuning.uniform\n\n- Apply Linear waveform:\n\n&gt;&gt;&gt; wv = bloqade.ir.Linear(start=0,stop=1,duration=0.5)\n&gt;&gt;&gt; reg = bloqade.start.add_position([(0,0),(1,1),(2,2),(3,3)])\n&gt;&gt;&gt; loc = reg.rydberg.detuning.uniform.apply(wv)\n</code></pre>"},{"location":"reference/bloqade/builder/start/","title":"Start","text":""},{"location":"reference/bloqade/builder/start/#bloqade.builder.start.ProgramStart","title":"ProgramStart","text":"<p>             Bases: <code>Drive</code>, <code>Builder</code></p> <p>ProgramStart is the base class for a starting/entry node for building a program.</p>"},{"location":"reference/bloqade/builder/start/#bloqade.builder.start.ProgramStart.apply","title":"apply","text":"<pre><code>apply(sequence)\n</code></pre> <p>Apply a pre-built sequence to a program.</p> <p>This allows you to build a program independent of any geometry and then <code>apply</code> the program to said geometry. Or, if you have a program you would like to try on multiple geometries you can trivially do so with this.</p> <p>Example Usage: <pre><code>&gt;&gt;&gt; from numpy import pi\n&gt;&gt;&gt; seq = start.rydberg.rabi.amplitude.constant(2.0 * pi, 4.5)\n# choose a geometry of interest to apply the program on\n&gt;&gt;&gt; from bloqade.atom_arrangement import Chain, Kagome\n&gt;&gt;&gt; complete_program = Chain(10).apply(seq)\n# you can .apply to as many geometries as you like\n&gt;&gt;&gt; another_complete_program = Kagome(3).apply(seq)\n</code></pre></p> <ul> <li>From here you can now do:<ul> <li><code>...assign(assignments).bloqade</code>: select the bloqade     local emulator backend</li> <li><code>...assign(assignments).braket</code>: select braket     local emulator or QuEra hardware</li> <li><code>...assign(assignments).device(specifier_string)</code>: select     backend by specifying a string</li> </ul> </li> <li>Assign multiple values to a single variable for a parameter sweep:<ul> <li><code>...assign(assignments).batch_assign(assignments)</code>:</li> </ul> </li> <li>Parallelize the program register, duplicating the geometry and waveform     sequence to take advantage of all available   space/qubits on the QPU:<ul> <li><code>...assign(assignments).parallelize(cluster_spacing)</code></li> </ul> </li> <li>Defer value assignment of certain variables to runtime:<ul> <li><code>...assign(assignments).args([previously_defined_vars])</code></li> </ul> </li> </ul> Source code in <code>src/bloqade/builder/start.py</code> <pre><code>@beartype\ndef apply(self, sequence: Sequence) -&gt; SequenceBuilder:\n    \"\"\"\n    Apply a pre-built sequence to a program.\n\n    This allows you to build a program independent of any geometry\n    and then `apply` the program to said geometry. Or, if you have a\n    program you would like to try on multiple geometries you can\n    trivially do so with this.\n\n    Example Usage:\n    ```\n    &gt;&gt;&gt; from numpy import pi\n    &gt;&gt;&gt; seq = start.rydberg.rabi.amplitude.constant(2.0 * pi, 4.5)\n    # choose a geometry of interest to apply the program on\n    &gt;&gt;&gt; from bloqade.atom_arrangement import Chain, Kagome\n    &gt;&gt;&gt; complete_program = Chain(10).apply(seq)\n    # you can .apply to as many geometries as you like\n    &gt;&gt;&gt; another_complete_program = Kagome(3).apply(seq)\n    ```\n\n    - From here you can now do:\n        - `...assign(assignments).bloqade`: select the bloqade\n            local emulator backend\n        - `...assign(assignments).braket`: select braket\n            local emulator or QuEra hardware\n        - `...assign(assignments).device(specifier_string)`: select\n            backend by specifying a string\n    - Assign multiple values to a single variable for a parameter sweep:\n        - `...assign(assignments).batch_assign(assignments)`:\n    - Parallelize the program register, duplicating the geometry and waveform\n        sequence to take advantage of all available\n      space/qubits on the QPU:\n        - `...assign(assignments).parallelize(cluster_spacing)`\n    - Defer value assignment of certain variables to runtime:\n        - `...assign(assignments).args([previously_defined_vars])`\n\n    \"\"\"\n    return SequenceBuilder(sequence, self)\n</code></pre>"},{"location":"reference/bloqade/builder/typing/","title":"Typing","text":""},{"location":"reference/bloqade/builder/waveform/","title":"Waveform","text":""},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.Recordable","title":"Recordable","text":""},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.Recordable.record","title":"record","text":"<pre><code>record(name)\n</code></pre> <p>Copy or \"record\" the value at the end of the waveform into a variable so that it can be used in another place.</p> <p>A common design pattern is to couple this with <code>.slice()</code> considering you may not know exactly what the end value of a <code>.slice()</code> is, especially in parameter sweeps where it becomes cumbersome to handle.</p> <p>If you specified a spatial modulation (e.g. <code>uniform</code>, <code>location</code>,<code>scale</code>) previously without a waveform you will now have completed the construction of a \"drive\", one or a sum of drives creating a \"field\" (e.g. Real-valued Rabi Amplitude/Phase).</p> <p>If you have already specified a waveform previously you will now be appending this waveform to that previous waveform.</p>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.Recordable.record--usage-example","title":"Usage Example:","text":"<pre><code># define program of interest\n&gt;&gt;&gt; from bloqade import start\n&gt;&gt;&gt; prog = start.rydberg.rabi.amplitude.uniform\n&gt;&gt;&gt; prog_with_wf = prog.piecewise_linear(durations=[0.3, 2.0, 0.3],\nvalues=[0.0, 2.0, 2.0, 0.0])\n# We now slice the piecewise_linear from above and record the\n# value at the end of that slice. We then use that value\n# to construct a new waveform that can be appended to the previous\n# one without introducing discontinuity (refer to the\n# \"Quantum Scar Dynamics\" tutorial for how this could be handy)\n&gt;&gt;&gt; prog_with_record = prog_with_wf.slice(0.0, 1.0).record(\"end_of_wf\")\n&gt;&gt;&gt; record_applied_prog = prog_with_record.linear(start=\"end_of_wf\"\n, stop=0.0, duration=0.3)\n</code></pre> <ul> <li>Your next steps include:</li> <li>Continue building your waveform via:<ul> <li><code>...slice(start, stop).linear(start, stop, duration)</code>:     to append another linear waveform</li> <li><code>...slice(start, stop).constant(value, duration)</code>:     to append a constant waveform</li> <li><code>...slice(start, stop).piecewise_linear()</code>:     to append a piecewise linear waveform</li> <li><code>...slice(start, stop).piecewise_constant()</code>:     to append a piecewise constant waveform</li> <li><code>...slice(start, stop).poly([coefficients], duration)</code>:     to append a polynomial waveform</li> <li><code>...slice(start, stop).apply(wf:bloqade.ir.Waveform)</code>:     to append a pre-defined waveform</li> <li><code>...slilce(start, stop).fn(f(t,...))</code>:     to append a waveform defined by a python function</li> </ul> </li> <li>Begin constructing another drive by starting a new spatial modulation     (this drive will be summed to the one you just created):<ul> <li><code>...slice(start, stop).uniform</code>:     To address all atoms in the field</li> <li><code>...slice(start, stop).location(int)</code>:     To address an atom at a specific location via index</li> <li><code>...slice(start, stop).scale(str)</code><ul> <li>To address an atom at a specific location via variable</li> <li>To address multiple atoms at specific locations by specifying     a single variable and then assigning it a list of coordinates</li> </ul> </li> </ul> </li> <li>Assign values to pre-existing variables via:<ul> <li><code>...slice(start, stop).assign(variable_name = value)</code>:     to assign a single value to a variable</li> <li><code>...slice(start, stop)     .batch_assign(variable_name = [value1, ...])</code>:     to assign multiple values to a variable</li> <li><code>...slice(start, stop).args([\"previously_defined_var\"])</code>:     to defer assignment of a variable to execution time</li> </ul> </li> <li>Select the backend you want your program to run on via:<ul> <li><code>...slice(start, stop).braket</code>:     to run on Braket local emulator or QuEra hardware remotely</li> <li><code>...slice(start, stop).bloqade</code>:     to run on the Bloqade local emulator</li> <li><code>...slice(start, stop).device</code>:     to specify the backend via string</li> </ul> </li> <li>Choose to parallelize your atom geometry,   duplicating it to fill the whole space:<ul> <li><code>...slice(start, stop).parallelize(spacing)</code></li> </ul> </li> <li>Start targeting another level coupling<ul> <li><code>...slice(start, stop).rydberg</code>:     to target the Rydberg level coupling</li> <li><code>...slice(start, stop).hyperfine</code>:     to target the Hyperfine level coupling</li> </ul> </li> <li>Start targeting other fields within your current level coupling   (previously selected as <code>rydberg</code> or <code>hyperfine</code>):<ul> <li><code>...slice(start, stop).amplitude</code>:     to target the real-valued Rabi Amplitude field</li> <li><code>...slice(start, stop).phase</code>:     to target the real-valued Rabi Phase field</li> <li><code>...slice(start, stop).detuning</code>:     to target the Detuning field</li> <li><code>...slice(start, stop).rabi</code>:     to target the complex-valued Rabi field ```</li> </ul> </li> </ul> Source code in <code>src/bloqade/builder/waveform.py</code> <pre><code>@beartype\ndef record(self, name: str) -&gt; \"Record\":\n    \"\"\"\n    Copy or \"record\" the value at the end of the waveform into a variable\n    so that it can be used in another place.\n\n    A common design pattern is to couple this with `.slice()` considering\n    you may not know exactly what the end value of a `.slice()` is,\n    especially in parameter sweeps where it becomes cumbersome to handle.\n\n    If you specified a spatial modulation (e.g. `uniform`, `location`,`scale`)\n    previously without a waveform you will now have completed the construction\n    of a \"drive\", one or a sum of drives creating a \"field\"\n    (e.g. Real-valued Rabi Amplitude/Phase).\n\n    If you have already specified a waveform previously you will now be appending\n    this waveform to that previous waveform.\n\n    ### Usage Example:\n    ```\n    # define program of interest\n    &gt;&gt;&gt; from bloqade import start\n    &gt;&gt;&gt; prog = start.rydberg.rabi.amplitude.uniform\n    &gt;&gt;&gt; prog_with_wf = prog.piecewise_linear(durations=[0.3, 2.0, 0.3],\n    values=[0.0, 2.0, 2.0, 0.0])\n    # We now slice the piecewise_linear from above and record the\n    # value at the end of that slice. We then use that value\n    # to construct a new waveform that can be appended to the previous\n    # one without introducing discontinuity (refer to the\n    # \"Quantum Scar Dynamics\" tutorial for how this could be handy)\n    &gt;&gt;&gt; prog_with_record = prog_with_wf.slice(0.0, 1.0).record(\"end_of_wf\")\n    &gt;&gt;&gt; record_applied_prog = prog_with_record.linear(start=\"end_of_wf\"\n    , stop=0.0, duration=0.3)\n    ```\n\n    - Your next steps include:\n    - Continue building your waveform via:\n        - `...slice(start, stop).linear(start, stop, duration)`:\n            to append another linear waveform\n        - `...slice(start, stop).constant(value, duration)`:\n            to append a constant waveform\n        - `...slice(start, stop).piecewise_linear()`:\n            to append a piecewise linear waveform\n        - `...slice(start, stop).piecewise_constant()`:\n            to append a piecewise constant waveform\n        - `...slice(start, stop).poly([coefficients], duration)`:\n            to append a polynomial waveform\n        - `...slice(start, stop).apply(wf:bloqade.ir.Waveform)`:\n            to append a pre-defined waveform\n        - `...slilce(start, stop).fn(f(t,...))`:\n            to append a waveform defined by a python function\n    - Begin constructing another drive by starting a new spatial modulation\n        (this drive will be summed to the one you just created):\n        - `...slice(start, stop).uniform`:\n            To address all atoms in the field\n        - `...slice(start, stop).location(int)`:\n            To address an atom at a specific location via index\n        - `...slice(start, stop).scale(str)`\n            - To address an atom at a specific location via variable\n            - To address multiple atoms at specific locations by specifying\n                a single variable and then assigning it a list of coordinates\n    - Assign values to pre-existing variables via:\n        - `...slice(start, stop).assign(variable_name = value)`:\n            to assign a single value to a variable\n        - `...slice(start, stop)\n            .batch_assign(variable_name = [value1, ...])`:\n            to assign multiple values to a variable\n        - `...slice(start, stop).args([\"previously_defined_var\"])`:\n            to defer assignment of a variable to execution time\n    - Select the backend you want your program to run on via:\n        - `...slice(start, stop).braket`:\n            to run on Braket local emulator or QuEra hardware remotely\n        - `...slice(start, stop).bloqade`:\n            to run on the Bloqade local emulator\n        - `...slice(start, stop).device`:\n            to specify the backend via string\n    - Choose to parallelize your atom geometry,\n      duplicating it to fill the whole space:\n        - `...slice(start, stop).parallelize(spacing)`\n    - Start targeting another level coupling\n        - `...slice(start, stop).rydberg`:\n            to target the Rydberg level coupling\n        - `...slice(start, stop).hyperfine`:\n            to target the Hyperfine level coupling\n    - Start targeting other fields within your current level coupling\n      (previously selected as `rydberg` or `hyperfine`):\n        - `...slice(start, stop).amplitude`:\n            to target the real-valued Rabi Amplitude field\n        - `...slice(start, stop).phase`:\n            to target the real-valued Rabi Phase field\n        - `...slice(start, stop).detuning`:\n            to target the Detuning field\n        - `...slice(start, stop).rabi`:\n            to target the complex-valued Rabi field\n    ```\n    \"\"\"\n    return Record(name, self)\n</code></pre>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.Sliceable","title":"Sliceable","text":""},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.Sliceable.slice","title":"slice","text":"<pre><code>slice(start=None, stop=None)\n</code></pre> <p>Indicate that you only want a portion of your waveform to be used in the program.</p> <p>If you specified a spatial modulation (e.g. <code>uniform</code>, <code>location</code>,<code>scale</code>) previously without a waveform you will now have completed the construction of a \"drive\", one or a sum of drives creating a \"field\" (e.g. Real-valued Rabi Amplitude/Phase).</p> <p>If you have already specified a waveform previously you will now be appending this waveform to that previous waveform.</p>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.Sliceable.slice--usage-example","title":"Usage Example:","text":"<pre><code># define a program with a waveform of interest\n&gt;&gt;&gt; from bloqade import start\n&gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.rabi.amplitude.uniform\n&gt;&gt;&gt; prog_with_wf = prog.piecewise_linear(durations=[0.3, 2.0, 0.3],\nvalues=[0.0, 2.0, 2.0, 0.0])\n# instead of using the full waveform we opt to only take the first 1 us\n&gt;&gt;&gt; prog_with_slice = prog_with_wf.slice(0.0, 1.0)\n# you may use variables as well\n&gt;&gt;&gt; prog_with_slice = prog_with_wf.slice(\"start\", \"end\")\n</code></pre> <ul> <li>Your next steps include:</li> <li>Continue building your waveform via:<ul> <li><code>...slice(start, stop).linear(start, stop, duration)</code>:     to append another linear waveform</li> <li><code>...slice(start, stop).constant(value, duration)</code>:     to append a constant waveform</li> <li><code>...slice(start, stop).piecewise_linear()</code>:     to append a piecewise linear waveform</li> <li><code>...slice(start, stop).piecewise_constant()</code>:     to append a piecewise constant waveform</li> <li><code>...slice(start, stop).poly([coefficients], duration)</code>:     to append a polynomial waveform</li> <li><code>...slice(start, stop).apply(wf:bloqade.ir.Waveform)</code>:     to append a pre-defined waveform</li> <li><code>...slilce(start, stop).fn(f(t,...))</code>:     to append a waveform defined by a python function</li> </ul> </li> <li>Begin constructing another drive by starting a new spatial modulation     (this drive will be summed to the one you just created):<ul> <li><code>...slice(start, stop).uniform</code>:     To address all atoms in the field</li> <li><code>...slice(start, stop).location(int)</code>:     To address an atom at a specific location via index</li> <li><code>...slice(start, stop).scale(...)</code><ul> <li>To address an atom at a specific location via variable</li> <li>To address multiple atoms at specific locations by specifying     a single variable and then assigning it a list of coordinates</li> </ul> </li> </ul> </li> <li>Assign values to pre-existing variables via:<ul> <li><code>...slice(start, stop).assign(variable_name = value)</code>:     to assign a single value to a variable</li> <li><code>...slice(start, stop)     .batch_assign(variable_name = [value1, ...])</code>:     to assign multiple values to a variable</li> <li><code>...slice(start, stop).args([\"previously_defined_var\"])</code>:     to defer assignment of a variable to execution time</li> </ul> </li> <li>Select the backend you want your program to run on via:<ul> <li><code>...slice(start, stop).braket</code>:     to run on Braket local emulator or QuEra hardware remotely</li> <li><code>...slice(start, stop).bloqade</code>:     to run on the Bloqade local emulator</li> <li><code>...slice(start, stop).device</code>:     to specify the backend via string</li> </ul> </li> <li>Choose to parallelize your atom geometry,   duplicating it to fill the whole space:<ul> <li><code>...slice(start, stop).parallelize(spacing)</code></li> </ul> </li> <li>Start targeting another level coupling<ul> <li><code>...slice(start, stop).rydberg</code>:     to target the Rydberg level coupling</li> <li><code>...slice(start, stop).hyperfine</code>:     to target the Hyperfine level coupling</li> </ul> </li> <li>Start targeting other fields within your current level coupling   (previously selected as <code>rydberg</code> or <code>hyperfine</code>):<ul> <li><code>...slice(start, stop).amplitude</code>:     to target the real-valued Rabi Amplitude field</li> <li><code>...slice(start, stop).phase</code>:     to target the real-valued Rabi Phase field</li> <li><code>...slice(start, stop).detuning</code>:     to target the Detuning field</li> <li><code>...slice(start, stop).rabi</code>:     to target the complex-valued Rabi field</li> </ul> </li> </ul> Source code in <code>src/bloqade/builder/waveform.py</code> <pre><code>@beartype\ndef slice(\n    self,\n    start: Optional[ScalarType] = None,\n    stop: Optional[ScalarType] = None,\n) -&gt; \"Slice\":\n    \"\"\"\n    Indicate that you only want a portion of your waveform to be used in\n    the program.\n\n    If you specified a spatial modulation (e.g. `uniform`, `location`,`scale`)\n    previously without a waveform you will now have completed the construction\n    of a \"drive\", one or a sum of drives creating a \"field\"\n    (e.g. Real-valued Rabi Amplitude/Phase).\n\n    If you have already specified a waveform previously you will now be appending\n    this waveform to that previous waveform.\n\n\n    ### Usage Example:\n    ```\n    # define a program with a waveform of interest\n    &gt;&gt;&gt; from bloqade import start\n    &gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.rabi.amplitude.uniform\n    &gt;&gt;&gt; prog_with_wf = prog.piecewise_linear(durations=[0.3, 2.0, 0.3],\n    values=[0.0, 2.0, 2.0, 0.0])\n    # instead of using the full waveform we opt to only take the first 1 us\n    &gt;&gt;&gt; prog_with_slice = prog_with_wf.slice(0.0, 1.0)\n    # you may use variables as well\n    &gt;&gt;&gt; prog_with_slice = prog_with_wf.slice(\"start\", \"end\")\n    ```\n\n    - Your next steps include:\n    - Continue building your waveform via:\n        - `...slice(start, stop).linear(start, stop, duration)`:\n            to append another linear waveform\n        - `...slice(start, stop).constant(value, duration)`:\n            to append a constant waveform\n        - `...slice(start, stop).piecewise_linear()`:\n            to append a piecewise linear waveform\n        - `...slice(start, stop).piecewise_constant()`:\n            to append a piecewise constant waveform\n        - `...slice(start, stop).poly([coefficients], duration)`:\n            to append a polynomial waveform\n        - `...slice(start, stop).apply(wf:bloqade.ir.Waveform)`:\n            to append a pre-defined waveform\n        - `...slilce(start, stop).fn(f(t,...))`:\n            to append a waveform defined by a python function\n    - Begin constructing another drive by starting a new spatial modulation\n        (this drive will be summed to the one you just created):\n        - `...slice(start, stop).uniform`:\n            To address all atoms in the field\n        - `...slice(start, stop).location(int)`:\n            To address an atom at a specific location via index\n        - `...slice(start, stop).scale(...)`\n            - To address an atom at a specific location via variable\n            - To address multiple atoms at specific locations by specifying\n                a single variable and then assigning it a list of coordinates\n    - Assign values to pre-existing variables via:\n        - `...slice(start, stop).assign(variable_name = value)`:\n            to assign a single value to a variable\n        - `...slice(start, stop)\n            .batch_assign(variable_name = [value1, ...])`:\n            to assign multiple values to a variable\n        - `...slice(start, stop).args([\"previously_defined_var\"])`:\n            to defer assignment of a variable to execution time\n    - Select the backend you want your program to run on via:\n        - `...slice(start, stop).braket`:\n            to run on Braket local emulator or QuEra hardware remotely\n        - `...slice(start, stop).bloqade`:\n            to run on the Bloqade local emulator\n        - `...slice(start, stop).device`:\n            to specify the backend via string\n    - Choose to parallelize your atom geometry,\n      duplicating it to fill the whole space:\n        - `...slice(start, stop).parallelize(spacing)`\n    - Start targeting another level coupling\n        - `...slice(start, stop).rydberg`:\n            to target the Rydberg level coupling\n        - `...slice(start, stop).hyperfine`:\n            to target the Hyperfine level coupling\n    - Start targeting other fields within your current level coupling\n      (previously selected as `rydberg` or `hyperfine`):\n        - `...slice(start, stop).amplitude`:\n            to target the real-valued Rabi Amplitude field\n        - `...slice(start, stop).phase`:\n            to target the real-valued Rabi Phase field\n        - `...slice(start, stop).detuning`:\n            to target the Detuning field\n        - `...slice(start, stop).rabi`:\n            to target the complex-valued Rabi field\n    \"\"\"\n    return Slice(start, stop, self)\n</code></pre>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable","title":"WaveformAttachable","text":"<p>             Bases: <code>Builder</code></p>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable.apply","title":"apply","text":"<pre><code>apply(wf)\n</code></pre> <p>Apply a <code>Waveform</code> built previously to current location(s).</p> <p>If you specified a spatial modulation (e.g. <code>uniform</code>, <code>location</code>,<code>scale</code>) previously without a waveform you will now have completed the construction of a \"drive\", one or a sum of drives creating a \"field\" (e.g. Real-valued Rabi Amplitude/Phase).</p> <p>If you have already specified a waveform previously you will now be appending this waveform to that previous waveform.</p>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable.apply--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.detuning.uniform\n# build our waveform independently of the main program\n&gt;&gt;&gt; from bloqade import piecewise_linear\n&gt;&gt;&gt; wf = piecewise_linear(durations=[0.3, 2.5, 0.3],\nvalues=[0.0, 2.0, 2.0, 0.0])\n&gt;&gt;&gt; prog.apply(wf)\n</code></pre> <ul> <li>Your next steps include:</li> <li>Continue building your waveform via:<ul> <li><code>...apply(waveform).linear(start, stop, duration)</code>:     to append another linear waveform</li> <li><code>...apply(waveform).constant(value, duration)</code>:     to append a constant waveform</li> <li><code>...apply(waveform).piecewise_linear([durations], [values])</code>:     to append a piecewise linear waveform</li> <li><code>...apply(waveform).piecewise_constant([durations], [values])</code>:     to append a piecewise constant waveform</li> <li><code>...apply(waveform).poly([coefficients], duration)</code>:     to append a polynomial waveform</li> <li><code>...apply(waveform).apply(waveform)</code>:     to append a pre-defined waveform</li> <li><code>...apply(waveform).fn(f(t,...))</code>:     to append a waveform defined by a python function</li> </ul> </li> <li>Slice a portion of the waveform to be used:<ul> <li><code>...apply(waveform).slice(start, stop, duration)</code></li> </ul> </li> <li>Save the ending value of your waveform to be reused elsewhere<ul> <li><code>...apply(waveform).record(\"you_variable_here\")</code></li> </ul> </li> <li>Begin constructing another drive by starting a new spatial modulation   (this drive will be summed to the one you just created):<ul> <li><code>...apply(waveform).uniform</code>: To address all atoms in the field</li> <li><code>...apply(waveform).location(int)</code>:     To address an atom at a specific location via index</li> <li><code>...apply(waveform).scale(...)</code><ul> <li>To address an atom at a specific location via variable</li> <li>To address multiple atoms at specific locations by specifying a     single variable and then assigning it a list of coordinates</li> </ul> </li> </ul> </li> <li>Assign values to pre-existing variables via:<ul> <li><code>...apply(waveform).assign(variable_name = value)</code>:     to assign a single value to a variable</li> <li><code>...apply(waveform).batch_assign(variable_name = [value1, ...])</code>:     to assign multiple values to a variable</li> <li><code>...apply(waveform).args([\"previously_defined_var\"])</code>:     to defer assignment of a variable to execution time</li> </ul> </li> <li>Select the backend you want your program to run on via:<ul> <li><code>...apply(waveform).braket</code>:     to run on Braket local emulator or QuEra hardware remotely</li> <li><code>...apply(waveform).bloqade</code>:     to run on the Bloqade local emulator</li> <li><code>...apply(waveform).device</code>:     to specify the backend via string</li> </ul> </li> <li>Choose to parallelize your atom geometry,   duplicating it to fill the whole space:<ul> <li><code>...apply(waveform).parallelize(spacing)</code></li> </ul> </li> <li>Start targeting another level coupling<ul> <li><code>...apply(waveform).rydberg</code>: to target the Rydberg level coupling</li> <li><code>...apply(waveform).hyperfine</code>: to target the Hyperfine level coupling</li> </ul> </li> <li>Start targeting other fields within your current level coupling   (previously selected as <code>rydberg</code> or <code>hyperfine</code>):<ul> <li><code>...apply(waveform).amplitude</code>:     to target the real-valued Rabi Amplitude field</li> <li><code>...apply(waveform).phase</code>:     to target the real-valued Rabi Phase field</li> <li><code>...apply(waveform).detuning</code>:     to target the Detuning field</li> <li><code>...apply(waveform).rabi</code>:     to target the complex-valued Rabi field</li> </ul> </li> </ul> Source code in <code>src/bloqade/builder/waveform.py</code> <pre><code>@beartype\ndef apply(self, wf: ir.Waveform) -&gt; \"Apply\":\n    \"\"\"\n    Apply a [`Waveform`][bloqade.ir.control.Waveform] built previously to\n    current location(s).\n\n    If you specified a spatial modulation (e.g. `uniform`, `location`,`scale`)\n    previously without a waveform you will now have completed the construction\n    of a \"drive\", one or a sum of drives creating a \"field\"\n    (e.g. Real-valued Rabi Amplitude/Phase).\n\n    If you have already specified a waveform previously you will now be appending\n    this waveform to that previous waveform.\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.detuning.uniform\n    # build our waveform independently of the main program\n    &gt;&gt;&gt; from bloqade import piecewise_linear\n    &gt;&gt;&gt; wf = piecewise_linear(durations=[0.3, 2.5, 0.3],\n    values=[0.0, 2.0, 2.0, 0.0])\n    &gt;&gt;&gt; prog.apply(wf)\n    ```\n\n    - Your next steps include:\n    - Continue building your waveform via:\n        - `...apply(waveform).linear(start, stop, duration)`:\n            to append another linear waveform\n        - `...apply(waveform).constant(value, duration)`:\n            to append a constant waveform\n        - `...apply(waveform).piecewise_linear([durations], [values])`:\n            to append a piecewise linear waveform\n        - `...apply(waveform).piecewise_constant([durations], [values])`:\n            to append a piecewise constant waveform\n        - `...apply(waveform).poly([coefficients], duration)`:\n            to append a polynomial waveform\n        - `...apply(waveform).apply(waveform)`:\n            to append a pre-defined waveform\n        - `...apply(waveform).fn(f(t,...))`:\n            to append a waveform defined by a python function\n    - Slice a portion of the waveform to be used:\n        - `...apply(waveform).slice(start, stop, duration)`\n    - Save the ending value of your waveform to be reused elsewhere\n        - `...apply(waveform).record(\"you_variable_here\")`\n    - Begin constructing another drive by starting a new spatial modulation\n      (this drive will be summed to the one you just created):\n        - `...apply(waveform).uniform`: To address all atoms in the field\n        - `...apply(waveform).location(int)`:\n            To address an atom at a specific location via index\n        - `...apply(waveform).scale(...)`\n            - To address an atom at a specific location via variable\n            - To address multiple atoms at specific locations by specifying a\n                single variable and then assigning it a list of coordinates\n    - Assign values to pre-existing variables via:\n        - `...apply(waveform).assign(variable_name = value)`:\n            to assign a single value to a variable\n        - `...apply(waveform).batch_assign(variable_name = [value1, ...])`:\n            to assign multiple values to a variable\n        - `...apply(waveform).args([\"previously_defined_var\"])`:\n            to defer assignment of a variable to execution time\n    - Select the backend you want your program to run on via:\n        - `...apply(waveform).braket`:\n            to run on Braket local emulator or QuEra hardware remotely\n        - `...apply(waveform).bloqade`:\n            to run on the Bloqade local emulator\n        - `...apply(waveform).device`:\n            to specify the backend via string\n    - Choose to parallelize your atom geometry,\n      duplicating it to fill the whole space:\n        - `...apply(waveform).parallelize(spacing)`\n    - Start targeting another level coupling\n        - `...apply(waveform).rydberg`: to target the Rydberg level coupling\n        - `...apply(waveform).hyperfine`: to target the Hyperfine level coupling\n    - Start targeting other fields within your current level coupling\n      (previously selected as `rydberg` or `hyperfine`):\n        - `...apply(waveform).amplitude`:\n            to target the real-valued Rabi Amplitude field\n        - `...apply(waveform).phase`:\n            to target the real-valued Rabi Phase field\n        - `...apply(waveform).detuning`:\n            to target the Detuning field\n        - `...apply(waveform).rabi`:\n            to target the complex-valued Rabi field\n    \"\"\"\n    return Apply(wf, self)\n</code></pre>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable.constant","title":"constant","text":"<pre><code>constant(value, duration)\n</code></pre> <p>Append or assign a constant waveform to the current location(s).</p> <p>If you specified a spatial modulation (e.g. <code>uniform</code>, <code>location</code>,<code>scale</code>) previously without a waveform you will now have completed the construction of a \"drive\", one or a sum of drives creating a \"field\" (e.g. Real-valued Rabi Amplitude/Phase).</p> <p>If you have already specified a waveform previously you will now be appending this waveform to that previous waveform.</p>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable.constant--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.detuning.uniform\n# apply a constant waveform of 1.9 radians/us for 0.5 us\n&gt;&gt;&gt; prog.constant(value=1.9,duration=0.5)\n</code></pre> <ul> <li>Your next steps include:</li> <li>Continue building your waveform via:<ul> <li><code>...constant(value, duration).linear(start, stop, duration)</code>:     to append another linear waveform</li> <li><code>...constant(value, duration).constant(value, duration)</code>:     to append a constant waveform</li> <li><code>...constant(value, duration)     .piecewise_linear([durations], [values])</code>:     to append a piecewise linear waveform</li> <li><code>...constant(value, duration)     .piecewise_constant([durations], [values])</code>:     to append a piecewise constant waveform</li> <li><code>...constant(value, duration).poly([coefficients], duration)</code>:     to append a polynomial waveform</li> <li><code>...constant(value, duration).apply(wf:bloqade.ir.Waveform)</code>:     to append a pre-defined waveform</li> <li><code>...constant(value, duration).fn(f(t,...))</code>:     to append a waveform defined by a python function</li> </ul> </li> <li>Slice a portion of the waveform to be used:<ul> <li><code>...constant(value, duration).slice(start, stop, duration)</code></li> </ul> </li> <li>Save the ending value of your waveform to be reused elsewhere<ul> <li><code>...constant(value, duration).record(\"you_variable_here\")</code></li> </ul> </li> <li>Begin constructing another drive by starting a new spatial modulation     (this drive will be summed to the one you just created):<ul> <li><code>...constant(value, duration).uniform</code>:     To address all atoms in the field</li> <li><code>...constant(value, duration).scale(...)</code>:     To address an atom at a specific location via index</li> <li><code>...constant(value, duration).location(int)</code><ul> <li>To address an atom at a specific location via variable</li> <li>To address multiple atoms at specific locations by specifying     a single variable and then assigning it a list of coordinates</li> </ul> </li> </ul> </li> <li>Assign values to pre-existing variables via:<ul> <li><code>...constant(value, duration).assign(variable_name = value)</code>:     to assign a single value to a variable</li> <li><code>...constant(value, duration)     .batch_assign(variable_name = [value1, ...])</code>:     to assign multiple values to a variable</li> <li><code>...constant(value, duration).args([\"previously_defined_var\"])</code>:     to defer assignment of a variable to execution time</li> </ul> </li> <li>Select the backend you want your program to run on via:<ul> <li><code>...constant(value, duration).braket</code>:     to run on Braket local emulator or QuEra hardware remotely</li> <li><code>...constant(value, duration).bloqade</code>:     to run on the Bloqade local emulator</li> <li><code>...constant(value, duration).device</code>:     to specify the backend via string</li> </ul> </li> <li>Choose to parallelize your atom geometry,   duplicating it to fill the whole space:<ul> <li><code>...constant(start, stop, duration).parallelize(spacing)</code></li> </ul> </li> <li>Start targeting another level coupling<ul> <li><code>...constant(value, duration).rydberg</code>:     to target the Rydberg level coupling</li> <li><code>...constant(value, duration).hyperfine</code>:     to target the Hyperfine level coupling</li> </ul> </li> <li>Start targeting other fields within your current   level coupling (previously selected as <code>rydberg</code> or <code>hyperfine</code>):<ul> <li><code>...constant(value, duration).amplitude</code>:     to target the real-valued Rabi Amplitude field</li> <li><code>...constant(value, duration).phase</code>:     to target the real-valued Rabi Phase field</li> <li><code>...constant(value, duration).detuning</code>:     to target the Detuning field</li> <li><code>...constant(value, duration).rabi</code>:     to target the complex-valued Rabi field</li> </ul> </li> </ul> Source code in <code>src/bloqade/builder/waveform.py</code> <pre><code>@beartype\ndef constant(self, value: ScalarType, duration: ScalarType) -&gt; \"Constant\":\n    \"\"\"\n    Append or assign a constant waveform to the current location(s).\n\n    If you specified a spatial modulation (e.g. `uniform`, `location`,`scale`)\n    previously without a waveform you will now have completed the construction\n    of a \"drive\", one or a sum of drives creating a \"field\"\n    (e.g. Real-valued Rabi Amplitude/Phase).\n\n    If you have already specified a waveform previously you will now be appending\n    this waveform to that previous waveform.\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.detuning.uniform\n    # apply a constant waveform of 1.9 radians/us for 0.5 us\n    &gt;&gt;&gt; prog.constant(value=1.9,duration=0.5)\n    ```\n\n    - Your next steps include:\n    - Continue building your waveform via:\n        - `...constant(value, duration).linear(start, stop, duration)`:\n            to append another linear waveform\n        - `...constant(value, duration).constant(value, duration)`:\n            to append a constant waveform\n        - `...constant(value, duration)\n            .piecewise_linear([durations], [values])`:\n            to append a piecewise linear waveform\n        - `...constant(value, duration)\n            .piecewise_constant([durations], [values])`:\n            to append a piecewise constant waveform\n        - `...constant(value, duration).poly([coefficients], duration)`:\n            to append a polynomial waveform\n        - `...constant(value, duration).apply(wf:bloqade.ir.Waveform)`:\n            to append a pre-defined waveform\n        - `...constant(value, duration).fn(f(t,...))`:\n            to append a waveform defined by a python function\n    - Slice a portion of the waveform to be used:\n        - `...constant(value, duration).slice(start, stop, duration)`\n    - Save the ending value of your waveform to be reused elsewhere\n        - `...constant(value, duration).record(\"you_variable_here\")`\n    - Begin constructing another drive by starting a new spatial modulation\n        (this drive will be summed to the one you just created):\n        - `...constant(value, duration).uniform`:\n            To address all atoms in the field\n        - `...constant(value, duration).scale(...)`:\n            To address an atom at a specific location via index\n        - `...constant(value, duration).location(int)`\n            - To address an atom at a specific location via variable\n            - To address multiple atoms at specific locations by specifying\n                a single variable and then assigning it a list of coordinates\n    - Assign values to pre-existing variables via:\n        - `...constant(value, duration).assign(variable_name = value)`:\n            to assign a single value to a variable\n        - `...constant(value, duration)\n            .batch_assign(variable_name = [value1, ...])`:\n            to assign multiple values to a variable\n        - `...constant(value, duration).args([\"previously_defined_var\"])`:\n            to defer assignment of a variable to execution time\n    - Select the backend you want your program to run on via:\n        - `...constant(value, duration).braket`:\n            to run on Braket local emulator or QuEra hardware remotely\n        - `...constant(value, duration).bloqade`:\n            to run on the Bloqade local emulator\n        - `...constant(value, duration).device`:\n            to specify the backend via string\n    - Choose to parallelize your atom geometry,\n      duplicating it to fill the whole space:\n        - `...constant(start, stop, duration).parallelize(spacing)`\n    - Start targeting another level coupling\n        - `...constant(value, duration).rydberg`:\n            to target the Rydberg level coupling\n        - `...constant(value, duration).hyperfine`:\n            to target the Hyperfine level coupling\n    - Start targeting other fields within your current\n      level coupling (previously selected as `rydberg` or `hyperfine`):\n        - `...constant(value, duration).amplitude`:\n            to target the real-valued Rabi Amplitude field\n        - `...constant(value, duration).phase`:\n            to target the real-valued Rabi Phase field\n        - `...constant(value, duration).detuning`:\n            to target the Detuning field\n        - `...constant(value, duration).rabi`:\n            to target the complex-valued Rabi field\n\n    \"\"\"\n    return Constant(value, duration, self)\n</code></pre>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable.fn","title":"fn","text":"<pre><code>fn(fn, duration)\n</code></pre> <p>Append or assign a custom function as a waveform.</p> <p>The function must have its first argument be that of time but can also have other arguments which are treated as variables. You can assign values to later in the program via <code>.assign</code> or <code>.batch_assign</code>.</p> <p>The function must also return a singular float value.</p> <p>If you specified a spatial modulation (e.g. <code>uniform</code>, <code>location</code>,<code>scale</code>) previously without a waveform you will now have completed the construction of a \"drive\", one or a sum of drives creating a \"field\" (e.g. Real-valued Rabi Amplitude/Phase).</p> <p>If you have already specified a waveform previously you will now be appending this waveform to that previous waveform.</p>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable.fn--usage-examples","title":"### Usage Examples:","text":"<pre><code>&gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.detuning.uniform\n# define our custom waveform. It must have one argument\n# be time followed by any other number of arguments that can\n# be assigned a value later in the program via `.assign` or `.batch_assign`\n&gt;&gt;&gt; def custom_waveform_function(t, arg1, arg2):\n        return arg1*t + arg2\n&gt;&gt;&gt; prog = prog.fn(custom_waveform_function, duration = 0.5)\n# assign values\n&gt;&gt;&gt; assigned_vars_prog = prog.assign(arg1 = 1.0, arg2 = 2.0)\n# or go for batching!\n&gt;&gt;&gt; assigned_vars_batch_prog = prog.assign(arg1 = 1.0, arg2 = [1.0, 2.0, 3.0])\n</code></pre> <ul> <li>Your next steps include:</li> <li>Continue building your waveform via:<ul> <li><code>...fn(f(t,...))     .linear(start, stop, duration)</code>: to append another linear waveform</li> <li><code>...fn(f(t,...))     .constant(value, duration)</code>: to append a constant waveform</li> <li><code>...fn(f(t,...))     .piecewise_linear(durations, values)</code>:     to append a piecewise linear waveform</li> <li><code>...fn(f(t,...))     .piecewise_constant(durations, values)</code>:     to append a piecewise constant waveform</li> <li><code>...fn(f(t,...))     .poly([coefficients], duration)</code>: to append a polynomial waveform</li> <li><code>...fn(f(t,...))     .apply(waveform)</code>: to append a pre-defined waveform</li> <li><code>...fn(f(t,...))     .fn(f(t,...))</code>: to append a waveform defined by a python function</li> </ul> </li> <li>Slice a portion of the waveform to be used:<ul> <li><code>...fn(f(t,...)).slice(start, stop, duration)</code></li> </ul> </li> <li>Save the ending value of your waveform to be reused elsewhere<ul> <li><code>...fn(f(t,...)).record(\"you_variable_here\")</code></li> </ul> </li> <li>Begin constructing another drive by starting a new spatial modulation   (this drive will be summed to the one you just created):<ul> <li><code>...fn(f(t,...)).uniform</code>:     To address all atoms in the field</li> <li><code>...fn(f(t,...)).scale(...)</code>:     To address an atom at a specific location via index</li> <li>...fn(f(t,...)).location(int)`<ul> <li>To address an atom at a specific location via variable</li> <li>To address multiple atoms at specific locations by     specifying a single variable and then assigning it a     list of coordinates</li> </ul> </li> </ul> </li> <li>Assign values to pre-existing variables via:<ul> <li><code>...fn(f(t,...))     .assign(variable_name = value)</code>: to assign a single value to a variable</li> <li><code>...fn(f(t,...))     .batch_assign(variable_name = [value1, ...])</code>:     to assign multiple values to a variable</li> <li><code>...fn(f(t,...))     .args([\"previously_defined_var\"])</code>:     to defer assignment of a variable to execution time</li> </ul> </li> <li>Select the backend you want your program to run on via:<ul> <li><code>...fn(f(t,...)).braket</code>:     to run on Braket local emulator or QuEra hardware remotely</li> <li><code>...fn(f(t,...)).bloqade</code>:     to run on the Bloqade local emulator</li> <li><code>...fn(f(t,...)).device</code>:     to specify the backend via string</li> </ul> </li> <li>Choose to parallelize your atom geometry,   duplicating it to fill the whole space:<ul> <li><code>...fn(f(t,...)).parallelize(spacing)</code></li> </ul> </li> <li>Start targeting another level coupling<ul> <li><code>...fn(f(t,...)).rydberg</code>:     to target the Rydberg level coupling</li> <li><code>...fn(f(t,...)).hyperfine</code>:     to target the Hyperfine level coupling</li> </ul> </li> <li>Start targeting other fields within your current level coupling   (previously selected as <code>rydberg</code> or <code>hyperfine</code>):<ul> <li><code>...fn(f(t,...)).amplitude</code>:     to target the real-valued Rabi Amplitude field</li> <li><code>...fn(f(t,...)).phase</code>:     to target the real-valued Rabi Phase field</li> <li><code>...fn(f(t,...)).detuning</code>:     to target the Detuning field</li> <li><code>...fn(f(t,...)).rabi</code>:     to target the complex-valued Rabi field</li> </ul> </li> </ul> Source code in <code>src/bloqade/builder/waveform.py</code> <pre><code>@beartype\ndef fn(self, fn: Callable, duration: ScalarType) -&gt; \"Fn\":\n    \"\"\"\n    Append or assign a custom function as a waveform.\n\n    The function must have its first argument be that of time but\n    can also have other arguments which are treated as variables.\n    You can assign values to later in the program via `.assign` or `.batch_assign`.\n\n    The function must also return a singular float value.\n\n    If you specified a spatial modulation (e.g. `uniform`, `location`,`scale`)\n    previously without a waveform you will now have completed the construction\n    of a \"drive\", one or a sum of drives creating a \"field\"\n    (e.g. Real-valued Rabi Amplitude/Phase).\n\n    If you have already specified a waveform previously you will now be appending\n    this waveform to that previous waveform.\n\n    ### ### Usage Examples:\n    ```\n    &gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.detuning.uniform\n    # define our custom waveform. It must have one argument\n    # be time followed by any other number of arguments that can\n    # be assigned a value later in the program via `.assign` or `.batch_assign`\n    &gt;&gt;&gt; def custom_waveform_function(t, arg1, arg2):\n            return arg1*t + arg2\n    &gt;&gt;&gt; prog = prog.fn(custom_waveform_function, duration = 0.5)\n    # assign values\n    &gt;&gt;&gt; assigned_vars_prog = prog.assign(arg1 = 1.0, arg2 = 2.0)\n    # or go for batching!\n    &gt;&gt;&gt; assigned_vars_batch_prog = prog.assign(arg1 = 1.0, arg2 = [1.0, 2.0, 3.0])\n    ```\n\n    - Your next steps include:\n    - Continue building your waveform via:\n        - `...fn(f(t,...))\n            .linear(start, stop, duration)`: to append another linear waveform\n        - `...fn(f(t,...))\n            .constant(value, duration)`: to append a constant waveform\n        - `...fn(f(t,...))\n            .piecewise_linear(durations, values)`:\n            to append a piecewise linear waveform\n        - `...fn(f(t,...))\n            .piecewise_constant(durations, values)`:\n            to append a piecewise constant waveform\n        - `...fn(f(t,...))\n            .poly([coefficients], duration)`: to append a polynomial waveform\n        - `...fn(f(t,...))\n            .apply(waveform)`: to append a pre-defined waveform\n        - `...fn(f(t,...))\n            .fn(f(t,...))`: to append a waveform defined by a python function\n    - Slice a portion of the waveform to be used:\n        - `...fn(f(t,...)).slice(start, stop, duration)`\n    - Save the ending value of your waveform to be reused elsewhere\n        - `...fn(f(t,...)).record(\"you_variable_here\")`\n    - Begin constructing another drive by starting a new spatial modulation\n      (this drive will be summed to the one you just created):\n        - `...fn(f(t,...)).uniform`:\n            To address all atoms in the field\n        - `...fn(f(t,...)).scale(...)`:\n            To address an atom at a specific location via index\n        - ...fn(f(t,...)).location(int)`\n            - To address an atom at a specific location via variable\n            - To address multiple atoms at specific locations by\n                specifying a single variable and then assigning it a\n                list of coordinates\n    - Assign values to pre-existing variables via:\n        - `...fn(f(t,...))\n            .assign(variable_name = value)`: to assign a single value to a variable\n        - `...fn(f(t,...))\n            .batch_assign(variable_name = [value1, ...])`:\n            to assign multiple values to a variable\n        - `...fn(f(t,...))\n            .args([\"previously_defined_var\"])`:\n            to defer assignment of a variable to execution time\n    - Select the backend you want your program to run on via:\n        - `...fn(f(t,...)).braket`:\n            to run on Braket local emulator or QuEra hardware remotely\n        - `...fn(f(t,...)).bloqade`:\n            to run on the Bloqade local emulator\n        - `...fn(f(t,...)).device`:\n            to specify the backend via string\n    - Choose to parallelize your atom geometry,\n      duplicating it to fill the whole space:\n        - `...fn(f(t,...)).parallelize(spacing)`\n    - Start targeting another level coupling\n        - `...fn(f(t,...)).rydberg`:\n            to target the Rydberg level coupling\n        - `...fn(f(t,...)).hyperfine`:\n            to target the Hyperfine level coupling\n    - Start targeting other fields within your current level coupling\n      (previously selected as `rydberg` or `hyperfine`):\n        - `...fn(f(t,...)).amplitude`:\n            to target the real-valued Rabi Amplitude field\n        - `...fn(f(t,...)).phase`:\n            to target the real-valued Rabi Phase field\n        - `...fn(f(t,...)).detuning`:\n            to target the Detuning field\n        - `...fn(f(t,...)).rabi`:\n            to target the complex-valued Rabi field\n\n    \"\"\"\n    return Fn(fn, duration, self)\n</code></pre>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable.linear","title":"linear","text":"<pre><code>linear(start, stop, duration)\n</code></pre> <p>Append or assign a linear waveform to the current location(s).</p> <p>If you specified a spatial modulation (e.g. <code>uniform</code>, <code>location</code>,<code>scale</code>) previously without a waveform you will now have completed the construction of a \"drive\", one or a sum of drives creating a \"field\" (e.g. Real-valued Rabi Amplitude/Phase).</p> <p>If you have already specified a waveform previously you will now be appending this waveform to that previous waveform.</p>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable.linear--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.detuning.uniform\n# apply a linear waveform that goes from 0 to 1 radians/us in 0.5 us\n&gt;&gt;&gt; prog.linear(start=0,stop=1,duration=0.5)\n</code></pre> <ul> <li>Your next steps include:</li> <li>Continue building your waveform via:<ul> <li><code>...linear(start, stop, duration).linear(start, stop, duration)</code>:     to append another linear waveform</li> <li><code>...linear(start, stop, duration).constant(value, duration)</code>:     to append a constant waveform</li> <li><code>...linear(start, stop, duration)     .piecewise_linear([durations], [values])</code>:     to append a piecewise linear waveform</li> <li><code>...linear(start, stop, duration)     .piecewise_constant([durations], [values])</code>:     to append a piecewise constant waveform</li> <li><code>...linear(start, stop, duration).poly([coefficients], duration)</code>:     to append a polynomial waveform</li> <li><code>...linear(start, stop, duration).apply(wf:bloqade.ir.Waveform)</code>:     to append a pre-defined waveform</li> <li><code>...linear(start, stop, duration).fn(f(t,...))</code>:     to append a waveform defined by a python function</li> </ul> </li> <li>Slice a portion of the waveform to be used:<ul> <li><code>...linear(start, stop, duration).slice(start, stop, duration)</code></li> </ul> </li> <li>Save the ending value of your waveform to be reused elsewhere<ul> <li><code>...linear(start, stop, duration).record(\"you_variable_here\")</code></li> </ul> </li> <li>Begin constructing another drive by starting a new spatial modulation     (this drive will be summed to the one you just created):<ul> <li><code>...linear(start, stop, duration).uniform</code>:     To address all atoms in the field</li> <li><code>...linear(start, stop, duration).location(int)</code>:     To address atoms at specific location with scaling</li> <li><code>...linear(start, stop, duration).scale(...)</code><ul> <li>To address atoms at specific location with scaling</li> <li>To address multiple atoms at specific locations by specifying     a single variable and then assigning it a list of coordinates</li> </ul> </li> </ul> </li> <li>Assign values to pre-existing variables via:<ul> <li><code>...linear(start, stop, duration).assign(variable_name = value)</code>:     to assign a single value to a variable</li> <li><code>...linear(start, stop, duration)     .batch_assign(variable_name = [value1, ...])</code>:     to assign multiple values to a variable</li> <li><code>...linear(start, stop, duration).args([\"previously_defined_var\"])</code>:     to defer assignment of a variable to execution time</li> </ul> </li> <li>Select the backend you want your program to run on via:<ul> <li><code>...linear(start, stop, duration).braket</code>:     to run on Braket local emulator or QuEra hardware remotely</li> <li><code>...linear(start, stop, duration).bloqade</code>:     to run on the Bloqade local emulator</li> <li><code>...linear(start, stop, duration).device</code>:     to specify the backend via string</li> </ul> </li> <li>Choose to parallelize your atom geometry,   duplicating it to fill the whole space:<ul> <li><code>...linear(start, stop, duration).parallelize(spacing)</code></li> </ul> </li> <li>Start targeting another level coupling<ul> <li><code>...linear(start, stop, duration).rydberg</code>:     to target the Rydberg level coupling</li> <li><code>...linear(start, stop, duration).hyperfine</code>:     to target the Hyperfine level coupling</li> </ul> </li> <li>Start targeting other fields within your current level coupling   (previously selected as <code>rydberg</code> or <code>hyperfine</code>):<ul> <li><code>...linear(start, stop, duration).amplitude</code>:     to target the real-valued Rabi Amplitude field</li> <li><code>...linear(start, stop, duration).phase</code>:     to target the real-valued Rabi Phase field</li> <li><code>...linear(start, stop, duration).detuning</code>:     to target the Detuning field</li> <li><code>...linear(start, stop, duration).rabi</code>:     to target the complex-valued Rabi field</li> </ul> </li> </ul> Source code in <code>src/bloqade/builder/waveform.py</code> <pre><code>@beartype\ndef linear(\n    self, start: ScalarType, stop: ScalarType, duration: ScalarType\n) -&gt; \"Linear\":\n    \"\"\"\n\n    Append or assign a linear waveform to the current location(s).\n\n    If you specified a spatial modulation (e.g. `uniform`, `location`,`scale`)\n    previously without a waveform you will now have completed the construction\n    of a \"drive\", one or a sum of drives creating a \"field\"\n    (e.g. Real-valued Rabi Amplitude/Phase).\n\n    If you have already specified a waveform previously you will now be appending\n    this waveform to that previous waveform.\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.detuning.uniform\n    # apply a linear waveform that goes from 0 to 1 radians/us in 0.5 us\n    &gt;&gt;&gt; prog.linear(start=0,stop=1,duration=0.5)\n    ```\n\n    - Your next steps include:\n    - Continue building your waveform via:\n        - `...linear(start, stop, duration).linear(start, stop, duration)`:\n            to append another linear waveform\n        - `...linear(start, stop, duration).constant(value, duration)`:\n            to append a constant waveform\n        - `...linear(start, stop, duration)\n            .piecewise_linear([durations], [values])`:\n            to append a piecewise linear waveform\n        - `...linear(start, stop, duration)\n            .piecewise_constant([durations], [values])`:\n            to append a piecewise constant waveform\n        - `...linear(start, stop, duration).poly([coefficients], duration)`:\n            to append a polynomial waveform\n        - `...linear(start, stop, duration).apply(wf:bloqade.ir.Waveform)`:\n            to append a pre-defined waveform\n        - `...linear(start, stop, duration).fn(f(t,...))`:\n            to append a waveform defined by a python function\n    - Slice a portion of the waveform to be used:\n        - `...linear(start, stop, duration).slice(start, stop, duration)`\n    - Save the ending value of your waveform to be reused elsewhere\n        - `...linear(start, stop, duration).record(\"you_variable_here\")`\n    - Begin constructing another drive by starting a new spatial modulation\n        (this drive will be summed to the one you just created):\n        - `...linear(start, stop, duration).uniform`:\n            To address all atoms in the field\n        - `...linear(start, stop, duration).location(int)`:\n            To address atoms at specific location with scaling\n        - `...linear(start, stop, duration).scale(...)`\n            - To address atoms at specific location with scaling\n            - To address multiple atoms at specific locations by specifying\n                a single variable and then assigning it a list of coordinates\n    - Assign values to pre-existing variables via:\n        - `...linear(start, stop, duration).assign(variable_name = value)`:\n            to assign a single value to a variable\n        - `...linear(start, stop, duration)\n            .batch_assign(variable_name = [value1, ...])`:\n            to assign multiple values to a variable\n        - `...linear(start, stop, duration).args([\"previously_defined_var\"])`:\n            to defer assignment of a variable to execution time\n    - Select the backend you want your program to run on via:\n        - `...linear(start, stop, duration).braket`:\n            to run on Braket local emulator or QuEra hardware remotely\n        - `...linear(start, stop, duration).bloqade`:\n            to run on the Bloqade local emulator\n        - `...linear(start, stop, duration).device`:\n            to specify the backend via string\n    - Choose to parallelize your atom geometry,\n      duplicating it to fill the whole space:\n        - `...linear(start, stop, duration).parallelize(spacing)`\n    - Start targeting another level coupling\n        - `...linear(start, stop, duration).rydberg`:\n            to target the Rydberg level coupling\n        - `...linear(start, stop, duration).hyperfine`:\n            to target the Hyperfine level coupling\n    - Start targeting other fields within your current level coupling\n      (previously selected as `rydberg` or `hyperfine`):\n        - `...linear(start, stop, duration).amplitude`:\n            to target the real-valued Rabi Amplitude field\n        - `...linear(start, stop, duration).phase`:\n            to target the real-valued Rabi Phase field\n        - `...linear(start, stop, duration).detuning`:\n            to target the Detuning field\n        - `...linear(start, stop, duration).rabi`:\n            to target the complex-valued Rabi field\n    \"\"\"\n\n    return Linear(start, stop, duration, self)\n</code></pre>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable.piecewise_constant","title":"piecewise_constant","text":"<pre><code>piecewise_constant(durations, values)\n</code></pre> <p>Append or assign a piecewise constant waveform to current location(s).</p> <p>The <code>durations</code> argument should have number of elements = len(values). <code>durations</code> should be the duration PER section of the waveform, NON-CUMULATIVE.</p> <p>If you specified a spatial modulation (e.g. <code>uniform</code>, <code>location</code>,<code>scale</code>) previously without a waveform you will now have completed the construction of a \"drive\", one or a sum of drives creating a \"field\" (e.g. Real-valued Rabi Amplitude/Phase).</p> <p>If you have already specified a waveform previously you will now be appending this waveform to that previous waveform.</p>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable.piecewise_constant--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.rabi.phase.uniform\n# create a staircase, we hold 0.0 rad/us for 1.0 us, then\n# to 1.0 rad/us for 0.5 us before stopping at 0.8 rad/us for 0.9 us.\n&gt;&gt;&gt; prog.piecewise_linear(durations=[0.3, 2.0, 0.3], values=[1.0, 0.5, 0.9])\n</code></pre> <ul> <li>Your next steps including:</li> <li>Continue building your waveform via:<ul> <li><code>...piecewise_constant([durations], [values])     .linear(start, stop, duration)</code>: to append another linear waveform</li> <li><code>...piecewise_constant([durations], [values])     .constant(value, duration)</code>: to append a constant waveform</li> <li><code>...piecewise_constant([durations], [values])     .piecewise_linear([durations], [values])</code>:     to append a piecewise linear waveform</li> <li><code>...piecewise_constant([durations], [values])     .piecewise_constant([durations], [values])</code>:     to append a piecewise constant waveform</li> <li><code>...piecewise_constant([durations], [values])     .poly([coefficients], duration)</code>: to append a polynomial waveform</li> <li><code>...piecewise_constant([durations], [values])     .apply(waveform)</code>: to append a pre-defined waveform</li> <li><code>...piecewise_constant([durations], [values]).fn(f(t,...))</code>:     to append a waveform defined by a python function</li> </ul> </li> <li>Slice a portion of the waveform to be used:<ul> <li><code>...piecewise_constant([durations], [values])     .slice(start, stop, duration)</code></li> </ul> </li> <li>Save the ending value of your waveform to be reused elsewhere<ul> <li><code>...piecewise_constant([durations], [values])     .record(\"you_variable_here\")</code></li> </ul> </li> <li>Begin constructing another drive by starting a new spatial modulation   (this drive will be summed to the one you just created):<ul> <li><code>...piecewise_constant([durations], [values]).uniform</code>:     To address all atoms in the field</li> <li><code>...piecewise_constant([durations], [values]).location(int)</code>:     To address an atom at a specific location via index</li> <li><code>...piecewise_constant([durations], [values]).scale(...)</code><ul> <li>To address an atom at a specific location via variable</li> <li>To address multiple atoms at specific locations by     specifying a single variable and then assigning it a     list of coordinates</li> </ul> </li> </ul> </li> <li>Assign values to pre-existing variables via:<ul> <li><code>...piecewise_constant([durations], [values])     .assign(variable_name = value)</code>: to assign a single value to a variable</li> <li><code>...piecewise_constant([durations], [values])     .batch_assign(variable_name = [value1, ...])</code>:     to assign multiple values to a variable</li> <li><code>...piecewise_constant([durations], [values])     .args([\"previously_defined_var\"])</code>: to defer assignment     of a variable to execution time</li> </ul> </li> <li>Select the backend you want your program to run on via:<ul> <li><code>...piecewise_constant([durations], [values]).braket</code>:     to run on Braket local emulator or QuEra hardware remotely</li> <li><code>...piecewise_constant([durations], [values]).bloqade</code>:     to run on the Bloqade local emulator</li> <li><code>...piecewise_constant([durations], [values]).device</code>:     to specify the backend via string</li> </ul> </li> <li>Choose to parallelize your atom geometry,   duplicating it to fill the whole space:<ul> <li><code>...piecewise_constat([durations], [values]).parallelize(spacing)</code></li> </ul> </li> <li>Start targeting another level coupling<ul> <li><code>...piecewise_constant([durations], [values]).rydberg</code>:     to target the Rydberg level coupling</li> <li><code>...piecewise_constant([durations], [values]).hyperfine</code>:     to target the Hyperfine level coupling</li> </ul> </li> <li>Start targeting other fields within your current level coupling   (previously selected as <code>rydberg</code> or <code>hyperfine</code>):<ul> <li><code>...piecewise_constant(durations, values).amplitude</code>:     to target the real-valued Rabi Amplitude field</li> <li><code>...piecewise_constant([durations], [values]).phase</code>:     to target the real-valued Rabi Phase field</li> <li><code>...piecewise_constant([durations], [values]).detuning</code>:     to target the Detuning field</li> <li><code>...piecewise_constant([durations], [values]).rabi</code>:     to target the complex-valued Rabi field</li> </ul> </li> </ul> Source code in <code>src/bloqade/builder/waveform.py</code> <pre><code>@beartype\ndef piecewise_constant(\n    self, durations: List[ScalarType], values: List[ScalarType]\n) -&gt; \"PiecewiseConstant\":\n    \"\"\"\n    Append or assign a piecewise constant waveform to current location(s).\n\n    The `durations` argument should have number of elements = len(values).\n    `durations` should be the duration PER section of the waveform,\n    NON-CUMULATIVE.\n\n    If you specified a spatial modulation (e.g. `uniform`, `location`,`scale`)\n    previously without a waveform you will now have completed the construction\n    of a \"drive\", one or a sum of drives creating a \"field\"\n    (e.g. Real-valued Rabi Amplitude/Phase).\n\n    If you have already specified a waveform previously you will now be appending\n    this waveform to that previous waveform.\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.rabi.phase.uniform\n    # create a staircase, we hold 0.0 rad/us for 1.0 us, then\n    # to 1.0 rad/us for 0.5 us before stopping at 0.8 rad/us for 0.9 us.\n    &gt;&gt;&gt; prog.piecewise_linear(durations=[0.3, 2.0, 0.3], values=[1.0, 0.5, 0.9])\n    ```\n\n    - Your next steps including:\n    - Continue building your waveform via:\n        - `...piecewise_constant([durations], [values])\n            .linear(start, stop, duration)`: to append another linear waveform\n        - `...piecewise_constant([durations], [values])\n            .constant(value, duration)`: to append a constant waveform\n        - `...piecewise_constant([durations], [values])\n            .piecewise_linear([durations], [values])`:\n            to append a piecewise linear waveform\n        - `...piecewise_constant([durations], [values])\n            .piecewise_constant([durations], [values])`:\n            to append a piecewise constant waveform\n        - `...piecewise_constant([durations], [values])\n            .poly([coefficients], duration)`: to append a polynomial waveform\n        - `...piecewise_constant([durations], [values])\n            .apply(waveform)`: to append a pre-defined waveform\n        - `...piecewise_constant([durations], [values]).fn(f(t,...))`:\n            to append a waveform defined by a python function\n    - Slice a portion of the waveform to be used:\n        - `...piecewise_constant([durations], [values])\n            .slice(start, stop, duration)`\n    - Save the ending value of your waveform to be reused elsewhere\n        - `...piecewise_constant([durations], [values])\n            .record(\"you_variable_here\")`\n    - Begin constructing another drive by starting a new spatial modulation\n      (this drive will be summed to the one you just created):\n        - `...piecewise_constant([durations], [values]).uniform`:\n            To address all atoms in the field\n        - `...piecewise_constant([durations], [values]).location(int)`:\n            To address an atom at a specific location via index\n        - `...piecewise_constant([durations], [values]).scale(...)`\n            - To address an atom at a specific location via variable\n            - To address multiple atoms at specific locations by\n                specifying a single variable and then assigning it a\n                list of coordinates\n    - Assign values to pre-existing variables via:\n        - `...piecewise_constant([durations], [values])\n            .assign(variable_name = value)`: to assign a single value to a variable\n        - `...piecewise_constant([durations], [values])\n            .batch_assign(variable_name = [value1, ...])`:\n            to assign multiple values to a variable\n        - `...piecewise_constant([durations], [values])\n            .args([\"previously_defined_var\"])`: to defer assignment\n            of a variable to execution time\n    - Select the backend you want your program to run on via:\n        - `...piecewise_constant([durations], [values]).braket`:\n            to run on Braket local emulator or QuEra hardware remotely\n        - `...piecewise_constant([durations], [values]).bloqade`:\n            to run on the Bloqade local emulator\n        - `...piecewise_constant([durations], [values]).device`:\n            to specify the backend via string\n    - Choose to parallelize your atom geometry,\n      duplicating it to fill the whole space:\n        - `...piecewise_constat([durations], [values]).parallelize(spacing)`\n    - Start targeting another level coupling\n        - `...piecewise_constant([durations], [values]).rydberg`:\n            to target the Rydberg level coupling\n        - `...piecewise_constant([durations], [values]).hyperfine`:\n            to target the Hyperfine level coupling\n    - Start targeting other fields within your current level coupling\n      (previously selected as `rydberg` or `hyperfine`):\n        - `...piecewise_constant(durations, values).amplitude`:\n            to target the real-valued Rabi Amplitude field\n        - `...piecewise_constant([durations], [values]).phase`:\n            to target the real-valued Rabi Phase field\n        - `...piecewise_constant([durations], [values]).detuning`:\n            to target the Detuning field\n        - `...piecewise_constant([durations], [values]).rabi`:\n            to target the complex-valued Rabi field\n    \"\"\"\n    return PiecewiseConstant(durations, values, self)\n</code></pre>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable.piecewise_linear","title":"piecewise_linear","text":"<pre><code>piecewise_linear(durations, values)\n</code></pre> <p>Append or assign a piecewise linear waveform to current location(s), where the waveform is formed by connecting <code>values[i], values[i+1]</code> with linear segments.</p> <p>The <code>durations</code> argument should have # of elements = len(values) - 1. <code>durations</code> should be the duration PER section of the waveform, NON-CUMULATIVE.</p> <p>If you specified a spatial modulation (e.g. <code>uniform</code>, <code>location</code>,<code>scale</code>) previously without a waveform you will now have completed the construction of a \"drive\", one or a sum of drives creating a \"field\" (e.g. Real-valued Rabi Amplitude/Phase).</p> <p>If you have already specified a waveform previously you will now be appending this waveform to that previous waveform.</p>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable.piecewise_linear--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.detuning.uniform\n# ramp our waveform up to a certain value, hold it\n# then ramp down. In this case, we ramp up to 2.0 rad/us in 0.3 us,\n# then hold it for 1.5 us before ramping down in 0.3 us back to 0.0 rad/us.\n&gt;&gt;&gt; prog.piecewise_linear(durations=[0.3, 2.0, 0.3],\nvalues=[0.0, 2.0, 2.0, 0.0])\n</code></pre> <ul> <li>Your next steps include:</li> <li>Continue building your waveform via:<ul> <li><code>...piecewise_linear([durations], [values])     .linear(start, stop, duration)</code>:     to append another linear waveform</li> <li><code>...piecewise_linear([durations], [values]).constant(value, duration)</code>:     to append a constant waveform</li> <li><code>...piecewise_linear([durations], [values])     .piecewise_linear(durations, values)</code>:     to append a piecewise linear waveform</li> <li><code>...piecewise_linear([durations], [values])     .piecewise_constant([durations], [values])</code>:     to append a piecewise constant waveform</li> <li><code>...piecewise_linear([durations], [values])     .poly([coefficients], duration)</code>: to append a polynomial waveform</li> <li><code>...piecewise_linear([durations], [values]).apply(waveform)</code>:     to append a pre-defined waveform</li> <li><code>...piecewise_linear([durations], [values]).fn(f(t,...))</code>:     to append a waveform defined by a python function</li> </ul> </li> <li>Slice a portion of the waveform to be used:<ul> <li><code>...piecewise_linear([durations], [values])     .slice(start, stop, duration)</code></li> </ul> </li> <li>Save the ending value of your waveform to be reused elsewhere<ul> <li><code>...piecewise_linear([durations], [values])     .record(\"you_variable_here\")</code></li> </ul> </li> <li>Begin constructing another drive by starting a new spatial modulation   (this drive will be summed to the one you just created):<ul> <li><code>...piecewise_linear([durations], [values]).uniform</code>:     To address all atoms in the field</li> <li><code>...piecewise_linear([durations], [values]).scale(...)</code>:     To address an atom at a specific location via index</li> <li><code>...piecewise_linear([durations], [values]).location(int)</code><ul> <li>To address an atom at a specific location via variable</li> <li>To address multiple atoms at specific locations by     specifying a single variable and then assigning it a     list of coordinates</li> </ul> </li> </ul> </li> <li>Assign values to pre-existing variables via:<ul> <li><code>...piecewise_linear([durations], [values])     .assign(variable_name = value)</code>:     to assign a single value to a variable</li> <li><code>...piecewise_linear([durations], [values])     .batch_assign(variable_name = [value1, ...])</code>:     to assign multiple values to a variable</li> <li><code>...piecewise_linear([durations], [values])     .args([\"previously_defined_var\"])</code>:     to defer assignment of a variable to execution time</li> </ul> </li> <li>Select the backend you want your program to run on via:<ul> <li><code>...piecewise_linear([durations], [values]).braket</code>:     to run on Braket local emulator or QuEra hardware remotely</li> <li><code>...piecewise_linear([durations], [values]).bloqade</code>:     to run on the Bloqade local emulator</li> <li><code>...piecewise_linear([durations], [values]).device</code>:     to specify the backend via string</li> </ul> </li> <li>Choose to parallelize your atom geometry,   duplicating it to fill the whole space:<ul> <li><code>...piecewise_linear([durations], [values]).parallelize(spacing)</code></li> </ul> </li> <li>Start targeting another level coupling<ul> <li><code>...piecewise_linear([durations], [values]).rydberg</code>:     to target the Rydberg level coupling</li> <li><code>...piecewise_linear([durations], [values]).hyperfine</code>:     to target the Hyperfine level coupling</li> </ul> </li> <li>Start targeting other fields within your current level coupling   (previously selected as <code>rydberg</code> or <code>hyperfine</code>):<ul> <li><code>...piecewise_linear([durations], [values]).amplitude</code>:     to target the real-valued Rabi Amplitude field</li> <li><code>...piecewise_linear([durations], [values]).phase</code>:     to target the real-valued Rabi Phase field</li> <li><code>...piecewise_linear([durations], [values]).detuning</code>:     to target the Detuning field</li> <li><code>....rabi</code>: to target the complex-valued Rabi field</li> </ul> </li> </ul> Source code in <code>src/bloqade/builder/waveform.py</code> <pre><code>@beartype\ndef piecewise_linear(\n    self, durations: List[ScalarType], values: List[ScalarType]\n) -&gt; \"PiecewiseLinear\":\n    \"\"\"\n    Append or assign a piecewise linear waveform to current location(s),\n    where the waveform is formed by connecting `values[i], values[i+1]`\n    with linear segments.\n\n    The `durations` argument should have # of elements = len(values) - 1.\n    `durations` should be the duration PER section of the waveform, NON-CUMULATIVE.\n\n    If you specified a spatial modulation (e.g. `uniform`, `location`,`scale`)\n    previously without a waveform you will now have completed the construction\n    of a \"drive\", one or a sum of drives creating a \"field\"\n    (e.g. Real-valued Rabi Amplitude/Phase).\n\n    If you have already specified a waveform previously you will now be appending\n    this waveform to that previous waveform.\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.detuning.uniform\n    # ramp our waveform up to a certain value, hold it\n    # then ramp down. In this case, we ramp up to 2.0 rad/us in 0.3 us,\n    # then hold it for 1.5 us before ramping down in 0.3 us back to 0.0 rad/us.\n    &gt;&gt;&gt; prog.piecewise_linear(durations=[0.3, 2.0, 0.3],\n    values=[0.0, 2.0, 2.0, 0.0])\n    ```\n\n    - Your next steps include:\n    - Continue building your waveform via:\n        - `...piecewise_linear([durations], [values])\n            .linear(start, stop, duration)`:\n            to append another linear waveform\n        - `...piecewise_linear([durations], [values]).constant(value, duration)`:\n            to append a constant waveform\n        - `...piecewise_linear([durations], [values])\n            .piecewise_linear(durations, values)`:\n            to append a piecewise linear waveform\n        - `...piecewise_linear([durations], [values])\n            .piecewise_constant([durations], [values])`:\n            to append a piecewise constant waveform\n        - `...piecewise_linear([durations], [values])\n            .poly([coefficients], duration)`: to append a polynomial waveform\n        - `...piecewise_linear([durations], [values]).apply(waveform)`:\n            to append a pre-defined waveform\n        - `...piecewise_linear([durations], [values]).fn(f(t,...))`:\n            to append a waveform defined by a python function\n    - Slice a portion of the waveform to be used:\n        - `...piecewise_linear([durations], [values])\n            .slice(start, stop, duration)`\n    - Save the ending value of your waveform to be reused elsewhere\n        - `...piecewise_linear([durations], [values])\n            .record(\"you_variable_here\")`\n    - Begin constructing another drive by starting a new spatial modulation\n      (this drive will be summed to the one you just created):\n        - `...piecewise_linear([durations], [values]).uniform`:\n            To address all atoms in the field\n        - `...piecewise_linear([durations], [values]).scale(...)`:\n            To address an atom at a specific location via index\n        - `...piecewise_linear([durations], [values]).location(int)`\n            - To address an atom at a specific location via variable\n            - To address multiple atoms at specific locations by\n                specifying a single variable and then assigning it a\n                list of coordinates\n    - Assign values to pre-existing variables via:\n        - `...piecewise_linear([durations], [values])\n            .assign(variable_name = value)`:\n            to assign a single value to a variable\n        - `...piecewise_linear([durations], [values])\n            .batch_assign(variable_name = [value1, ...])`:\n            to assign multiple values to a variable\n        - `...piecewise_linear([durations], [values])\n            .args([\"previously_defined_var\"])`:\n            to defer assignment of a variable to execution time\n    - Select the backend you want your program to run on via:\n        - `...piecewise_linear([durations], [values]).braket`:\n            to run on Braket local emulator or QuEra hardware remotely\n        - `...piecewise_linear([durations], [values]).bloqade`:\n            to run on the Bloqade local emulator\n        - `...piecewise_linear([durations], [values]).device`:\n            to specify the backend via string\n    - Choose to parallelize your atom geometry,\n      duplicating it to fill the whole space:\n        - `...piecewise_linear([durations], [values]).parallelize(spacing)`\n    - Start targeting another level coupling\n        - `...piecewise_linear([durations], [values]).rydberg`:\n            to target the Rydberg level coupling\n        - `...piecewise_linear([durations], [values]).hyperfine`:\n            to target the Hyperfine level coupling\n    - Start targeting other fields within your current level coupling\n      (previously selected as `rydberg` or `hyperfine`):\n        - `...piecewise_linear([durations], [values]).amplitude`:\n            to target the real-valued Rabi Amplitude field\n        - `...piecewise_linear([durations], [values]).phase`:\n            to target the real-valued Rabi Phase field\n        - `...piecewise_linear([durations], [values]).detuning`:\n            to target the Detuning field\n        - `....rabi`: to target the complex-valued Rabi field\n    \"\"\"\n    return PiecewiseLinear(durations, values, self)\n</code></pre>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable.poly","title":"poly","text":"<pre><code>poly(coeffs, duration)\n</code></pre> <p>Append or assign a waveform with a polynomial profile to current location(s).</p> <p>You pass in a list of coefficients and a duration to this method which obeys the following expression:</p> <p><code>wv(t) = coeffs[0] + coeffs[1]*t + coeffs[2]*t^2 + ... + coeffs[n]*t^n</code></p> <p>If you specified a spatial modulation (e.g. <code>uniform</code>, <code>location</code>,<code>scale</code>) previously without a waveform you will now have completed the construction of a \"drive\", one or a sum of drives creating a \"field\" (e.g. Real-valued Rabi Amplitude/Phase).</p> <p>If you have already specified a waveform previously you will now be appending this waveform to that previous waveform.</p>"},{"location":"reference/bloqade/builder/waveform/#bloqade.builder.waveform.WaveformAttachable.poly--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.detuning.uniform\n&gt;&gt;&gt; coeffs = [-1, 0.5, 1.2]\n# resulting polynomial is:\n# f(t) = -1 + 0.5*t + 1.2*t^2 with duration of\n# 0.5 us\n&gt;&gt;&gt; prog.poly(coeffs, duration=0.5)\n</code></pre> <ul> <li>Your next steps include:</li> <li>Continue building your waveform via:<ul> <li><code>...poly([coeffs], duration).linear(start, stop, duration)</code>:     to append another linear waveform</li> <li><code>...poly([coeffs], duration).constant(value, duration)</code>:     to append a constant waveform</li> <li><code>...poly([coeffs], duration)     .piecewise_linear([durations], [values])</code>:     to append a piecewise linear waveform</li> <li><code>...poly([coeffs], duration)     .piecewise_constant([durations],[values])</code>:     to append a piecewise constant waveform</li> <li><code>...poly([coeffs], duration).poly([coefficients], duration)</code>:     to append a polynomial waveform</li> <li><code>...poly([coeffs], duration).apply(waveform)</code>:     to append a pre-defined waveform</li> <li><code>...poly([coeffs], duration).fn(f(t,...))</code>:     to append a waveform defined by a python function</li> </ul> </li> <li>Slice a portion of the waveform to be used:<ul> <li><code>...poly([coeffs], duration).slice(start, stop, duration)</code></li> </ul> </li> <li>Save the ending value of your waveform to be reused elsewhere<ul> <li><code>...poly([coeffs], duration).record(\"you_variable_here\")</code></li> </ul> </li> <li>Begin constructing another drive by starting a new spatial modulation   (this drive will be summed to the one you just created):<ul> <li><code>...poly([coeffs], duration).uniform</code>:     To address all atoms in the field</li> <li><code>...poly([coeffs], duration).location(int)</code>:     To address an atom at a specific location via index</li> <li><code>...poly([coeffs], duration).scale(...)</code><ul> <li>To address an atom at a specific location via variable</li> <li>To address multiple atoms at specific locations by     specifying a single variable and then assigning     it a list of coordinates</li> </ul> </li> </ul> </li> <li>Assign values to pre-existing variables via:<ul> <li><code>...poly([coeffs], duration).assign(variable_name = value)</code>:     to assign a single value to a variable</li> <li><code>...poly([coeffs], duration)     .batch_assign(variable_name = [value1, ...])</code>:     to assign multiple values to a variable</li> <li><code>...poly([coeffs], duration).args([\"previously_defined_var\"])</code>:     to defer assignment of a variable to execution time</li> </ul> </li> <li>Select the backend you want your program to run on via:<ul> <li><code>...poly([coeffs], duration).braket</code>:     to run on Braket local emulator or QuEra hardware remotely</li> <li><code>...poly([coeffs], duration).bloqade</code>:     to run on the Bloqade local emulator</li> <li><code>...poly([coeffs], duration).device</code>:     to specify the backend via string</li> </ul> </li> <li>Choose to parallelize your atom geometry,   duplicating it to fill the whole space:<ul> <li><code>...poly([coeffs], duration).parallelize(spacing)</code></li> </ul> </li> <li>Start targeting another level coupling<ul> <li><code>...poly([coeffs], duration).rydberg</code>:     to target the Rydberg level coupling</li> <li><code>...poly([coeffs], duration).hyperfine</code>:     to target the Hyperfine level coupling</li> </ul> </li> <li>Start targeting other fields within your current level   coupling (previously selected as <code>rydberg</code> or <code>hyperfine</code>):<ul> <li><code>...poly([coeffs], duration).amplitude</code>:     to target the real-valued Rabi Amplitude field</li> <li><code>...poly([coeffs], duration).phase</code>:     to target the real-valued Rabi Phase field</li> <li><code>...poly([coeffs], duration).detuning</code>:     to target the Detuning field</li> <li><code>...poly([coeffs], duration).rabi</code>:     to target the complex-valued Rabi field</li> </ul> </li> </ul> Source code in <code>src/bloqade/builder/waveform.py</code> <pre><code>@beartype\ndef poly(self, coeffs: List[ScalarType], duration: ScalarType) -&gt; \"Poly\":\n    \"\"\"\n    Append or assign a waveform with a polynomial profile to current location(s).\n\n    You pass in a list of coefficients and a duration to this method which obeys\n    the following expression:\n\n    `\n    wv(t) = coeffs[0] + coeffs[1]*t + coeffs[2]*t^2 + ... + coeffs[n]*t^n\n    `\n\n    If you specified a spatial modulation (e.g. `uniform`, `location`,`scale`)\n    previously without a waveform you will now have completed the construction\n    of a \"drive\", one or a sum of drives creating a \"field\"\n    (e.g. Real-valued Rabi Amplitude/Phase).\n\n    If you have already specified a waveform previously you will now be appending\n    this waveform to that previous waveform.\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.detuning.uniform\n    &gt;&gt;&gt; coeffs = [-1, 0.5, 1.2]\n    # resulting polynomial is:\n    # f(t) = -1 + 0.5*t + 1.2*t^2 with duration of\n    # 0.5 us\n    &gt;&gt;&gt; prog.poly(coeffs, duration=0.5)\n    ```\n\n    - Your next steps include:\n    - Continue building your waveform via:\n        - `...poly([coeffs], duration).linear(start, stop, duration)`:\n            to append another linear waveform\n        - `...poly([coeffs], duration).constant(value, duration)`:\n            to append a constant waveform\n        - `...poly([coeffs], duration)\n            .piecewise_linear([durations], [values])`:\n            to append a piecewise linear waveform\n        - `...poly([coeffs], duration)\n            .piecewise_constant([durations],[values])`:\n            to append a piecewise constant waveform\n        - `...poly([coeffs], duration).poly([coefficients], duration)`:\n            to append a polynomial waveform\n        - `...poly([coeffs], duration).apply(waveform)`:\n            to append a pre-defined waveform\n        - `...poly([coeffs], duration).fn(f(t,...))`:\n            to append a waveform defined by a python function\n    - Slice a portion of the waveform to be used:\n        - `...poly([coeffs], duration).slice(start, stop, duration)`\n    - Save the ending value of your waveform to be reused elsewhere\n        - `...poly([coeffs], duration).record(\"you_variable_here\")`\n    - Begin constructing another drive by starting a new spatial modulation\n      (this drive will be summed to the one you just created):\n        - `...poly([coeffs], duration).uniform`:\n            To address all atoms in the field\n        - `...poly([coeffs], duration).location(int)`:\n            To address an atom at a specific location via index\n        - `...poly([coeffs], duration).scale(...)`\n            - To address an atom at a specific location via variable\n            - To address multiple atoms at specific locations by\n                specifying a single variable and then assigning\n                it a list of coordinates\n    - Assign values to pre-existing variables via:\n        - `...poly([coeffs], duration).assign(variable_name = value)`:\n            to assign a single value to a variable\n        - `...poly([coeffs], duration)\n            .batch_assign(variable_name = [value1, ...])`:\n            to assign multiple values to a variable\n        - `...poly([coeffs], duration).args([\"previously_defined_var\"])`:\n            to defer assignment of a variable to execution time\n    - Select the backend you want your program to run on via:\n        - `...poly([coeffs], duration).braket`:\n            to run on Braket local emulator or QuEra hardware remotely\n        - `...poly([coeffs], duration).bloqade`:\n            to run on the Bloqade local emulator\n        - `...poly([coeffs], duration).device`:\n            to specify the backend via string\n    - Choose to parallelize your atom geometry,\n      duplicating it to fill the whole space:\n        - `...poly([coeffs], duration).parallelize(spacing)`\n    - Start targeting another level coupling\n        - `...poly([coeffs], duration).rydberg`:\n            to target the Rydberg level coupling\n        - `...poly([coeffs], duration).hyperfine`:\n            to target the Hyperfine level coupling\n    - Start targeting other fields within your current level\n      coupling (previously selected as `rydberg` or `hyperfine`):\n        - `...poly([coeffs], duration).amplitude`:\n            to target the real-valued Rabi Amplitude field\n        - `...poly([coeffs], duration).phase`:\n            to target the real-valued Rabi Phase field\n        - `...poly([coeffs], duration).detuning`:\n            to target the Detuning field\n        - `...poly([coeffs], duration).rabi`:\n            to target the complex-valued Rabi field\n    \"\"\"\n    return Poly(coeffs, duration, self)\n</code></pre>"},{"location":"reference/bloqade/builder/backend/","title":"Index","text":""},{"location":"reference/bloqade/builder/backend/#bloqade.builder.backend.BackendRoute","title":"BackendRoute","text":"<p>             Bases: <code>QuEraService</code>, <code>BraketService</code>, <code>BloqadeService</code></p> <p>Specify the backend to run your program on via a string (versus more formal builder syntax) of specifying the vendor/product first (Bloqade/Braket) and narrowing it down (e.g: ...device(\"quera.aquila\") versus ...quera.aquila()) - You can pass the following arguments:     - <code>\"braket.aquila\"</code>     - <code>\"braket.local_emulator\"</code>     - <code>\"bloqade.python\"</code>     - <code>\"bloqade.julia\"</code></p>"},{"location":"reference/bloqade/builder/backend/bloqade/","title":"Bloqade","text":""},{"location":"reference/bloqade/builder/backend/bloqade/#bloqade.builder.backend.bloqade.BloqadeDeviceRoute","title":"BloqadeDeviceRoute","text":"<p>             Bases: <code>Builder</code></p>"},{"location":"reference/bloqade/builder/backend/bloqade/#bloqade.builder.backend.bloqade.BloqadeDeviceRoute.python","title":"python","text":"<pre><code>python()\n</code></pre> <p>Specify the Bloqade Python backend.</p> <ul> <li>Possible Next Steps:<ul> <li><code>...python().run(shots)</code>:     to submit to the python emulator and await results</li> </ul> </li> </ul> Source code in <code>src/bloqade/builder/backend/bloqade.py</code> <pre><code>def python(self):\n    \"\"\"\n    Specify the Bloqade Python backend.\n\n    - Possible Next Steps:\n        - `...python().run(shots)`:\n            to submit to the python emulator and await results\n    \"\"\"\n    return self.parse().bloqade.python()\n</code></pre>"},{"location":"reference/bloqade/builder/backend/bloqade/#bloqade.builder.backend.bloqade.BloqadeService","title":"BloqadeService","text":"<p>             Bases: <code>Builder</code></p>"},{"location":"reference/bloqade/builder/backend/bloqade/#bloqade.builder.backend.bloqade.BloqadeService.bloqade","title":"bloqade  <code>property</code>","text":"<pre><code>bloqade\n</code></pre> <p>Specify the Bloqade backend.</p> <ul> <li>Possible Next Steps:<ul> <li><code>...bloqade.python()</code>: target submission to the Bloqade python backend</li> <li><code>...bloqade.julia()</code>: (CURRENTLY NOT IMPLEMENTED!)target     submission to the Bloqade.jl backend</li> </ul> </li> </ul>"},{"location":"reference/bloqade/builder/backend/braket/","title":"Braket","text":""},{"location":"reference/bloqade/builder/backend/braket/#bloqade.builder.backend.braket.BraketDeviceRoute","title":"BraketDeviceRoute","text":"<p>             Bases: <code>Builder</code></p>"},{"location":"reference/bloqade/builder/backend/braket/#bloqade.builder.backend.braket.BraketDeviceRoute.aquila","title":"aquila","text":"<pre><code>aquila()\n</code></pre> <p>Specify QuEra's Aquila QPU on Braket to submit your program to.</p> <p>The number of shots you specify in the subsequent <code>.run</code> method will either:     - dictate the number of times your program is run     - dictate the number of times per parameter your program is run if       you have a variable with batch assignments/intend to conduct       a parameter sweep</p> <ul> <li>Possible next steps are:<ul> <li><code>...aquila().run(shots)</code>: To submit to hardware and WAIT for     results (blocking)</li> <li><code>...aquila().run_async(shots)</code>: To submit to hardware and immediately     allow for other operations to occur</li> </ul> </li> </ul> Source code in <code>src/bloqade/builder/backend/braket.py</code> <pre><code>def aquila(self) -&gt; \"BraketHardwareRoutine\":\n    \"\"\"\n    Specify QuEra's Aquila QPU on Braket to submit your program to.\n\n    The number of shots you specify in the subsequent `.run` method will either:\n        - dictate the number of times your program is run\n        - dictate the number of times per parameter your program is run if\n          you have a variable with batch assignments/intend to conduct\n          a parameter sweep\n\n\n    - Possible next steps are:\n        - `...aquila().run(shots)`: To submit to hardware and WAIT for\n            results (blocking)\n        - `...aquila().run_async(shots)`: To submit to hardware and immediately\n            allow for other operations to occur\n    \"\"\"\n    return self.parse().braket.aquila()\n</code></pre>"},{"location":"reference/bloqade/builder/backend/braket/#bloqade.builder.backend.braket.BraketDeviceRoute.device","title":"device","text":"<pre><code>device(device_arn)\n</code></pre> <p>Specify QPU based on the device ARN on Braket to submit your program to.</p> <p>The number of shots you specify in the subsequent <code>.run</code> method will either:     - dictate the number of times your program is run     - dictate the number of times per parameter your program is run if         you have a variable with batch assignments/intend to conduct         a parameter sweep</p> <ul> <li>Possible next steps are:<ul> <li><code>...device(arn).run(shots)</code>: To submit to hardware and WAIT for     results (blocking)</li> <li><code>...device(arn).run_async(shots)</code>: To submit to hardware and immediately     allow for other operations to occur</li> </ul> </li> </ul> Source code in <code>src/bloqade/builder/backend/braket.py</code> <pre><code>def device(self, device_arn) -&gt; \"BraketHardwareRoutine\":\n    \"\"\"\n    Specify QPU based on the device ARN on Braket to submit your program to.\n\n    The number of shots you specify in the subsequent `.run` method will either:\n        - dictate the number of times your program is run\n        - dictate the number of times per parameter your program is run if\n            you have a variable with batch assignments/intend to conduct\n            a parameter sweep\n\n\n    - Possible next steps are:\n        - `...device(arn).run(shots)`: To submit to hardware and WAIT for\n            results (blocking)\n        - `...device(arn).run_async(shots)`: To submit to hardware and immediately\n            allow for other operations to occur\n    \"\"\"\n    return self.parse().braket.device(device_arn)\n</code></pre>"},{"location":"reference/bloqade/builder/backend/braket/#bloqade.builder.backend.braket.BraketDeviceRoute.local_emulator","title":"local_emulator","text":"<pre><code>local_emulator()\n</code></pre> <p>Specify the Braket local emulator to submit your program to.</p> <ul> <li>The number of shots you specify in the subsequent <code>.run</code> method will either:<ul> <li>dictate the number of times your program is run</li> <li>dictate the number of times per parameter your program is run if   you have a variable with batch assignments/intend to   conduct a parameter sweep</li> </ul> </li> <li>Possible next steps are:<ul> <li><code>...local_emulator().run(shots)</code>: to submit to the emulator     and await results</li> </ul> </li> </ul> Source code in <code>src/bloqade/builder/backend/braket.py</code> <pre><code>def local_emulator(self) -&gt; \"BraketLocalEmulatorRoutine\":\n    \"\"\"\n    Specify the Braket local emulator to submit your program to.\n\n    - The number of shots you specify in the subsequent `.run` method will either:\n        - dictate the number of times your program is run\n        - dictate the number of times per parameter your program is run if\n          you have a variable with batch assignments/intend to\n          conduct a parameter sweep\n    - Possible next steps are:\n        - `...local_emulator().run(shots)`: to submit to the emulator\n            and await results\n\n    \"\"\"\n    return self.parse().braket.local_emulator()\n</code></pre>"},{"location":"reference/bloqade/builder/backend/braket/#bloqade.builder.backend.braket.BraketService","title":"BraketService","text":"<p>             Bases: <code>Builder</code></p>"},{"location":"reference/bloqade/builder/backend/braket/#bloqade.builder.backend.braket.BraketService.braket","title":"braket  <code>property</code>","text":"<pre><code>braket\n</code></pre> <p>Specify the Braket backend. This allows you to access the AWS Braket local emulator OR go submit things to QuEra hardware on AWS Braket service.</p> <ul> <li>Possible Next Steps are:<ul> <li><code>...braket.aquila()</code>: target submission to the QuEra Aquila QPU</li> <li><code>...braket.local_emulator()</code>: target submission to the Braket local emulator</li> </ul> </li> </ul>"},{"location":"reference/bloqade/builder/backend/quera/","title":"Quera","text":""},{"location":"reference/bloqade/builder/backend/quera/#bloqade.builder.backend.quera.QuEraDeviceRoute","title":"QuEraDeviceRoute","text":"<p>             Bases: <code>Builder</code></p>"},{"location":"reference/bloqade/builder/backend/quera/#bloqade.builder.backend.quera.QuEraDeviceRoute.aquila","title":"aquila","text":"<pre><code>aquila()\n</code></pre> <p>Specify QuEra's Aquila QPU</p> Return <p>QuEraHardwareRoutine</p> <ul> <li> <p>Possible Next:</p> <p>-&gt; <code>...aquila().submit</code>     :: submit aync remote job</p> <p>-&gt; <code>...aquila().run</code>     :: submit job and wait until job finished     and results returned</p> <p>-&gt; <code>...aquila().__callable__</code>     :: submit job and wait until job finished     and results returned</p> </li> </ul> Source code in <code>src/bloqade/builder/backend/quera.py</code> <pre><code>def aquila(self):\n    \"\"\"\n    Specify QuEra's Aquila QPU\n\n    Return:\n        QuEraHardwareRoutine\n\n\n    - Possible Next:\n\n        -&gt; `...aquila().submit`\n            :: submit aync remote job\n\n        -&gt; `...aquila().run`\n            :: submit job and wait until job finished\n            and results returned\n\n        -&gt; `...aquila().__callable__`\n            :: submit job and wait until job finished\n            and results returned\n\n\n    \"\"\"\n    return self.parse().quera.aquila()\n</code></pre>"},{"location":"reference/bloqade/builder/backend/quera/#bloqade.builder.backend.quera.QuEraDeviceRoute.cloud_mock","title":"cloud_mock","text":"<pre><code>cloud_mock()\n</code></pre> <p>Specify QuEra's Remote Mock QPU</p> Return <p>QuEraHardwareRoutine</p> <ul> <li> <p>Possible Next:</p> <p>-&gt; <code>...aquila().submit</code>     :: submit aync remote job</p> <p>-&gt; <code>...aquila().run</code>     :: submit job and wait until job finished     and results returned</p> <p>-&gt; <code>...aquila().__callable__</code>     :: submit job and wait until job finished     and results returned</p> </li> </ul> Source code in <code>src/bloqade/builder/backend/quera.py</code> <pre><code>def cloud_mock(self):\n    \"\"\"\n    Specify QuEra's Remote Mock QPU\n\n    Return:\n        QuEraHardwareRoutine\n\n    - Possible Next:\n\n        -&gt; `...aquila().submit`\n            :: submit aync remote job\n\n        -&gt; `...aquila().run`\n            :: submit job and wait until job finished\n            and results returned\n\n        -&gt; `...aquila().__callable__`\n            :: submit job and wait until job finished\n            and results returned\n\n\n\n    \"\"\"\n    return self.parse().quera.cloud_mock()\n</code></pre>"},{"location":"reference/bloqade/builder/backend/quera/#bloqade.builder.backend.quera.QuEraDeviceRoute.device","title":"device","text":"<pre><code>device(config_file=None, **api_config)\n</code></pre> <p>Specify QuEra's QPU device,</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>file that speficy the target hardware</p> <code>None</code> Return <p>QuEraHardwareRoutine</p> <ul> <li> <p>Possible Next:</p> <p>-&gt; <code>...device().submit</code>     :: submit aync remote job</p> <p>-&gt; <code>...device().run</code>     :: submit job and wait until job finished     and results returned</p> <p>-&gt; <code>...device().__callable__</code>     :: submit job and wait until job finished     and results returned</p> </li> </ul> Source code in <code>src/bloqade/builder/backend/quera.py</code> <pre><code>def device(self, config_file: Optional[str] = None, **api_config):\n    \"\"\"\n    Specify QuEra's QPU device,\n\n    Args:\n        config_file (str): file that speficy the target hardware\n\n    Return:\n        QuEraHardwareRoutine\n\n    - Possible Next:\n\n        -&gt; `...device().submit`\n            :: submit aync remote job\n\n        -&gt; `...device().run`\n            :: submit job and wait until job finished\n            and results returned\n\n        -&gt; `...device().__callable__`\n            :: submit job and wait until job finished\n            and results returned\n\n\n    \"\"\"\n    return self.parse().quera.device(config_file, **api_config)\n</code></pre>"},{"location":"reference/bloqade/builder/backend/quera/#bloqade.builder.backend.quera.QuEraDeviceRoute.mock","title":"mock","text":"<pre><code>mock(state_file='.mock_state.txt', submission_error=False)\n</code></pre> <p>Specify mock, testing locally.</p> Return <p>QuEraHardwareRoutine</p> <ul> <li> <p>Possible Next:</p> <p>-&gt; <code>...aquila().submit</code>     :: submit aync remote job</p> <p>-&gt; <code>...aquila().run</code>     :: submit job and wait until job finished     and results returned</p> <p>-&gt; <code>...aquila().__callable__</code>     :: submit job and wait until job finished     and results returned</p> </li> </ul> Source code in <code>src/bloqade/builder/backend/quera.py</code> <pre><code>def mock(self, state_file: str = \".mock_state.txt\", submission_error: bool = False):\n    \"\"\"\n    Specify mock, testing locally.\n\n    Return:\n        QuEraHardwareRoutine\n\n    - Possible Next:\n\n        -&gt; `...aquila().submit`\n            :: submit aync remote job\n\n        -&gt; `...aquila().run`\n            :: submit job and wait until job finished\n            and results returned\n\n        -&gt; `...aquila().__callable__`\n            :: submit job and wait until job finished\n            and results returned\n\n\n\n    \"\"\"\n    return self.parse().quera.mock(\n        state_file=state_file, submission_error=submission_error\n    )\n</code></pre>"},{"location":"reference/bloqade/builder/backend/quera/#bloqade.builder.backend.quera.QuEraService","title":"QuEraService","text":"<p>             Bases: <code>Builder</code></p>"},{"location":"reference/bloqade/builder/backend/quera/#bloqade.builder.backend.quera.QuEraService.quera","title":"quera  <code>property</code>","text":"<pre><code>quera\n</code></pre> <ul> <li>Specify Quera backend</li> <li> <p>Possible Next:</p> <p>-&gt; <code>...quera.aquila</code>     :: Aquila QPU</p> <p>-&gt; <code>...quera.mock</code>     :: mock backend, meant for testings</p> <p>-&gt; <code>...quera.device</code>     :: QuEra QPU, specifiy by config_file</p> </li> </ul>"},{"location":"reference/bloqade/builder/parse/","title":"Index","text":""},{"location":"reference/bloqade/builder/parse/builder/","title":"Builder","text":""},{"location":"reference/bloqade/builder/parse/stream/","title":"Stream","text":""},{"location":"reference/bloqade/builder/parse/stream/#bloqade.builder.parse.stream.BuilderStream","title":"BuilderStream  <code>dataclass</code>","text":"<p>Represents a stream of builder nodes.</p>"},{"location":"reference/bloqade/builder/parse/stream/#bloqade.builder.parse.stream.BuilderStream.eat","title":"eat","text":"<pre><code>eat(types, skips=None)\n</code></pre> <p>Scan the stream until a node of type in <code>types</code> or <code>skips</code> is found.</p> <p>Parameters:</p> Name Type Description Default <code>types</code> <code>List[Type[Builder]]</code> <p>List of types to move the stream pointer to</p> required <code>skips</code> <code>List[Type[Builder]] | None</code> <p>List of types to end the</p> <code>None</code> <p>Returns:</p> Name Type Description <code>BuilderNode</code> <code>BuilderNode</code> <p>The beginning of the stream which matches a type in <code>types</code>.</p> Source code in <code>src/bloqade/builder/parse/stream.py</code> <pre><code>def eat(\n    self, types: List[Type[Builder]], skips: Optional[List[Type[Builder]]] = None\n) -&gt; BuilderNode:\n    \"\"\"Scan the stream until a node of type in `types` or `skips` is found.\n\n    Args:\n        types (List[Type[Builder]]): List of types to move the stream pointer to\n        skips (List[Type[Builder]] | None, optional): List of types to end the\n        stream scan\n\n    Returns:\n        BuilderNode: The beginning of the stream which matches a type in `types`.\n    \"\"\"\n    head = self.read_next(types)\n    curr = head\n    while curr is not None:\n        if type(curr.node) not in types:\n            if skips and type(curr.node) not in skips:\n                break\n        curr = curr.next\n    self.curr = curr\n    return head\n</code></pre>"},{"location":"reference/bloqade/builder/parse/trait/","title":"Trait","text":""},{"location":"reference/bloqade/builder/parse/trait/#bloqade.builder.parse.trait.Parse","title":"Parse","text":"<p>             Bases: <code>ParseRegister</code>, <code>ParseSequence</code>, <code>ParseCircuit</code>, <code>ParseRoutine</code></p>"},{"location":"reference/bloqade/builder/parse/trait/#bloqade.builder.parse.trait.Parse.n_atoms","title":"n_atoms  <code>property</code>","text":"<pre><code>n_atoms\n</code></pre> <p>Return the number of atoms in the program.</p>"},{"location":"reference/bloqade/builder/parse/trait/#bloqade.builder.parse.trait.ParseCircuit","title":"ParseCircuit","text":""},{"location":"reference/bloqade/builder/parse/trait/#bloqade.builder.parse.trait.ParseCircuit.parse_circuit","title":"parse_circuit","text":"<pre><code>parse_circuit()\n</code></pre> <p>Parse the analog circuit from the program.</p> Source code in <code>src/bloqade/builder/parse/trait.py</code> <pre><code>def parse_circuit(self: \"Builder\") -&gt; \"AnalogCircuit\":\n    \"\"\"Parse the analog circuit from the program.\"\"\"\n    from bloqade.builder.parse.builder import Parser\n\n    return Parser().parse_circuit(self)\n</code></pre>"},{"location":"reference/bloqade/builder/parse/trait/#bloqade.builder.parse.trait.ParseRegister","title":"ParseRegister","text":""},{"location":"reference/bloqade/builder/parse/trait/#bloqade.builder.parse.trait.ParseRegister.parse_register","title":"parse_register","text":"<pre><code>parse_register()\n</code></pre> <p>Parse the arrangement of atoms of the program.</p> Source code in <code>src/bloqade/builder/parse/trait.py</code> <pre><code>def parse_register(self: \"Builder\") -&gt; Union[\"AtomArrangement\", \"ParallelRegister\"]:\n    \"\"\"Parse the arrangement of atoms of the program.\"\"\"\n    from bloqade.builder.parse.builder import Parser\n\n    return Parser().parse_register(self)\n</code></pre>"},{"location":"reference/bloqade/builder/parse/trait/#bloqade.builder.parse.trait.ParseRoutine","title":"ParseRoutine","text":""},{"location":"reference/bloqade/builder/parse/trait/#bloqade.builder.parse.trait.ParseRoutine.parse","title":"parse","text":"<pre><code>parse()\n</code></pre> <p>Parse the program to return a Routine object.</p> Source code in <code>src/bloqade/builder/parse/trait.py</code> <pre><code>def parse(self: \"Builder\") -&gt; \"Routine\":\n    \"\"\"Parse the program to return a Routine object.\"\"\"\n    from bloqade.builder.parse.builder import Parser\n\n    return Parser().parse(self)\n</code></pre>"},{"location":"reference/bloqade/builder/parse/trait/#bloqade.builder.parse.trait.ParseSequence","title":"ParseSequence","text":""},{"location":"reference/bloqade/builder/parse/trait/#bloqade.builder.parse.trait.ParseSequence.parse_sequence","title":"parse_sequence","text":"<pre><code>parse_sequence()\n</code></pre> <p>Parse the pulse sequence part of the program.</p> Source code in <code>src/bloqade/builder/parse/trait.py</code> <pre><code>def parse_sequence(self: \"Builder\") -&gt; \"Sequence\":\n    \"\"\"Parse the pulse sequence part of the program.\"\"\"\n    from bloqade.builder.parse.builder import Parser\n\n    return Parser().parse_sequence(self)\n</code></pre>"},{"location":"reference/bloqade/emulate/","title":"Index","text":""},{"location":"reference/bloqade/emulate/sparse_operator/","title":"Sparse operator","text":""},{"location":"reference/bloqade/emulate/ir/","title":"Index","text":""},{"location":"reference/bloqade/emulate/ir/atom_type/","title":"Atom type","text":""},{"location":"reference/bloqade/emulate/ir/emulator/","title":"Emulator","text":""},{"location":"reference/bloqade/emulate/ir/emulator/#bloqade.emulate.ir.emulator.Register","title":"Register  <code>dataclass</code>","text":"<p>This class represents the of the atoms in the system.</p>"},{"location":"reference/bloqade/emulate/ir/space/","title":"Space","text":""},{"location":"reference/bloqade/emulate/ir/state_vector/","title":"State vector","text":""},{"location":"reference/bloqade/emulate/ir/state_vector/#bloqade.emulate.ir.state_vector.AnalogGate","title":"AnalogGate  <code>dataclass</code>","text":""},{"location":"reference/bloqade/emulate/ir/state_vector/#bloqade.emulate.ir.state_vector.AnalogGate.run","title":"run","text":"<pre><code>run(\n    shots=1,\n    solver_name=\"dop853\",\n    atol=1e-14,\n    rtol=1e-07,\n    nsteps=2147483647,\n    interaction_picture=False,\n    project_hyperfine=True,\n)\n</code></pre> <p>Run the emulation with all atoms in the ground state, sampling the final state vector.</p> Source code in <code>src/bloqade/emulate/ir/state_vector.py</code> <pre><code>@beartype\ndef run(\n    self,\n    shots: int = 1,\n    solver_name: str = \"dop853\",\n    atol: float = 1e-14,\n    rtol: float = 1e-7,\n    nsteps: int = 2_147_483_647,\n    interaction_picture: bool = False,\n    project_hyperfine: bool = True,\n):\n    \"\"\"Run the emulation with all atoms in the ground state,\n    sampling the final state vector.\"\"\"\n\n    options = dict(\n        solver_name=solver_name,\n        atol=atol,\n        rtol=rtol,\n        nsteps=nsteps,\n        interaction_picture=interaction_picture,\n    )\n\n    state = self.hamiltonian.space.zero_state()\n    (result,) = self.apply(state, **options)\n    result /= np.linalg.norm(result)\n\n    return self.hamiltonian.space.sample_state_vector(\n        result, shots, project_hyperfine=project_hyperfine\n    )\n</code></pre>"},{"location":"reference/bloqade/ir/","title":"Index","text":""},{"location":"reference/bloqade/ir/#bloqade.ir.start","title":"start  <code>module-attribute</code>","text":"<pre><code>start = ListOfLocations()\n</code></pre> <p>A Program starting point, alias of empty <code>ListOfLocations</code>.</p> <ul> <li>Next possible steps to build your program are:</li> <li>Specify which level coupling to address with:<ul> <li><code>start.rydberg</code>: for <code>Rydberg</code>     Level coupling</li> <li><code>start.hyperfine</code>: for <code>Hyperfine</code>     Level coupling</li> <li>LOCKOUT: You cannot add atoms to your geometry after specifying level coupling.</li> </ul> </li> <li>continue/start building your geometry with:<ul> <li><code>start.add_position()</code>: to add atom(s) to current register. It will accept:<ul> <li>A single coordinate, represented as a tuple (e.g. <code>(5,6)</code>) with a value that   can either be:<ul> <li>integers: <code>(5,6)</code></li> <li>floats: <code>(5.1, 2.5)</code></li> <li>strings (for later variable assignment): <code>(\"x\", \"y\")</code></li> <li><code>Scalar</code> objects: <code>(2*cast(\"x\"), 5+cast(\"y\"))</code></li> </ul> </li> <li>A list of coordinates, represented as a list of types mentioned previously.</li> <li>A numpy array with shape (n, 2) where n is the total number of atoms</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/bloqade/ir/#bloqade.ir.AlignedWaveform","title":"AlignedWaveform","text":"<p>             Bases: <code>Waveform</code></p> <pre><code>&lt;padded waveform&gt; ::= &lt;waveform&gt; | &lt;waveform&gt; &lt;alignment&gt; &lt;value&gt;\n\n&lt;alignment&gt; ::= 'left aligned' | 'right aligned'\n&lt;value&gt; ::= 'left value' | 'right value' | &lt;scalar expr&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.AnalogCircuit","title":"AnalogCircuit","text":"<p>AnalogCircuit is a dummy type that bundle register and sequence together.</p>"},{"location":"reference/bloqade/ir/#bloqade.ir.AnalogCircuit.register","title":"register  <code>property</code>","text":"<pre><code>register\n</code></pre> <p>Get the register of the program.</p> <p>Returns:</p> Type Description <p>register (Union[\"AtomArrangement\", \"ParallelRegister\"])</p> Note <p>If the program is built with <code>parallelize()</code>, The the register will be a <code>ParallelRegister</code>. Otherwise it will be a <code>AtomArrangement</code>.</p>"},{"location":"reference/bloqade/ir/#bloqade.ir.AnalogCircuit.show","title":"show","text":"<pre><code>show(**assignments)\n</code></pre> <p>Interactive visualization of the program</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>assigning the instance value (literal) to the existing variables in the program</p> <code>{}</code> Source code in <code>src/bloqade/ir/analog_circuit.py</code> <pre><code>def show(self, **assignments):\n    \"\"\"Interactive visualization of the program\n\n    Args:\n        **assignments: assigning the instance value (literal) to the\n            existing variables in the program\n\n    \"\"\"\n    display_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.AtomArrangement","title":"AtomArrangement","text":"<p>             Bases: <code>ProgramStart</code>, <code>TransformTrait</code></p>"},{"location":"reference/bloqade/ir/#bloqade.ir.AtomArrangement.n_atoms","title":"n_atoms  <code>property</code>","text":"<pre><code>n_atoms\n</code></pre> <p>number of atoms (filled sites) in the register.</p>"},{"location":"reference/bloqade/ir/#bloqade.ir.AtomArrangement.n_dims","title":"n_dims  <code>property</code>","text":"<pre><code>n_dims\n</code></pre> <p>number of dimensions in the register.</p>"},{"location":"reference/bloqade/ir/#bloqade.ir.AtomArrangement.n_sites","title":"n_sites  <code>property</code>","text":"<pre><code>n_sites\n</code></pre> <p>number of sites in the register.</p>"},{"location":"reference/bloqade/ir/#bloqade.ir.AtomArrangement.n_vacant","title":"n_vacant  <code>property</code>","text":"<pre><code>n_vacant\n</code></pre> <p>number of vacant sites in the register.</p>"},{"location":"reference/bloqade/ir/#bloqade.ir.AtomArrangement.enumerate","title":"enumerate","text":"<pre><code>enumerate()\n</code></pre> <p>enumerate all locations in the register.</p> Source code in <code>src/bloqade/ir/location/base.py</code> <pre><code>def enumerate(self) -&gt; Generator[LocationInfo, None, None]:\n    \"\"\"enumerate all locations in the register.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.AtomArrangement.figure","title":"figure","text":"<pre><code>figure(fig_kwargs=None, **assignments)\n</code></pre> <p>obtain a figure object from the atom arrangement.</p> Source code in <code>src/bloqade/ir/location/base.py</code> <pre><code>def figure(self, fig_kwargs=None, **assignments):\n    \"\"\"obtain a figure object from the atom arrangement.\"\"\"\n    return get_atom_arrangement_figure(self, fig_kwargs, **assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.AtomArrangement.rydberg_interaction","title":"rydberg_interaction","text":"<pre><code>rydberg_interaction(**assignments)\n</code></pre> <p>calculate the Rydberg interaction matrix.</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>the values to assign to the variables in the register.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>the Rydberg interaction matrix in the lower triangular form.</p> Source code in <code>src/bloqade/ir/location/base.py</code> <pre><code>def rydberg_interaction(self, **assignments) -&gt; NDArray:\n    \"\"\"calculate the Rydberg interaction matrix.\n\n    Args:\n        **assignments: the values to assign to the variables in the register.\n\n    Returns:\n        NDArray: the Rydberg interaction matrix in the lower triangular form.\n\n    \"\"\"\n\n    from bloqade.constants import RB_C6\n\n    # calculate the Interaction matrix\n    V_ij = np.zeros((self.n_sites, self.n_sites))\n    for i, site_i in enumerate(self.enumerate()):\n        pos_i = np.array([float(ele(**assignments)) for ele in site_i.position])\n\n        for j, site_j in enumerate(self.enumerate()):\n            if j &gt;= i:\n                break  # enforce lower triangular form\n\n            pos_j = np.array([float(ele(**assignments)) for ele in site_j.position])\n            r_ij = np.linalg.norm(pos_i - pos_j)\n\n            V_ij[i, j] = RB_C6 / r_ij**6\n\n    return V_ij\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.BoundedBravais","title":"BoundedBravais","text":"<pre><code>BoundedBravais(*shape, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>AtomArrangement</code></p> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(self, *shape: int, lattice_spacing: ScalarType = 1.0):\n    self.shape = shape\n    self.lattice_spacing = cast(lattice_spacing)\n    self.__n_atoms = None\n    self.__n_dims = None\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.BoundedBravais.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('shape', 'lattice_spacing')\n</code></pre> <p>Base classe for Bravais lattices <code>AtomArrangement</code>.</p> <ul> <li><code>Square</code></li> <li><code>Chain</code></li> <li><code>Honeycomb</code></li> <li><code>Triangular</code></li> <li><code>Lieb</code></li> <li><code>Kagome</code></li> <li><code>Rectangular</code></li> </ul>"},{"location":"reference/bloqade/ir/#bloqade.ir.BoundedBravais.n_dims","title":"n_dims  <code>property</code>","text":"<pre><code>n_dims\n</code></pre> <p>dimension of the lattice</p> <p>Returns:</p> Name Type Description <code>int</code> <p>dimension of the lattice</p>"},{"location":"reference/bloqade/ir/#bloqade.ir.BoundedBravais.coordinates","title":"coordinates","text":"<pre><code>coordinates(index)\n</code></pre> <p>calculate the coordinates of a cell in the lattice given the cell index.</p> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef coordinates(self, index: List[int]) -&gt; NDArray:\n    \"\"\"calculate the coordinates of a cell in the lattice\n    given the cell index.\n    \"\"\"\n    # damn! this is like stone age broadcasting\n    vectors = np.array(self.cell_vectors())\n    index = np.array(index)\n    pos = np.sum(vectors.T * index, axis=1)\n    return pos + np.array(self.cell_atoms())\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.BoundedBravais.scale","title":"scale","text":"<pre><code>scale(factor)\n</code></pre> <p>Scale the current location with a factor.</p> <p>(x,y) -&gt; factor*(x,y)</p> <p>Parameters:</p> Name Type Description Default <code>factor</code> <code>str | Real | Decimal | Scalar</code> <p>scale factor</p> required <p>Returns:</p> Name Type Description <code>BoundedBravais</code> <code>BoundedBravais</code> <p>The lattice with the scaled locations</p> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef scale(self, factor: ScalarType) -&gt; \"BoundedBravais\":\n    \"\"\"Scale the current location with a factor.\n\n    (x,y) -&gt; factor*(x,y)\n\n    Args:\n        factor (str | Real | Decimal | Scalar): scale factor\n\n    Returns:\n        BoundedBravais: The lattice with the scaled locations\n    \"\"\"\n    factor = cast(factor)\n    obj = self.__new__(type(self))\n    for f in fields(self):\n        if f.name == \"lattice_spacing\":\n            obj.lattice_spacing = factor * self.lattice_spacing\n        else:\n            setattr(obj, f.name, getattr(self, f.name))\n    return obj\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Chain","title":"Chain","text":"<pre><code>Chain(L, lattice_spacing=1.0, vertical_chain=False)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Chain lattice.</p> <ul> <li>1D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0).</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in the chain</p> required <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L: int, lattice_spacing: ScalarType = 1.0, vertical_chain: bool = False\n):\n    self.vertical = vertical_chain\n    super().__init__(L, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Constant","title":"Constant","text":"<pre><code>Constant(value, duration)\n</code></pre> <p>             Bases: <code>Instruction</code></p> <pre><code>&lt;constant&gt; ::= 'constant' &lt;scalar expr&gt;\n</code></pre> <p>f(t=0:duration) = value</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Scalar</code> <p>the constant value</p> required <code>duration</code> <code>Scalar</code> <p>the time span of the constant waveform.</p> required Source code in <code>src/bloqade/ir/control/waveform.py</code> <pre><code>@beartype\ndef __init__(self, value: ScalarType, duration: ScalarType):\n    object.__setattr__(self, \"value\", cast(value))\n    object.__setattr__(self, \"duration\", cast(duration))\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Field","title":"Field","text":"<p>             Bases: <code>FieldExpr</code></p> <p>Field node in the IR. Which contains collection(s) of <code>Waveform</code></p> <pre><code>&lt;field&gt; ::= ('field' &lt;spatial modulation&gt;  &lt;padded waveform&gt;)*\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Field.canonicalize","title":"canonicalize","text":"<pre><code>canonicalize()\n</code></pre> <p>Canonicalize the Field by merging <code>ScaledLocation</code> nodes with the same waveform.</p> Source code in <code>src/bloqade/ir/control/field.py</code> <pre><code>def canonicalize(self) -&gt; \"Field\":\n    \"\"\"\n    Canonicalize the Field by merging `ScaledLocation` nodes with the same waveform.\n    \"\"\"\n    reversed_dirves = {}\n\n    for sm, wf in self.drives.items():\n        reversed_dirves[wf] = reversed_dirves.get(wf, []) + [sm]\n\n    drives = {}\n\n    for wf, sms in reversed_dirves.items():\n        new_sm = [sm for sm in sms if not isinstance(sm, ScaledLocations)]\n        scaled_locations_sm = [sm for sm in sms if isinstance(sm, ScaledLocations)]\n\n        new_mask = {}\n\n        for ele in scaled_locations_sm:\n            for loc, scl in ele.value.items():\n                new_mask[loc] = new_mask.get(loc, 0) + cast(scl)\n\n        if new_mask:\n            new_sm += [ScaledLocations(new_mask)]\n\n        for sm in new_sm:\n            drives[sm] = wf\n\n    return Field(drives)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Field.show","title":"show","text":"<pre><code>show(**assignments)\n</code></pre> <p>Interactive visualization of the Field</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>assigning the instance value (literal) to the existing variables in the Field</p> <code>{}</code> Source code in <code>src/bloqade/ir/control/field.py</code> <pre><code>def show(self, **assignments):\n    \"\"\"\n    Interactive visualization of the Field\n\n    Args:\n        **assignments: assigning the instance value (literal) to the\n            existing variables in the Field\n\n    \"\"\"\n    display_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Honeycomb","title":"Honeycomb","text":"<pre><code>Honeycomb(L1, L2=None, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Honeycomb lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (\u00bd, sqrt(3)/2)</li> </ul> </li> <li>unit cell (2 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (\u00bd, 1/(2*sqrt(3))</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of unit cells in linear direction. n_atoms = L1 * L1 * 2.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of unit cells in direction a2. n_atoms = L1 * L2 * 2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    super().__init__(L1, L2, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Kagome","title":"Kagome","text":"<pre><code>Kagome(L1, L2=None, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Kagome lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (\u00bd, sqrt(3)/2)</li> </ul> </li> <li>unit cell (3 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (0.5, 0)</li> <li>loc3 (0.25 ,0.25sqrt(3))</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of sites in linear direction. n_atoms = 3 * L1 * L1.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of unit cells along a2 direction, n_atoms = 3 * L1 * L2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    super().__init__(L1, L2, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Lieb","title":"Lieb","text":"<pre><code>Lieb(L1, L2=None, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Lieb lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (0, 1)</li> </ul> </li> <li>unit cell (3 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (0.5, 0)</li> <li>loc3 (0 ,0.5)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of unit cells in linear direction. n_atoms = 3* L1 * L1.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of unit cells along a2 direction, n_atoms = 3 * L1 * L2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    super().__init__(L1, L2, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Linear","title":"Linear","text":"<pre><code>Linear(start, stop, duration)\n</code></pre> <p>             Bases: <code>Instruction</code></p> <pre><code>&lt;linear&gt; ::= 'linear' &lt;scalar expr&gt; &lt;scalar expr&gt;\n</code></pre> <p>f(t=0:duration) = start + (stop-start)/duration * t</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Scalar</code> <p>start value</p> required <code>stop</code> <code>Scalar</code> <p>stop value</p> required <code>duration</code> <code>Scalar</code> <p>the time span of the linear waveform.</p> required Source code in <code>src/bloqade/ir/control/waveform.py</code> <pre><code>@beartype\ndef __init__(self, start: ScalarType, stop: ScalarType, duration: ScalarType):\n    object.__setattr__(self, \"start\", cast(start))\n    object.__setattr__(self, \"stop\", cast(stop))\n    object.__setattr__(self, \"duration\", cast(duration))\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Literal","title":"Literal","text":"<p>             Bases: <code>Real</code></p>"},{"location":"reference/bloqade/ir/#bloqade.ir.Literal.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value\n</code></pre> <p>Scalar Literal, which stores a decimaal value instance.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Decimal</code> <p>decimal value instance</p> required"},{"location":"reference/bloqade/ir/#bloqade.ir.ParallelRegister","title":"ParallelRegister","text":"<pre><code>ParallelRegister(register, cluster_spacing)\n</code></pre> <p>             Bases: <code>ProgramStart</code></p> <p>Parallel Register</p> Source code in <code>src/bloqade/ir/location/base.py</code> <pre><code>@beartype\ndef __init__(self, register: AtomArrangement, cluster_spacing: ScalarType):\n    self._register = register\n    self._cluster_spacing = cast(cluster_spacing)\n\n    if register.n_atoms &gt; 0:\n        # calculate bounding box\n        # of this register\n        location_iter = register.enumerate()\n        (x, y) = next(location_iter).position\n        x_min = x\n        x_max = x\n        y_min = y\n        y_max = y\n\n        for location_info in location_iter:\n            (x, y) = location_info.position\n            x_min = x.min(x_min)\n            x_max = x.max(x_max)\n            y_min = y.min(y_min)\n            y_max = y.max(y_max)\n\n        shift_x = (x_max - x_min) + cluster_spacing\n        shift_y = (y_max - y_min) + cluster_spacing\n\n        register_locations = [\n            list(location_info.position) for location_info in register.enumerate()\n        ]\n        register_filling = [\n            location_info.filling.value for location_info in register.enumerate()\n        ]\n        shift_vectors = [[shift_x, cast(0)], [cast(0), shift_y]]\n    else:\n        raise ValueError(\"No locations to parallelize.\")\n\n    self.register_locations = register_locations\n    self.register_filling = register_filling\n    self.shift_vectors = shift_vectors\n    super().__init__(self)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Poly","title":"Poly","text":"<pre><code>Poly(coeffs, duration)\n</code></pre> <p>             Bases: <code>Instruction</code></p> <pre><code>&lt;poly&gt; ::= &lt;scalar&gt;+\n</code></pre> <p>f(t=0:duration) = c[0] + c[1]t + c[2]t^2 + ... + c[n-1]t^n-1 + c[n]t^n</p> <p>Parameters:</p> Name Type Description Default <code>coeffs</code> <code>List[Scalar]</code> <p>the coefficients c[] of the polynomial.</p> required <code>duration</code> <code>Scalar</code> <p>the time span of the waveform.</p> required Source code in <code>src/bloqade/ir/control/waveform.py</code> <pre><code>@beartype\ndef __init__(self, coeffs: List[ScalarType], duration: ScalarType):\n    object.__setattr__(self, \"coeffs\", tuple(map(cast, coeffs)))\n    object.__setattr__(self, \"duration\", cast(duration))\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Pulse","title":"Pulse","text":"<pre><code>Pulse(field_pairs)\n</code></pre> <p>             Bases: <code>PulseExpr</code></p> <pre><code>&lt;pulse&gt; ::= (&lt;field name&gt; &lt;field&gt;)+\n</code></pre> Source code in <code>src/bloqade/ir/control/pulse.py</code> <pre><code>def __init__(self, field_pairs):\n    fields = dict()\n    for k, v in field_pairs.items():\n        if isinstance(v, Field):\n            fields[k] = v\n        elif isinstance(v, dict):\n            fields[k] = Field(v)\n        else:\n            raise TypeError(f\"Expected Field or dict, got {type(v)}\")\n    self.fields = fields\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Pulse.show","title":"show","text":"<pre><code>show(**assignments)\n</code></pre> <p>Interactive visualization of the Pulse</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>assigning the instance value (literal) to the existing variables in the Pulse</p> <code>{}</code> Source code in <code>src/bloqade/ir/control/pulse.py</code> <pre><code>def show(self, **assignments):\n    \"\"\"\n    Interactive visualization of the Pulse\n\n    Args:\n        **assignments: assigning the instance value (literal) to the\n            existing variables in the Pulse\n\n    \"\"\"\n    display_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.PythonFn","title":"PythonFn","text":"<p>             Bases: <code>Instruction</code></p> <pre><code>&lt;python-fn&gt; ::= 'python-fn' &lt;python function def&gt; &lt;scalar expr&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Record","title":"Record","text":"<p>             Bases: <code>Waveform</code></p> <pre><code>&lt;record&gt; ::= 'record' &lt;waveform&gt; &lt;var&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Rectangular","title":"Rectangular","text":"<pre><code>Rectangular(\n    width,\n    height,\n    lattice_spacing_x=1.0,\n    lattice_spacing_y=None,\n)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Rectangular lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0)</li> <li>a2 = (0,1)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>number of sites in x direction.</p> required <code>height</code> <code>int</code> <p>number of sites in y direction.</p> required <code>lattice_spacing_x</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <code>lattice_spacing_y</code> <code>(Scalar, Real)</code> <p>lattice spacing in y direction. optional.</p> <code>None</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    width: int,\n    height: int,\n    lattice_spacing_x: ScalarType = 1.0,\n    lattice_spacing_y: Optional[ScalarType] = None,\n):\n    super().__init__(width, height, lattice_spacing=lattice_spacing_x)\n\n    if lattice_spacing_y is None:\n        self.ratio = cast(1.0) / cast(lattice_spacing_x)\n    else:\n        self.ratio = cast(lattice_spacing_y) / cast(lattice_spacing_x)\n\n    super().__init__(width, height, lattice_spacing=lattice_spacing_x)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Sample","title":"Sample","text":"<p>             Bases: <code>Waveform</code></p> <pre><code>&lt;sample&gt; ::= 'sample' &lt;waveform&gt; &lt;interpolation&gt; &lt;scalar&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Scalar","title":"Scalar","text":"<p>Base class for all scalar expressions.</p> <pre><code>&lt;scalar&gt; ::= &lt;literal&gt;\n| &lt;variable&gt;\n| &lt;default&gt;\n| &lt;negative&gt;\n| &lt;add&gt;\n| &lt;mul&gt;\n| &lt;min&gt;\n| &lt;max&gt;\n| &lt;slice&gt;\n| &lt;inverval&gt;\n\n&lt;mul&gt; ::= &lt;scalar&gt; '*' &lt;scalar&gt;\n&lt;add&gt; ::= &lt;scalar&gt; '+' &lt;scalar&gt;\n&lt;min&gt; ::= 'min' &lt;scalar&gt;+\n&lt;max&gt; ::= 'max' &lt;scalar&gt;+\n&lt;slice&gt; ::= &lt;scalar expr&gt; '[' &lt;interval&gt; ']'\n&lt;interval&gt; ::= &lt;scalar expr&gt; '..' &lt;scalar expr&gt;\n&lt;real&gt; ::= &lt;literal&gt; | &lt;var&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Sequence","title":"Sequence","text":"<pre><code>Sequence(seq_pairs=None)\n</code></pre> <p>             Bases: <code>SequenceExpr</code></p> <p>Sequence of a program, which includes pulses informations.</p> Source code in <code>src/bloqade/ir/control/sequence.py</code> <pre><code>def __init__(self, seq_pairs: Optional[Dict] = None):\n    if seq_pairs is None:\n        self.pulses = {}\n        return\n\n    pulses = {}\n    for level_coupling, pulse in seq_pairs.items():\n        if not isinstance(level_coupling, LevelCoupling):\n            raise TypeError(f\"Unexpected type {type(level_coupling)}\")\n\n        if isinstance(pulse, PulseExpr):\n            pulses[level_coupling] = pulse\n        elif isinstance(pulse, dict):\n            pulses[level_coupling] = Pulse(pulse)\n        else:\n            raise TypeError(f\"Unexpected type {type(pulse)}\")\n    self.pulses = pulses\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Sequence.show","title":"show","text":"<pre><code>show(**assignments)\n</code></pre> <p>Interactive visualization of the Sequence</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>assigning the instance value (literal) to the existing variables in the Sequence</p> <code>{}</code> Source code in <code>src/bloqade/ir/control/sequence.py</code> <pre><code>def show(self, **assignments):\n    \"\"\"\n    Interactive visualization of the Sequence\n\n    Args:\n        **assignments: assigning the instance value (literal) to the\n            existing variables in the Sequence\n\n    \"\"\"\n    display_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Square","title":"Square","text":"<pre><code>Square(L1, L2=None, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Square lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0)</li> <li>a2 = (0,1)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L1 * L1.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of sites in direction a2. n_atoms = L1 * L2, default is L1</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    super().__init__(L1, L2, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Triangular","title":"Triangular","text":"<pre><code>Triangular(L1, L2=None, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Triangular lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (\u00bd, sqrt(3)/2)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0, 0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L * L.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of sites along a2 direction, n_atoms = L1 * L2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    super().__init__(L1, L2, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Variable","title":"Variable","text":"<p>             Bases: <code>Real</code></p> <p>Variable, which stores a variable name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>variable instance.</p> required"},{"location":"reference/bloqade/ir/#bloqade.ir.Waveform","title":"Waveform","text":"<p>Waveform node in the IR.</p> <ul> <li><code>&lt;instruction&gt;</code></li> <li><code>&lt;smooth&gt;</code></li> <li><code>&lt;slice&gt;</code></li> <li><code>&lt;apppend&gt;</code></li> <li><code>&lt;negative&gt;</code></li> <li><code>&lt;scale&gt;</code></li> <li><code>&lt;add&gt;</code></li> <li><code>&lt;record&gt;</code></li> <li><code>&lt;sample&gt;</code></li> </ul> <pre><code>&lt;waveform&gt; ::= &lt;instruction&gt;\n    | &lt;smooth&gt;\n    | &lt;slice&gt;\n    | &lt;append&gt;\n    | &lt;negative&gt;\n    | &lt;scale&gt;\n    | &lt;add&gt;\n    | &lt;record&gt;\n    | &lt;sample&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.Waveform.figure","title":"figure","text":"<pre><code>figure(**assignments)\n</code></pre> <p>get figure of the plotting the waveform.</p> <p>Returns:</p> Name Type Description <code>figure</code> <p>a bokeh figure</p> Source code in <code>src/bloqade/ir/control/waveform.py</code> <pre><code>def figure(self, **assignments):\n    \"\"\"get figure of the plotting the waveform.\n\n    Returns:\n        figure: a bokeh figure\n    \"\"\"\n    return get_ir_figure(self, **assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.cast","title":"cast","text":"<pre><code>cast(py)\n</code></pre> <ol> <li> <p>cast Real number (or list/tuple of Real numbers) to <code>Scalar Literal</code>.</p> </li> <li> <p>cast str (or list/tuple of Real numbers) to <code>Scalar Variable</code>.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>py</code> <code>Union[str, Real, Tuple[Real], List[Real]]</code> <p>python object to cast</p> required <p>Returns:</p> Type Description <code>Scalar</code> <p>Scalar</p> Source code in <code>src/bloqade/ir/scalar.py</code> <pre><code>def cast(py) -&gt; \"Scalar\":\n    \"\"\"\n    1. cast Real number (or list/tuple of Real numbers)\n    to [`Scalar Literal`][bloqade.ir.scalar.Literal].\n\n    2. cast str (or list/tuple of Real numbers)\n    to [`Scalar Variable`][bloqade.ir.scalar.Variable].\n\n    Args:\n        py (Union[str,Real,Tuple[Real],List[Real]]): python object to cast\n\n    Returns:\n        Scalar\n    \"\"\"\n    ret = trycast(py)\n    if ret is None:\n        raise TypeError(f\"Cannot cast {type(py)} to Scalar Literal\")\n\n    return ret\n</code></pre>"},{"location":"reference/bloqade/ir/#bloqade.ir.var","title":"var","text":"<pre><code>var(py)\n</code></pre> <p>cast string (or list/tuple of strings) to <code>Variable</code>.</p> <p>Parameters:</p> Name Type Description Default <code>py</code> <code>Union[str, List[str]]</code> <p>a string or list/tuple of strings</p> required <p>Returns:</p> Type Description <code>Variable</code> <p>Union[Variable]</p> Source code in <code>src/bloqade/ir/scalar.py</code> <pre><code>def var(py: str) -&gt; \"Variable\":\n    \"\"\"cast string (or list/tuple of strings)\n    to [`Variable`][bloqade.ir.scalar.Variable].\n\n    Args:\n        py (Union[str, List[str]]): a string or list/tuple of strings\n\n    Returns:\n       Union[Variable]\n    \"\"\"\n    ret = tryvar(py)\n    if ret is None:\n        raise TypeError(f\"Cannot cast {type(py)} to Variable\")\n\n    return ret\n</code></pre>"},{"location":"reference/bloqade/ir/analog_circuit/","title":"Analog circuit","text":""},{"location":"reference/bloqade/ir/analog_circuit/#bloqade.ir.analog_circuit.AnalogCircuit","title":"AnalogCircuit","text":"<p>AnalogCircuit is a dummy type that bundle register and sequence together.</p>"},{"location":"reference/bloqade/ir/analog_circuit/#bloqade.ir.analog_circuit.AnalogCircuit.register","title":"register  <code>property</code>","text":"<pre><code>register\n</code></pre> <p>Get the register of the program.</p> <p>Returns:</p> Type Description <p>register (Union[\"AtomArrangement\", \"ParallelRegister\"])</p> Note <p>If the program is built with <code>parallelize()</code>, The the register will be a <code>ParallelRegister</code>. Otherwise it will be a <code>AtomArrangement</code>.</p>"},{"location":"reference/bloqade/ir/analog_circuit/#bloqade.ir.analog_circuit.AnalogCircuit.show","title":"show","text":"<pre><code>show(**assignments)\n</code></pre> <p>Interactive visualization of the program</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>assigning the instance value (literal) to the existing variables in the program</p> <code>{}</code> Source code in <code>src/bloqade/ir/analog_circuit.py</code> <pre><code>def show(self, **assignments):\n    \"\"\"Interactive visualization of the program\n\n    Args:\n        **assignments: assigning the instance value (literal) to the\n            existing variables in the program\n\n    \"\"\"\n    display_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/scalar/","title":"Scalar","text":""},{"location":"reference/bloqade/ir/scalar/#bloqade.ir.scalar.Literal","title":"Literal","text":"<p>             Bases: <code>Real</code></p>"},{"location":"reference/bloqade/ir/scalar/#bloqade.ir.scalar.Literal.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value\n</code></pre> <p>Scalar Literal, which stores a decimaal value instance.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Decimal</code> <p>decimal value instance</p> required"},{"location":"reference/bloqade/ir/scalar/#bloqade.ir.scalar.Scalar","title":"Scalar","text":"<p>Base class for all scalar expressions.</p> <pre><code>&lt;scalar&gt; ::= &lt;literal&gt;\n| &lt;variable&gt;\n| &lt;default&gt;\n| &lt;negative&gt;\n| &lt;add&gt;\n| &lt;mul&gt;\n| &lt;min&gt;\n| &lt;max&gt;\n| &lt;slice&gt;\n| &lt;inverval&gt;\n\n&lt;mul&gt; ::= &lt;scalar&gt; '*' &lt;scalar&gt;\n&lt;add&gt; ::= &lt;scalar&gt; '+' &lt;scalar&gt;\n&lt;min&gt; ::= 'min' &lt;scalar&gt;+\n&lt;max&gt; ::= 'max' &lt;scalar&gt;+\n&lt;slice&gt; ::= &lt;scalar expr&gt; '[' &lt;interval&gt; ']'\n&lt;interval&gt; ::= &lt;scalar expr&gt; '..' &lt;scalar expr&gt;\n&lt;real&gt; ::= &lt;literal&gt; | &lt;var&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/scalar/#bloqade.ir.scalar.Variable","title":"Variable","text":"<p>             Bases: <code>Real</code></p> <p>Variable, which stores a variable name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>variable instance.</p> required"},{"location":"reference/bloqade/ir/scalar/#bloqade.ir.scalar.cast","title":"cast","text":"<pre><code>cast(py)\n</code></pre> <ol> <li> <p>cast Real number (or list/tuple of Real numbers) to <code>Scalar Literal</code>.</p> </li> <li> <p>cast str (or list/tuple of Real numbers) to <code>Scalar Variable</code>.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>py</code> <code>Union[str, Real, Tuple[Real], List[Real]]</code> <p>python object to cast</p> required <p>Returns:</p> Type Description <code>Scalar</code> <p>Scalar</p> Source code in <code>src/bloqade/ir/scalar.py</code> <pre><code>def cast(py) -&gt; \"Scalar\":\n    \"\"\"\n    1. cast Real number (or list/tuple of Real numbers)\n    to [`Scalar Literal`][bloqade.ir.scalar.Literal].\n\n    2. cast str (or list/tuple of Real numbers)\n    to [`Scalar Variable`][bloqade.ir.scalar.Variable].\n\n    Args:\n        py (Union[str,Real,Tuple[Real],List[Real]]): python object to cast\n\n    Returns:\n        Scalar\n    \"\"\"\n    ret = trycast(py)\n    if ret is None:\n        raise TypeError(f\"Cannot cast {type(py)} to Scalar Literal\")\n\n    return ret\n</code></pre>"},{"location":"reference/bloqade/ir/scalar/#bloqade.ir.scalar.var","title":"var","text":"<pre><code>var(py)\n</code></pre> <p>cast string (or list/tuple of strings) to <code>Variable</code>.</p> <p>Parameters:</p> Name Type Description Default <code>py</code> <code>Union[str, List[str]]</code> <p>a string or list/tuple of strings</p> required <p>Returns:</p> Type Description <code>Variable</code> <p>Union[Variable]</p> Source code in <code>src/bloqade/ir/scalar.py</code> <pre><code>def var(py: str) -&gt; \"Variable\":\n    \"\"\"cast string (or list/tuple of strings)\n    to [`Variable`][bloqade.ir.scalar.Variable].\n\n    Args:\n        py (Union[str, List[str]]): a string or list/tuple of strings\n\n    Returns:\n       Union[Variable]\n    \"\"\"\n    ret = tryvar(py)\n    if ret is None:\n        raise TypeError(f\"Cannot cast {type(py)} to Variable\")\n\n    return ret\n</code></pre>"},{"location":"reference/bloqade/ir/control/","title":"Index","text":""},{"location":"reference/bloqade/ir/control/field/","title":"Field","text":""},{"location":"reference/bloqade/ir/control/field/#bloqade.ir.control.field.Field","title":"Field","text":"<p>             Bases: <code>FieldExpr</code></p> <p>Field node in the IR. Which contains collection(s) of <code>Waveform</code></p> <pre><code>&lt;field&gt; ::= ('field' &lt;spatial modulation&gt;  &lt;padded waveform&gt;)*\n</code></pre>"},{"location":"reference/bloqade/ir/control/field/#bloqade.ir.control.field.Field.canonicalize","title":"canonicalize","text":"<pre><code>canonicalize()\n</code></pre> <p>Canonicalize the Field by merging <code>ScaledLocation</code> nodes with the same waveform.</p> Source code in <code>src/bloqade/ir/control/field.py</code> <pre><code>def canonicalize(self) -&gt; \"Field\":\n    \"\"\"\n    Canonicalize the Field by merging `ScaledLocation` nodes with the same waveform.\n    \"\"\"\n    reversed_dirves = {}\n\n    for sm, wf in self.drives.items():\n        reversed_dirves[wf] = reversed_dirves.get(wf, []) + [sm]\n\n    drives = {}\n\n    for wf, sms in reversed_dirves.items():\n        new_sm = [sm for sm in sms if not isinstance(sm, ScaledLocations)]\n        scaled_locations_sm = [sm for sm in sms if isinstance(sm, ScaledLocations)]\n\n        new_mask = {}\n\n        for ele in scaled_locations_sm:\n            for loc, scl in ele.value.items():\n                new_mask[loc] = new_mask.get(loc, 0) + cast(scl)\n\n        if new_mask:\n            new_sm += [ScaledLocations(new_mask)]\n\n        for sm in new_sm:\n            drives[sm] = wf\n\n    return Field(drives)\n</code></pre>"},{"location":"reference/bloqade/ir/control/field/#bloqade.ir.control.field.Field.show","title":"show","text":"<pre><code>show(**assignments)\n</code></pre> <p>Interactive visualization of the Field</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>assigning the instance value (literal) to the existing variables in the Field</p> <code>{}</code> Source code in <code>src/bloqade/ir/control/field.py</code> <pre><code>def show(self, **assignments):\n    \"\"\"\n    Interactive visualization of the Field\n\n    Args:\n        **assignments: assigning the instance value (literal) to the\n            existing variables in the Field\n\n    \"\"\"\n    display_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/control/pulse/","title":"Pulse","text":""},{"location":"reference/bloqade/ir/control/pulse/#bloqade.ir.control.pulse.Append","title":"Append","text":"<p>             Bases: <code>PulseExpr</code></p> <pre><code>&lt;append&gt; ::= &lt;expr&gt;+\n</code></pre>"},{"location":"reference/bloqade/ir/control/pulse/#bloqade.ir.control.pulse.Pulse","title":"Pulse","text":"<pre><code>Pulse(field_pairs)\n</code></pre> <p>             Bases: <code>PulseExpr</code></p> <pre><code>&lt;pulse&gt; ::= (&lt;field name&gt; &lt;field&gt;)+\n</code></pre> Source code in <code>src/bloqade/ir/control/pulse.py</code> <pre><code>def __init__(self, field_pairs):\n    fields = dict()\n    for k, v in field_pairs.items():\n        if isinstance(v, Field):\n            fields[k] = v\n        elif isinstance(v, dict):\n            fields[k] = Field(v)\n        else:\n            raise TypeError(f\"Expected Field or dict, got {type(v)}\")\n    self.fields = fields\n</code></pre>"},{"location":"reference/bloqade/ir/control/pulse/#bloqade.ir.control.pulse.Pulse.show","title":"show","text":"<pre><code>show(**assignments)\n</code></pre> <p>Interactive visualization of the Pulse</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>assigning the instance value (literal) to the existing variables in the Pulse</p> <code>{}</code> Source code in <code>src/bloqade/ir/control/pulse.py</code> <pre><code>def show(self, **assignments):\n    \"\"\"\n    Interactive visualization of the Pulse\n\n    Args:\n        **assignments: assigning the instance value (literal) to the\n            existing variables in the Pulse\n\n    \"\"\"\n    display_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/control/pulse/#bloqade.ir.control.pulse.PulseExpr","title":"PulseExpr","text":"<pre><code>&lt;expr&gt; ::= &lt;pulse&gt;\n  | &lt;append&gt;\n  | &lt;slice&gt;\n  | &lt;named&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/control/sequence/","title":"Sequence","text":""},{"location":"reference/bloqade/ir/control/sequence/#bloqade.ir.control.sequence.Sequence","title":"Sequence","text":"<pre><code>Sequence(seq_pairs=None)\n</code></pre> <p>             Bases: <code>SequenceExpr</code></p> <p>Sequence of a program, which includes pulses informations.</p> Source code in <code>src/bloqade/ir/control/sequence.py</code> <pre><code>def __init__(self, seq_pairs: Optional[Dict] = None):\n    if seq_pairs is None:\n        self.pulses = {}\n        return\n\n    pulses = {}\n    for level_coupling, pulse in seq_pairs.items():\n        if not isinstance(level_coupling, LevelCoupling):\n            raise TypeError(f\"Unexpected type {type(level_coupling)}\")\n\n        if isinstance(pulse, PulseExpr):\n            pulses[level_coupling] = pulse\n        elif isinstance(pulse, dict):\n            pulses[level_coupling] = Pulse(pulse)\n        else:\n            raise TypeError(f\"Unexpected type {type(pulse)}\")\n    self.pulses = pulses\n</code></pre>"},{"location":"reference/bloqade/ir/control/sequence/#bloqade.ir.control.sequence.Sequence.show","title":"show","text":"<pre><code>show(**assignments)\n</code></pre> <p>Interactive visualization of the Sequence</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>assigning the instance value (literal) to the existing variables in the Sequence</p> <code>{}</code> Source code in <code>src/bloqade/ir/control/sequence.py</code> <pre><code>def show(self, **assignments):\n    \"\"\"\n    Interactive visualization of the Sequence\n\n    Args:\n        **assignments: assigning the instance value (literal) to the\n            existing variables in the Sequence\n\n    \"\"\"\n    display_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/","title":"Waveform","text":""},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Add","title":"Add","text":"<p>             Bases: <code>Waveform</code></p> <pre><code>&lt;add&gt; ::= &lt;waveform&gt; '+' &lt;waveform&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.AlignedWaveform","title":"AlignedWaveform","text":"<p>             Bases: <code>Waveform</code></p> <pre><code>&lt;padded waveform&gt; ::= &lt;waveform&gt; | &lt;waveform&gt; &lt;alignment&gt; &lt;value&gt;\n\n&lt;alignment&gt; ::= 'left aligned' | 'right aligned'\n&lt;value&gt; ::= 'left value' | 'right value' | &lt;scalar expr&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Append","title":"Append","text":"<p>             Bases: <code>Waveform</code></p> <pre><code>&lt;append&gt; ::= &lt;waveform&gt;+\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Constant","title":"Constant","text":"<pre><code>Constant(value, duration)\n</code></pre> <p>             Bases: <code>Instruction</code></p> <pre><code>&lt;constant&gt; ::= 'constant' &lt;scalar expr&gt;\n</code></pre> <p>f(t=0:duration) = value</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Scalar</code> <p>the constant value</p> required <code>duration</code> <code>Scalar</code> <p>the time span of the constant waveform.</p> required Source code in <code>src/bloqade/ir/control/waveform.py</code> <pre><code>@beartype\ndef __init__(self, value: ScalarType, duration: ScalarType):\n    object.__setattr__(self, \"value\", cast(value))\n    object.__setattr__(self, \"duration\", cast(duration))\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Instruction","title":"Instruction","text":"<p>             Bases: <code>Waveform</code></p> <p>Instruction node in the IR.</p> <ul> <li><code>&lt;linear&gt;</code></li> <li><code>&lt;constant&gt;</code></li> <li><code>&lt;poly&gt;</code></li> <li><code>&lt;python-fn&gt;</code></li> </ul> <pre><code>&lt;instruction&gt; ::= &lt;linear&gt;\n    | &lt;constant&gt;\n    | &lt;poly&gt;\n    | &lt;python-fn&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Linear","title":"Linear","text":"<pre><code>Linear(start, stop, duration)\n</code></pre> <p>             Bases: <code>Instruction</code></p> <pre><code>&lt;linear&gt; ::= 'linear' &lt;scalar expr&gt; &lt;scalar expr&gt;\n</code></pre> <p>f(t=0:duration) = start + (stop-start)/duration * t</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Scalar</code> <p>start value</p> required <code>stop</code> <code>Scalar</code> <p>stop value</p> required <code>duration</code> <code>Scalar</code> <p>the time span of the linear waveform.</p> required Source code in <code>src/bloqade/ir/control/waveform.py</code> <pre><code>@beartype\ndef __init__(self, start: ScalarType, stop: ScalarType, duration: ScalarType):\n    object.__setattr__(self, \"start\", cast(start))\n    object.__setattr__(self, \"stop\", cast(stop))\n    object.__setattr__(self, \"duration\", cast(duration))\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Negative","title":"Negative","text":"<p>             Bases: <code>Waveform</code></p> <pre><code>&lt;negative&gt; ::= '-' &lt;waveform&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Poly","title":"Poly","text":"<pre><code>Poly(coeffs, duration)\n</code></pre> <p>             Bases: <code>Instruction</code></p> <pre><code>&lt;poly&gt; ::= &lt;scalar&gt;+\n</code></pre> <p>f(t=0:duration) = c[0] + c[1]t + c[2]t^2 + ... + c[n-1]t^n-1 + c[n]t^n</p> <p>Parameters:</p> Name Type Description Default <code>coeffs</code> <code>List[Scalar]</code> <p>the coefficients c[] of the polynomial.</p> required <code>duration</code> <code>Scalar</code> <p>the time span of the waveform.</p> required Source code in <code>src/bloqade/ir/control/waveform.py</code> <pre><code>@beartype\ndef __init__(self, coeffs: List[ScalarType], duration: ScalarType):\n    object.__setattr__(self, \"coeffs\", tuple(map(cast, coeffs)))\n    object.__setattr__(self, \"duration\", cast(duration))\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.PythonFn","title":"PythonFn","text":"<p>             Bases: <code>Instruction</code></p> <pre><code>&lt;python-fn&gt; ::= 'python-fn' &lt;python function def&gt; &lt;scalar expr&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Record","title":"Record","text":"<p>             Bases: <code>Waveform</code></p> <pre><code>&lt;record&gt; ::= 'record' &lt;waveform&gt; &lt;var&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Sample","title":"Sample","text":"<p>             Bases: <code>Waveform</code></p> <pre><code>&lt;sample&gt; ::= 'sample' &lt;waveform&gt; &lt;interpolation&gt; &lt;scalar&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Scale","title":"Scale","text":"<pre><code>Scale(scalar, waveform)\n</code></pre> <p>             Bases: <code>Waveform</code></p> <pre><code>&lt;scale&gt; ::= &lt;scalar expr&gt; '*' &lt;waveform&gt;\n</code></pre> Source code in <code>src/bloqade/ir/control/waveform.py</code> <pre><code>def __init__(self, scalar, waveform: Waveform):\n    object.__setattr__(self, \"scalar\", cast(scalar))\n    object.__setattr__(self, \"waveform\", waveform)\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Slice","title":"Slice","text":"<p>             Bases: <code>Waveform</code></p> <pre><code>&lt;slice&gt; ::= &lt;waveform&gt; &lt;scalar.interval&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Smooth","title":"Smooth","text":"<pre><code>Smooth(radius, kernel, waveform)\n</code></pre> <p>             Bases: <code>Waveform</code></p> <pre><code>&lt;smooth&gt; ::= 'smooth' &lt;kernel&gt; &lt;waveform&gt;\n</code></pre> Source code in <code>src/bloqade/ir/control/waveform.py</code> <pre><code>def __init__(self, radius, kernel, waveform):\n    if isinstance(kernel, str):\n        if kernel == \"Guassian\":\n            kernel = GaussianKernel\n        elif kernel == \"Logistic\":\n            kernel = LogisticKernel\n        elif kernel == \"Sigmoid\":\n            kernel = SigmoidKernel\n        elif kernel == \"Triangle\":\n            kernel = TriangleKernel\n        elif kernel == \"Uniform\":\n            kernel = UniformKernel\n        elif kernel == \"Parabolic\":\n            kernel = ParabolicKernel\n        elif kernel == \"Biweight\":\n            kernel = BiweightKernel\n        elif kernel == \"Triweight\":\n            kernel = TriweightKernel\n        elif kernel == \"Tricube\":\n            kernel = TricubeKernel\n        elif kernel == \"Cosine\":\n            kernel = CosineKernel\n        else:\n            raise ValueError(f\"Invalid kernel: {kernel}\")\n\n    object.__setattr__(self, \"radius\", cast(radius))\n    object.__setattr__(self, \"kernel\", kernel)\n    object.__setattr__(self, \"waveform\", waveform)\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Waveform","title":"Waveform","text":"<p>Waveform node in the IR.</p> <ul> <li><code>&lt;instruction&gt;</code></li> <li><code>&lt;smooth&gt;</code></li> <li><code>&lt;slice&gt;</code></li> <li><code>&lt;apppend&gt;</code></li> <li><code>&lt;negative&gt;</code></li> <li><code>&lt;scale&gt;</code></li> <li><code>&lt;add&gt;</code></li> <li><code>&lt;record&gt;</code></li> <li><code>&lt;sample&gt;</code></li> </ul> <pre><code>&lt;waveform&gt; ::= &lt;instruction&gt;\n    | &lt;smooth&gt;\n    | &lt;slice&gt;\n    | &lt;append&gt;\n    | &lt;negative&gt;\n    | &lt;scale&gt;\n    | &lt;add&gt;\n    | &lt;record&gt;\n    | &lt;sample&gt;\n</code></pre>"},{"location":"reference/bloqade/ir/control/waveform/#bloqade.ir.control.waveform.Waveform.figure","title":"figure","text":"<pre><code>figure(**assignments)\n</code></pre> <p>get figure of the plotting the waveform.</p> <p>Returns:</p> Name Type Description <code>figure</code> <p>a bokeh figure</p> Source code in <code>src/bloqade/ir/control/waveform.py</code> <pre><code>def figure(self, **assignments):\n    \"\"\"get figure of the plotting the waveform.\n\n    Returns:\n        figure: a bokeh figure\n    \"\"\"\n    return get_ir_figure(self, **assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/location/","title":"Index","text":""},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.start","title":"start  <code>module-attribute</code>","text":"<pre><code>start = ListOfLocations()\n</code></pre> <p>A Program starting point, alias of empty <code>ListOfLocations</code>.</p> <ul> <li>Next possible steps to build your program are:</li> <li>Specify which level coupling to address with:<ul> <li><code>start.rydberg</code>: for <code>Rydberg</code>     Level coupling</li> <li><code>start.hyperfine</code>: for <code>Hyperfine</code>     Level coupling</li> <li>LOCKOUT: You cannot add atoms to your geometry after specifying level coupling.</li> </ul> </li> <li>continue/start building your geometry with:<ul> <li><code>start.add_position()</code>: to add atom(s) to current register. It will accept:<ul> <li>A single coordinate, represented as a tuple (e.g. <code>(5,6)</code>) with a value that   can either be:<ul> <li>integers: <code>(5,6)</code></li> <li>floats: <code>(5.1, 2.5)</code></li> <li>strings (for later variable assignment): <code>(\"x\", \"y\")</code></li> <li><code>Scalar</code> objects: <code>(2*cast(\"x\"), 5+cast(\"y\"))</code></li> </ul> </li> <li>A list of coordinates, represented as a list of types mentioned previously.</li> <li>A numpy array with shape (n, 2) where n is the total number of atoms</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.AtomArrangement","title":"AtomArrangement","text":"<p>             Bases: <code>ProgramStart</code>, <code>TransformTrait</code></p>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.AtomArrangement.n_atoms","title":"n_atoms  <code>property</code>","text":"<pre><code>n_atoms\n</code></pre> <p>number of atoms (filled sites) in the register.</p>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.AtomArrangement.n_dims","title":"n_dims  <code>property</code>","text":"<pre><code>n_dims\n</code></pre> <p>number of dimensions in the register.</p>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.AtomArrangement.n_sites","title":"n_sites  <code>property</code>","text":"<pre><code>n_sites\n</code></pre> <p>number of sites in the register.</p>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.AtomArrangement.n_vacant","title":"n_vacant  <code>property</code>","text":"<pre><code>n_vacant\n</code></pre> <p>number of vacant sites in the register.</p>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.AtomArrangement.enumerate","title":"enumerate","text":"<pre><code>enumerate()\n</code></pre> <p>enumerate all locations in the register.</p> Source code in <code>src/bloqade/ir/location/base.py</code> <pre><code>def enumerate(self) -&gt; Generator[LocationInfo, None, None]:\n    \"\"\"enumerate all locations in the register.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.AtomArrangement.figure","title":"figure","text":"<pre><code>figure(fig_kwargs=None, **assignments)\n</code></pre> <p>obtain a figure object from the atom arrangement.</p> Source code in <code>src/bloqade/ir/location/base.py</code> <pre><code>def figure(self, fig_kwargs=None, **assignments):\n    \"\"\"obtain a figure object from the atom arrangement.\"\"\"\n    return get_atom_arrangement_figure(self, fig_kwargs, **assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.AtomArrangement.rydberg_interaction","title":"rydberg_interaction","text":"<pre><code>rydberg_interaction(**assignments)\n</code></pre> <p>calculate the Rydberg interaction matrix.</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>the values to assign to the variables in the register.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>the Rydberg interaction matrix in the lower triangular form.</p> Source code in <code>src/bloqade/ir/location/base.py</code> <pre><code>def rydberg_interaction(self, **assignments) -&gt; NDArray:\n    \"\"\"calculate the Rydberg interaction matrix.\n\n    Args:\n        **assignments: the values to assign to the variables in the register.\n\n    Returns:\n        NDArray: the Rydberg interaction matrix in the lower triangular form.\n\n    \"\"\"\n\n    from bloqade.constants import RB_C6\n\n    # calculate the Interaction matrix\n    V_ij = np.zeros((self.n_sites, self.n_sites))\n    for i, site_i in enumerate(self.enumerate()):\n        pos_i = np.array([float(ele(**assignments)) for ele in site_i.position])\n\n        for j, site_j in enumerate(self.enumerate()):\n            if j &gt;= i:\n                break  # enforce lower triangular form\n\n            pos_j = np.array([float(ele(**assignments)) for ele in site_j.position])\n            r_ij = np.linalg.norm(pos_i - pos_j)\n\n            V_ij[i, j] = RB_C6 / r_ij**6\n\n    return V_ij\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.BoundedBravais","title":"BoundedBravais","text":"<pre><code>BoundedBravais(*shape, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>AtomArrangement</code></p> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(self, *shape: int, lattice_spacing: ScalarType = 1.0):\n    self.shape = shape\n    self.lattice_spacing = cast(lattice_spacing)\n    self.__n_atoms = None\n    self.__n_dims = None\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.BoundedBravais.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('shape', 'lattice_spacing')\n</code></pre> <p>Base classe for Bravais lattices <code>AtomArrangement</code>.</p> <ul> <li><code>Square</code></li> <li><code>Chain</code></li> <li><code>Honeycomb</code></li> <li><code>Triangular</code></li> <li><code>Lieb</code></li> <li><code>Kagome</code></li> <li><code>Rectangular</code></li> </ul>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.BoundedBravais.n_dims","title":"n_dims  <code>property</code>","text":"<pre><code>n_dims\n</code></pre> <p>dimension of the lattice</p> <p>Returns:</p> Name Type Description <code>int</code> <p>dimension of the lattice</p>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.BoundedBravais.coordinates","title":"coordinates","text":"<pre><code>coordinates(index)\n</code></pre> <p>calculate the coordinates of a cell in the lattice given the cell index.</p> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef coordinates(self, index: List[int]) -&gt; NDArray:\n    \"\"\"calculate the coordinates of a cell in the lattice\n    given the cell index.\n    \"\"\"\n    # damn! this is like stone age broadcasting\n    vectors = np.array(self.cell_vectors())\n    index = np.array(index)\n    pos = np.sum(vectors.T * index, axis=1)\n    return pos + np.array(self.cell_atoms())\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.BoundedBravais.scale","title":"scale","text":"<pre><code>scale(factor)\n</code></pre> <p>Scale the current location with a factor.</p> <p>(x,y) -&gt; factor*(x,y)</p> <p>Parameters:</p> Name Type Description Default <code>factor</code> <code>str | Real | Decimal | Scalar</code> <p>scale factor</p> required <p>Returns:</p> Name Type Description <code>BoundedBravais</code> <code>BoundedBravais</code> <p>The lattice with the scaled locations</p> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef scale(self, factor: ScalarType) -&gt; \"BoundedBravais\":\n    \"\"\"Scale the current location with a factor.\n\n    (x,y) -&gt; factor*(x,y)\n\n    Args:\n        factor (str | Real | Decimal | Scalar): scale factor\n\n    Returns:\n        BoundedBravais: The lattice with the scaled locations\n    \"\"\"\n    factor = cast(factor)\n    obj = self.__new__(type(self))\n    for f in fields(self):\n        if f.name == \"lattice_spacing\":\n            obj.lattice_spacing = factor * self.lattice_spacing\n        else:\n            setattr(obj, f.name, getattr(self, f.name))\n    return obj\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.Chain","title":"Chain","text":"<pre><code>Chain(L, lattice_spacing=1.0, vertical_chain=False)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Chain lattice.</p> <ul> <li>1D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0).</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in the chain</p> required <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L: int, lattice_spacing: ScalarType = 1.0, vertical_chain: bool = False\n):\n    self.vertical = vertical_chain\n    super().__init__(L, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.Honeycomb","title":"Honeycomb","text":"<pre><code>Honeycomb(L1, L2=None, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Honeycomb lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (\u00bd, sqrt(3)/2)</li> </ul> </li> <li>unit cell (2 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (\u00bd, 1/(2*sqrt(3))</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of unit cells in linear direction. n_atoms = L1 * L1 * 2.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of unit cells in direction a2. n_atoms = L1 * L2 * 2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    super().__init__(L1, L2, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.Kagome","title":"Kagome","text":"<pre><code>Kagome(L1, L2=None, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Kagome lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (\u00bd, sqrt(3)/2)</li> </ul> </li> <li>unit cell (3 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (0.5, 0)</li> <li>loc3 (0.25 ,0.25sqrt(3))</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of sites in linear direction. n_atoms = 3 * L1 * L1.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of unit cells along a2 direction, n_atoms = 3 * L1 * L2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    super().__init__(L1, L2, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.Lieb","title":"Lieb","text":"<pre><code>Lieb(L1, L2=None, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Lieb lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (0, 1)</li> </ul> </li> <li>unit cell (3 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (0.5, 0)</li> <li>loc3 (0 ,0.5)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of unit cells in linear direction. n_atoms = 3* L1 * L1.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of unit cells along a2 direction, n_atoms = 3 * L1 * L2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    super().__init__(L1, L2, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.ParallelRegister","title":"ParallelRegister","text":"<pre><code>ParallelRegister(register, cluster_spacing)\n</code></pre> <p>             Bases: <code>ProgramStart</code></p> <p>Parallel Register</p> Source code in <code>src/bloqade/ir/location/base.py</code> <pre><code>@beartype\ndef __init__(self, register: AtomArrangement, cluster_spacing: ScalarType):\n    self._register = register\n    self._cluster_spacing = cast(cluster_spacing)\n\n    if register.n_atoms &gt; 0:\n        # calculate bounding box\n        # of this register\n        location_iter = register.enumerate()\n        (x, y) = next(location_iter).position\n        x_min = x\n        x_max = x\n        y_min = y\n        y_max = y\n\n        for location_info in location_iter:\n            (x, y) = location_info.position\n            x_min = x.min(x_min)\n            x_max = x.max(x_max)\n            y_min = y.min(y_min)\n            y_max = y.max(y_max)\n\n        shift_x = (x_max - x_min) + cluster_spacing\n        shift_y = (y_max - y_min) + cluster_spacing\n\n        register_locations = [\n            list(location_info.position) for location_info in register.enumerate()\n        ]\n        register_filling = [\n            location_info.filling.value for location_info in register.enumerate()\n        ]\n        shift_vectors = [[shift_x, cast(0)], [cast(0), shift_y]]\n    else:\n        raise ValueError(\"No locations to parallelize.\")\n\n    self.register_locations = register_locations\n    self.register_filling = register_filling\n    self.shift_vectors = shift_vectors\n    super().__init__(self)\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.Rectangular","title":"Rectangular","text":"<pre><code>Rectangular(\n    width,\n    height,\n    lattice_spacing_x=1.0,\n    lattice_spacing_y=None,\n)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Rectangular lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0)</li> <li>a2 = (0,1)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>number of sites in x direction.</p> required <code>height</code> <code>int</code> <p>number of sites in y direction.</p> required <code>lattice_spacing_x</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <code>lattice_spacing_y</code> <code>(Scalar, Real)</code> <p>lattice spacing in y direction. optional.</p> <code>None</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    width: int,\n    height: int,\n    lattice_spacing_x: ScalarType = 1.0,\n    lattice_spacing_y: Optional[ScalarType] = None,\n):\n    super().__init__(width, height, lattice_spacing=lattice_spacing_x)\n\n    if lattice_spacing_y is None:\n        self.ratio = cast(1.0) / cast(lattice_spacing_x)\n    else:\n        self.ratio = cast(lattice_spacing_y) / cast(lattice_spacing_x)\n\n    super().__init__(width, height, lattice_spacing=lattice_spacing_x)\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.Square","title":"Square","text":"<pre><code>Square(L1, L2=None, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Square lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0)</li> <li>a2 = (0,1)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L1 * L1.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of sites in direction a2. n_atoms = L1 * L2, default is L1</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    super().__init__(L1, L2, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/location/#bloqade.ir.location.Triangular","title":"Triangular","text":"<pre><code>Triangular(L1, L2=None, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Triangular lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (\u00bd, sqrt(3)/2)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0, 0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L * L.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of sites along a2 direction, n_atoms = L1 * L2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    super().__init__(L1, L2, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/location/base/","title":"Base","text":""},{"location":"reference/bloqade/ir/location/base/#bloqade.ir.location.base.AtomArrangement","title":"AtomArrangement","text":"<p>             Bases: <code>ProgramStart</code>, <code>TransformTrait</code></p>"},{"location":"reference/bloqade/ir/location/base/#bloqade.ir.location.base.AtomArrangement.n_atoms","title":"n_atoms  <code>property</code>","text":"<pre><code>n_atoms\n</code></pre> <p>number of atoms (filled sites) in the register.</p>"},{"location":"reference/bloqade/ir/location/base/#bloqade.ir.location.base.AtomArrangement.n_dims","title":"n_dims  <code>property</code>","text":"<pre><code>n_dims\n</code></pre> <p>number of dimensions in the register.</p>"},{"location":"reference/bloqade/ir/location/base/#bloqade.ir.location.base.AtomArrangement.n_sites","title":"n_sites  <code>property</code>","text":"<pre><code>n_sites\n</code></pre> <p>number of sites in the register.</p>"},{"location":"reference/bloqade/ir/location/base/#bloqade.ir.location.base.AtomArrangement.n_vacant","title":"n_vacant  <code>property</code>","text":"<pre><code>n_vacant\n</code></pre> <p>number of vacant sites in the register.</p>"},{"location":"reference/bloqade/ir/location/base/#bloqade.ir.location.base.AtomArrangement.enumerate","title":"enumerate","text":"<pre><code>enumerate()\n</code></pre> <p>enumerate all locations in the register.</p> Source code in <code>src/bloqade/ir/location/base.py</code> <pre><code>def enumerate(self) -&gt; Generator[LocationInfo, None, None]:\n    \"\"\"enumerate all locations in the register.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/bloqade/ir/location/base/#bloqade.ir.location.base.AtomArrangement.figure","title":"figure","text":"<pre><code>figure(fig_kwargs=None, **assignments)\n</code></pre> <p>obtain a figure object from the atom arrangement.</p> Source code in <code>src/bloqade/ir/location/base.py</code> <pre><code>def figure(self, fig_kwargs=None, **assignments):\n    \"\"\"obtain a figure object from the atom arrangement.\"\"\"\n    return get_atom_arrangement_figure(self, fig_kwargs, **assignments)\n</code></pre>"},{"location":"reference/bloqade/ir/location/base/#bloqade.ir.location.base.AtomArrangement.rydberg_interaction","title":"rydberg_interaction","text":"<pre><code>rydberg_interaction(**assignments)\n</code></pre> <p>calculate the Rydberg interaction matrix.</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>the values to assign to the variables in the register.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>the Rydberg interaction matrix in the lower triangular form.</p> Source code in <code>src/bloqade/ir/location/base.py</code> <pre><code>def rydberg_interaction(self, **assignments) -&gt; NDArray:\n    \"\"\"calculate the Rydberg interaction matrix.\n\n    Args:\n        **assignments: the values to assign to the variables in the register.\n\n    Returns:\n        NDArray: the Rydberg interaction matrix in the lower triangular form.\n\n    \"\"\"\n\n    from bloqade.constants import RB_C6\n\n    # calculate the Interaction matrix\n    V_ij = np.zeros((self.n_sites, self.n_sites))\n    for i, site_i in enumerate(self.enumerate()):\n        pos_i = np.array([float(ele(**assignments)) for ele in site_i.position])\n\n        for j, site_j in enumerate(self.enumerate()):\n            if j &gt;= i:\n                break  # enforce lower triangular form\n\n            pos_j = np.array([float(ele(**assignments)) for ele in site_j.position])\n            r_ij = np.linalg.norm(pos_i - pos_j)\n\n            V_ij[i, j] = RB_C6 / r_ij**6\n\n    return V_ij\n</code></pre>"},{"location":"reference/bloqade/ir/location/base/#bloqade.ir.location.base.ParallelRegister","title":"ParallelRegister","text":"<pre><code>ParallelRegister(register, cluster_spacing)\n</code></pre> <p>             Bases: <code>ProgramStart</code></p> <p>Parallel Register</p> Source code in <code>src/bloqade/ir/location/base.py</code> <pre><code>@beartype\ndef __init__(self, register: AtomArrangement, cluster_spacing: ScalarType):\n    self._register = register\n    self._cluster_spacing = cast(cluster_spacing)\n\n    if register.n_atoms &gt; 0:\n        # calculate bounding box\n        # of this register\n        location_iter = register.enumerate()\n        (x, y) = next(location_iter).position\n        x_min = x\n        x_max = x\n        y_min = y\n        y_max = y\n\n        for location_info in location_iter:\n            (x, y) = location_info.position\n            x_min = x.min(x_min)\n            x_max = x.max(x_max)\n            y_min = y.min(y_min)\n            y_max = y.max(y_max)\n\n        shift_x = (x_max - x_min) + cluster_spacing\n        shift_y = (y_max - y_min) + cluster_spacing\n\n        register_locations = [\n            list(location_info.position) for location_info in register.enumerate()\n        ]\n        register_filling = [\n            location_info.filling.value for location_info in register.enumerate()\n        ]\n        shift_vectors = [[shift_x, cast(0)], [cast(0), shift_y]]\n    else:\n        raise ValueError(\"No locations to parallelize.\")\n\n    self.register_locations = register_locations\n    self.register_filling = register_filling\n    self.shift_vectors = shift_vectors\n    super().__init__(self)\n</code></pre>"},{"location":"reference/bloqade/ir/location/bravais/","title":"Bravais","text":""},{"location":"reference/bloqade/ir/location/bravais/#bloqade.ir.location.bravais.BoundedBravais","title":"BoundedBravais","text":"<pre><code>BoundedBravais(*shape, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>AtomArrangement</code></p> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(self, *shape: int, lattice_spacing: ScalarType = 1.0):\n    self.shape = shape\n    self.lattice_spacing = cast(lattice_spacing)\n    self.__n_atoms = None\n    self.__n_dims = None\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade/ir/location/bravais/#bloqade.ir.location.bravais.BoundedBravais.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('shape', 'lattice_spacing')\n</code></pre> <p>Base classe for Bravais lattices <code>AtomArrangement</code>.</p> <ul> <li><code>Square</code></li> <li><code>Chain</code></li> <li><code>Honeycomb</code></li> <li><code>Triangular</code></li> <li><code>Lieb</code></li> <li><code>Kagome</code></li> <li><code>Rectangular</code></li> </ul>"},{"location":"reference/bloqade/ir/location/bravais/#bloqade.ir.location.bravais.BoundedBravais.n_dims","title":"n_dims  <code>property</code>","text":"<pre><code>n_dims\n</code></pre> <p>dimension of the lattice</p> <p>Returns:</p> Name Type Description <code>int</code> <p>dimension of the lattice</p>"},{"location":"reference/bloqade/ir/location/bravais/#bloqade.ir.location.bravais.BoundedBravais.coordinates","title":"coordinates","text":"<pre><code>coordinates(index)\n</code></pre> <p>calculate the coordinates of a cell in the lattice given the cell index.</p> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef coordinates(self, index: List[int]) -&gt; NDArray:\n    \"\"\"calculate the coordinates of a cell in the lattice\n    given the cell index.\n    \"\"\"\n    # damn! this is like stone age broadcasting\n    vectors = np.array(self.cell_vectors())\n    index = np.array(index)\n    pos = np.sum(vectors.T * index, axis=1)\n    return pos + np.array(self.cell_atoms())\n</code></pre>"},{"location":"reference/bloqade/ir/location/bravais/#bloqade.ir.location.bravais.BoundedBravais.scale","title":"scale","text":"<pre><code>scale(factor)\n</code></pre> <p>Scale the current location with a factor.</p> <p>(x,y) -&gt; factor*(x,y)</p> <p>Parameters:</p> Name Type Description Default <code>factor</code> <code>str | Real | Decimal | Scalar</code> <p>scale factor</p> required <p>Returns:</p> Name Type Description <code>BoundedBravais</code> <code>BoundedBravais</code> <p>The lattice with the scaled locations</p> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef scale(self, factor: ScalarType) -&gt; \"BoundedBravais\":\n    \"\"\"Scale the current location with a factor.\n\n    (x,y) -&gt; factor*(x,y)\n\n    Args:\n        factor (str | Real | Decimal | Scalar): scale factor\n\n    Returns:\n        BoundedBravais: The lattice with the scaled locations\n    \"\"\"\n    factor = cast(factor)\n    obj = self.__new__(type(self))\n    for f in fields(self):\n        if f.name == \"lattice_spacing\":\n            obj.lattice_spacing = factor * self.lattice_spacing\n        else:\n            setattr(obj, f.name, getattr(self, f.name))\n    return obj\n</code></pre>"},{"location":"reference/bloqade/ir/location/bravais/#bloqade.ir.location.bravais.Chain","title":"Chain","text":"<pre><code>Chain(L, lattice_spacing=1.0, vertical_chain=False)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Chain lattice.</p> <ul> <li>1D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0).</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in the chain</p> required <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L: int, lattice_spacing: ScalarType = 1.0, vertical_chain: bool = False\n):\n    self.vertical = vertical_chain\n    super().__init__(L, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/location/bravais/#bloqade.ir.location.bravais.Honeycomb","title":"Honeycomb","text":"<pre><code>Honeycomb(L1, L2=None, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Honeycomb lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (\u00bd, sqrt(3)/2)</li> </ul> </li> <li>unit cell (2 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (\u00bd, 1/(2*sqrt(3))</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of unit cells in linear direction. n_atoms = L1 * L1 * 2.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of unit cells in direction a2. n_atoms = L1 * L2 * 2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    super().__init__(L1, L2, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/location/bravais/#bloqade.ir.location.bravais.Kagome","title":"Kagome","text":"<pre><code>Kagome(L1, L2=None, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Kagome lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (\u00bd, sqrt(3)/2)</li> </ul> </li> <li>unit cell (3 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (0.5, 0)</li> <li>loc3 (0.25 ,0.25sqrt(3))</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of sites in linear direction. n_atoms = 3 * L1 * L1.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of unit cells along a2 direction, n_atoms = 3 * L1 * L2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    super().__init__(L1, L2, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/location/bravais/#bloqade.ir.location.bravais.Lieb","title":"Lieb","text":"<pre><code>Lieb(L1, L2=None, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Lieb lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (0, 1)</li> </ul> </li> <li>unit cell (3 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (0.5, 0)</li> <li>loc3 (0 ,0.5)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of unit cells in linear direction. n_atoms = 3* L1 * L1.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of unit cells along a2 direction, n_atoms = 3 * L1 * L2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    super().__init__(L1, L2, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/location/bravais/#bloqade.ir.location.bravais.Rectangular","title":"Rectangular","text":"<pre><code>Rectangular(\n    width,\n    height,\n    lattice_spacing_x=1.0,\n    lattice_spacing_y=None,\n)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Rectangular lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0)</li> <li>a2 = (0,1)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>number of sites in x direction.</p> required <code>height</code> <code>int</code> <p>number of sites in y direction.</p> required <code>lattice_spacing_x</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <code>lattice_spacing_y</code> <code>(Scalar, Real)</code> <p>lattice spacing in y direction. optional.</p> <code>None</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    width: int,\n    height: int,\n    lattice_spacing_x: ScalarType = 1.0,\n    lattice_spacing_y: Optional[ScalarType] = None,\n):\n    super().__init__(width, height, lattice_spacing=lattice_spacing_x)\n\n    if lattice_spacing_y is None:\n        self.ratio = cast(1.0) / cast(lattice_spacing_x)\n    else:\n        self.ratio = cast(lattice_spacing_y) / cast(lattice_spacing_x)\n\n    super().__init__(width, height, lattice_spacing=lattice_spacing_x)\n</code></pre>"},{"location":"reference/bloqade/ir/location/bravais/#bloqade.ir.location.bravais.Square","title":"Square","text":"<pre><code>Square(L1, L2=None, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Square lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0)</li> <li>a2 = (0,1)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L1 * L1.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of sites in direction a2. n_atoms = L1 * L2, default is L1</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    super().__init__(L1, L2, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/location/bravais/#bloqade.ir.location.bravais.Triangular","title":"Triangular","text":"<pre><code>Triangular(L1, L2=None, lattice_spacing=1.0)\n</code></pre> <p>             Bases: <code>BoundedBravais</code></p> <p>Triangular lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (\u00bd, sqrt(3)/2)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0, 0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L * L.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of sites along a2 direction, n_atoms = L1 * L2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>src/bloqade/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    super().__init__(L1, L2, lattice_spacing=lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade/ir/location/list/","title":"List","text":""},{"location":"reference/bloqade/ir/location/list/#bloqade.ir.location.list.start","title":"start  <code>module-attribute</code>","text":"<pre><code>start = ListOfLocations()\n</code></pre> <p>A Program starting point, alias of empty <code>ListOfLocations</code>.</p> <ul> <li>Next possible steps to build your program are:</li> <li>Specify which level coupling to address with:<ul> <li><code>start.rydberg</code>: for <code>Rydberg</code>     Level coupling</li> <li><code>start.hyperfine</code>: for <code>Hyperfine</code>     Level coupling</li> <li>LOCKOUT: You cannot add atoms to your geometry after specifying level coupling.</li> </ul> </li> <li>continue/start building your geometry with:<ul> <li><code>start.add_position()</code>: to add atom(s) to current register. It will accept:<ul> <li>A single coordinate, represented as a tuple (e.g. <code>(5,6)</code>) with a value that   can either be:<ul> <li>integers: <code>(5,6)</code></li> <li>floats: <code>(5.1, 2.5)</code></li> <li>strings (for later variable assignment): <code>(\"x\", \"y\")</code></li> <li><code>Scalar</code> objects: <code>(2*cast(\"x\"), 5+cast(\"y\"))</code></li> </ul> </li> <li>A list of coordinates, represented as a list of types mentioned previously.</li> <li>A numpy array with shape (n, 2) where n is the total number of atoms</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/bloqade/ir/location/quera_task_result/","title":"Quera task result","text":""},{"location":"reference/bloqade/ir/location/quera_task_result/#bloqade.ir.location.quera_task_result.QuEraTaskResults","title":"QuEraTaskResults","text":"<p>             Bases: <code>BaseModel</code></p>"},{"location":"reference/bloqade/ir/location/quera_task_result/#bloqade.ir.location.quera_task_result.QuEraTaskResults.export_as_probabilities","title":"export_as_probabilities","text":"<pre><code>export_as_probabilities()\n</code></pre> <p>converts from shot results to probabilities</p> <p>Returns:</p> Name Type Description <code>TaskProbabilities</code> <code>TaskProbabilities</code> <p>The task results as probabilties</p> Source code in <code>src/bloqade/ir/location/quera_task_result.py</code> <pre><code>def export_as_probabilities(self) -&gt; TaskProbabilities:\n    \"\"\"converts from shot results to probabilities\n\n    Returns:\n        TaskProbabilities: The task results as probabilties\n    \"\"\"\n    counts = dict()\n    nshots = len(self.shot_outputs)\n    for shot_result in self.shot_outputs:\n        pre_sequence_str = \"\".join(str(bit) for bit in shot_result.pre_sequence)\n\n        post_sequence_str = \"\".join(str(bit) for bit in shot_result.post_sequence)\n\n        configuration = (pre_sequence_str, post_sequence_str)\n        # iterative average\n        current_count = counts.get(configuration, 0)\n        counts[configuration] = current_count + 1\n\n    probabilities = [(config, count / nshots) for config, count in counts.items()]\n    return TaskProbabilities(probabilities=probabilities)\n</code></pre>"},{"location":"reference/bloqade/ir/location/transform/","title":"Transform","text":""},{"location":"reference/bloqade/ir/location/transform/#bloqade.ir.location.transform.TransformTrait","title":"TransformTrait","text":""},{"location":"reference/bloqade/ir/location/transform/#bloqade.ir.location.transform.TransformTrait.add_position","title":"add_position","text":"<pre><code>add_position(position, filling=None)\n</code></pre> <p>Add a position or multiple positions to a pre-existing geometry.</p> <p><code>add_position</code> is capable of accepting: - A single tuple for one atom coordinate: <code>(1.0, 2.5)</code> - A list of tuples: `[(0.0, 1.0), (2.0,1.5), etc.] - A numpy array of shape (N, 2) where N is the number of atoms</p> <p>You may also intersperse variables anywhere a value may be present.</p> <p>You can also pass in an optional argument which determines the atom \"filling\" (whether or not at a specified coordinate an atom should be present).</p>"},{"location":"reference/bloqade/ir/location/transform/#bloqade.ir.location.transform.TransformTrait.add_position--usage-example","title":"Usage Example:","text":"<pre><code># single coordinate\n&gt;&gt;&gt; reg = start.add_position((0,0))\n# you may chain add_position calls\n&gt;&gt;&gt; reg_plus_two = reg.add_position([(2,2),(5.0, 2.1)])\n# you can add variables anywhere a value may be present\n&gt;&gt;&gt; reg_with_var = reg_plus_two.add_position((\"x\", \"y\"))\n# and specify your atom fillings\n&gt;&gt;&gt; reg_with_filling = reg_with_var.add_position([(3.1, 0.0), (4.1, 2.2)],\n[True, False])\n# alternatively you could use one boolean to specify\n# all coordinates should be empty/filled\n&gt;&gt;&gt; reg_with_more_filling = reg_with_filling.add_positions([(3.1, 2.9),\n(5.2, 2.2)], False)\n</code></pre> <ul> <li>Next possible steps are:</li> <li>Continuing to build your geometry via:<ul> <li><code>...add_position(positions).add_position(positions)</code>:     to add more positions</li> <li><code>...add_position(positions).apply_defect_count(n_defects)</code>: to randomly drop out n_atoms</li> <li><code>...add_position(positions).apply_defect_density(defect_probability)</code>: to drop out atoms with a certain probability</li> <li><code>...add_position(positions).scale(scale)</code>: to scale the geometry</li> </ul> </li> <li>Targeting a level coupling once you're done with the atom geometry:<ul> <li><code>...add_position(positions).rydberg</code>: to specify Rydberg coupling</li> <li><code>...add_position(positions).hyperfine</code>: to specify Hyperfine coupling</li> </ul> </li> <li>Visualizing your atom geometry:<ul> <li><code>...add_position(positions).show()</code>: shows your geometry in your web browser</li> </ul> </li> </ul> Source code in <code>src/bloqade/ir/location/transform.py</code> <pre><code>def add_position(\n    self,\n    position: Union[\n        PositionArray,\n        List[Tuple[ScalarType, ScalarType]],\n        Tuple[ScalarType, ScalarType],\n    ],\n    filling: Optional[Union[BoolArray, List[bool], bool]] = None,\n) -&gt; \"ListOfLocations\":\n    \"\"\"\n    Add a position or multiple positions to a pre-existing geometry.\n\n    `add_position` is capable of accepting:\n    - A single tuple for one atom coordinate: `(1.0, 2.5)`\n    - A list of tuples: `[(0.0, 1.0), (2.0,1.5), etc.]\n    - A numpy array of shape (N, 2) where N is the number of atoms\n\n    You may also intersperse variables anywhere a value may be present.\n\n    You can also pass in an optional argument which determines the atom \"filling\"\n    (whether or not at a specified coordinate an atom should be present).\n\n    ### Usage Example:\n    ```\n    # single coordinate\n    &gt;&gt;&gt; reg = start.add_position((0,0))\n    # you may chain add_position calls\n    &gt;&gt;&gt; reg_plus_two = reg.add_position([(2,2),(5.0, 2.1)])\n    # you can add variables anywhere a value may be present\n    &gt;&gt;&gt; reg_with_var = reg_plus_two.add_position((\"x\", \"y\"))\n    # and specify your atom fillings\n    &gt;&gt;&gt; reg_with_filling = reg_with_var.add_position([(3.1, 0.0), (4.1, 2.2)],\n    [True, False])\n    # alternatively you could use one boolean to specify\n    # all coordinates should be empty/filled\n    &gt;&gt;&gt; reg_with_more_filling = reg_with_filling.add_positions([(3.1, 2.9),\n    (5.2, 2.2)], False)\n    ```\n\n    - Next possible steps are:\n    - Continuing to build your geometry via:\n        - `...add_position(positions).add_position(positions)`:\n            to add more positions\n        - `...add_position(positions).apply_defect_count(n_defects)`:\n        to randomly drop out n_atoms\n        - `...add_position(positions).apply_defect_density(defect_probability)`:\n        to drop out atoms with a certain probability\n        - `...add_position(positions).scale(scale)`: to scale the geometry\n    - Targeting a level coupling once you're done with the atom geometry:\n        - `...add_position(positions).rydberg`: to specify Rydberg coupling\n        - `...add_position(positions).hyperfine`: to specify Hyperfine coupling\n    - Visualizing your atom geometry:\n        - `...add_position(positions).show()`:\n        shows your geometry in your web browser\n\n    \"\"\"\n    return self._add_position(position, filling)\n</code></pre>"},{"location":"reference/bloqade/ir/location/transform/#bloqade.ir.location.transform.TransformTrait.apply_defect_count","title":"apply_defect_count","text":"<pre><code>apply_defect_count(n_defects, rng=np.random.default_rng())\n</code></pre> <p>Drop <code>n_defects</code> atoms from the geometry randomly. Internally this occurs by setting certain sites to have a SiteFilling set to false indicating no atom is present at the coordinate.</p> <p>A default numpy-based Random Number Generator is used but you can explicitly override this by passing in your own.</p>"},{"location":"reference/bloqade/ir/location/transform/#bloqade.ir.location.transform.TransformTrait.apply_defect_count--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; from bloqade.atom_arrangement import Chain\n&gt;&gt;&gt; import numpy as np\n# set a custom seed for a numpy-based RNG\n&gt;&gt;&gt; custom_rng = np.random.default_rng(888)\n# randomly remove two atoms from the geometry\n&gt;&gt;&gt; reg = Chain(11).apply_defect_count(2, custom_rng)\n# you may also chain apply_defect_count calls\n&gt;&gt;&gt; reg.apply_defect_count(2, custom_rng)\n# you can also use apply_defect_count on custom geometries\n&gt;&gt;&gt; from bloqade import start\n&gt;&gt;&gt; start.add_position([(0,0), (1,1)]).apply_defect_count(1, custom_rng)\n</code></pre> <ul> <li>Next possible steps are:</li> <li>Continuing to build your geometry via:<ul> <li><code>...apply_defect_count(defect_counts).add_position(positions)</code>:     to add more positions</li> <li><code>...apply_defect_count(defect_counts)     .apply_defect_count(n_defects)</code>: to randomly drop out n_atoms</li> <li><code>...apply_defect_count(defect_counts)     .apply_defect_density(defect_probability)</code>:     to drop out atoms with a certain probability</li> <li><code>...apply_defect_count(defect_counts).scale(scale)</code>:     to scale the geometry</li> </ul> </li> <li>Targeting a level coupling once you're done with the atom geometry:<ul> <li><code>...apply_defect_count(defect_counts).rydberg</code>: to specify     Rydberg coupling</li> <li><code>...apply_defect_count(defect_counts).hyperfine</code>:     to specify Hyperfine coupling</li> </ul> </li> <li>Visualizing your atom geometry:<ul> <li><code>...apply_defect_count(defect_counts).show()</code>:     shows your geometry in your web browser</li> </ul> </li> </ul> Source code in <code>src/bloqade/ir/location/transform.py</code> <pre><code>@beartype\ndef apply_defect_count(\n    self, n_defects: int, rng: np.random.Generator = np.random.default_rng()\n):\n    \"\"\"\n    Drop `n_defects` atoms from the geometry randomly. Internally this occurs\n    by setting certain sites to have a SiteFilling set to false indicating\n    no atom is present at the coordinate.\n\n    A default numpy-based Random Number Generator is used but you can\n    explicitly override this by passing in your own.\n\n    ### Usage Example:\n\n    ```\n    &gt;&gt;&gt; from bloqade.atom_arrangement import Chain\n    &gt;&gt;&gt; import numpy as np\n    # set a custom seed for a numpy-based RNG\n    &gt;&gt;&gt; custom_rng = np.random.default_rng(888)\n    # randomly remove two atoms from the geometry\n    &gt;&gt;&gt; reg = Chain(11).apply_defect_count(2, custom_rng)\n    # you may also chain apply_defect_count calls\n    &gt;&gt;&gt; reg.apply_defect_count(2, custom_rng)\n    # you can also use apply_defect_count on custom geometries\n    &gt;&gt;&gt; from bloqade import start\n    &gt;&gt;&gt; start.add_position([(0,0), (1,1)]).apply_defect_count(1, custom_rng)\n    ```\n\n    - Next possible steps are:\n    - Continuing to build your geometry via:\n        - `...apply_defect_count(defect_counts).add_position(positions)`:\n            to add more positions\n        - `...apply_defect_count(defect_counts)\n            .apply_defect_count(n_defects)`: to randomly drop out n_atoms\n        - `...apply_defect_count(defect_counts)\n            .apply_defect_density(defect_probability)`:\n            to drop out atoms with a certain probability\n        - `...apply_defect_count(defect_counts).scale(scale)`:\n            to scale the geometry\n    - Targeting a level coupling once you're done with the atom geometry:\n        - `...apply_defect_count(defect_counts).rydberg`: to specify\n            Rydberg coupling\n        - `...apply_defect_count(defect_counts).hyperfine`:\n            to specify Hyperfine coupling\n    - Visualizing your atom geometry:\n        - `...apply_defect_count(defect_counts).show()`:\n            shows your geometry in your web browser\n    \"\"\"\n    from .list import ListOfLocations\n    from .base import LocationInfo, SiteFilling\n\n    location_list = []\n    for location_info in self.enumerate():\n        location_list.append(location_info)\n\n    filled_sites = []\n\n    for index, location_info in enumerate(location_list):\n        if location_info.filling is SiteFilling.filled:\n            filled_sites.append(index)\n\n    if n_defects &gt;= len(filled_sites):\n        raise ValueError(\n            f\"n_defects {n_defects} must be less than the number of filled sites \"\n            f\"({len(filled_sites)})\"\n        )\n\n    for _ in range(n_defects):\n        index = rng.choice(filled_sites)\n        location_list[index] = LocationInfo(\n            location_list[index].position,\n            (False if location_list[index].filling is SiteFilling.filled else True),\n        )\n        filled_sites.remove(index)\n\n    return ListOfLocations(location_list)\n</code></pre>"},{"location":"reference/bloqade/ir/location/transform/#bloqade.ir.location.transform.TransformTrait.apply_defect_density","title":"apply_defect_density","text":"<pre><code>apply_defect_density(\n    defect_probability, rng=np.random.default_rng()\n)\n</code></pre> <p>Drop atoms randomly with <code>defect_probability</code> probability (range of 0 to 1). Internally this occurs by setting certain sites to have a SiteFilling set to false indicating no atom is present at the coordinate.</p> <p>A default numpy-based Random Number Generator is used but you can explicitly override this by passing in your own.</p>"},{"location":"reference/bloqade/ir/location/transform/#bloqade.ir.location.transform.TransformTrait.apply_defect_density--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; from bloqade.atom_arrangement import Chain\n&gt;&gt;&gt; import numpy as np\n# set a custom seed for a numpy-based RNG\n&gt;&gt;&gt; custom_rng = np.random.default_rng(888)\n# randomly remove two atoms from the geometry\n&gt;&gt;&gt; reg = Chain(11).apply_defect_density(0.2, custom_rng)\n# you may also chain apply_defect_density calls\n&gt;&gt;&gt; reg.apply_defect_count(0.1, custom_rng)\n# you can also use apply_defect_density on custom geometries\n&gt;&gt;&gt; from bloqade import start\n&gt;&gt;&gt; start.add_position([(0,0), (1,1)])\n.apply_defect_density(0.5, custom_rng)\n</code></pre> <ul> <li>Next possible steps are:</li> <li>Continuing to build your geometry via:<ul> <li><code>...apply_defect_count(defect_counts).add_position(positions)</code>: to add more positions</li> <li><code>...apply_defect_count(defect_counts).apply_defect_count(n_defects)</code>: to randomly drop out n_atoms</li> <li><code>...apply_defect_count(defect_counts) .apply_defect_density(defect_probability)</code>: to drop out atoms with a certain probability</li> <li><code>...apply_defect_count(defect_counts).scale(scale)</code>: to scale the geometry</li> </ul> </li> <li>Targeting a level coupling once you're done with the atom geometry:<ul> <li><code>...apply_defect_count(defect_counts).rydberg</code>: to specify Rydberg coupling</li> <li><code>...apply_defect_count(defect_counts).hyperfine</code>: to specify Hyperfine coupling</li> </ul> </li> <li>Visualizing your atom geometry:<ul> <li><code>...apply_defect_count(defect_counts).show()</code>: shows your geometry in your web browser</li> </ul> </li> </ul> Source code in <code>src/bloqade/ir/location/transform.py</code> <pre><code>@beartype\ndef apply_defect_density(\n    self,\n    defect_probability: float,\n    rng: np.random.Generator = np.random.default_rng(),\n):\n    \"\"\"\n    Drop atoms randomly with `defect_probability` probability (range of 0 to 1).\n    Internally this occurs by setting certain sites to have a SiteFilling\n    set to false indicating no atom is present at the coordinate.\n\n    A default numpy-based Random Number Generator is used but you can\n    explicitly override this by passing in your own.\n\n    ### Usage Example:\n\n    ```\n    &gt;&gt;&gt; from bloqade.atom_arrangement import Chain\n    &gt;&gt;&gt; import numpy as np\n    # set a custom seed for a numpy-based RNG\n    &gt;&gt;&gt; custom_rng = np.random.default_rng(888)\n    # randomly remove two atoms from the geometry\n    &gt;&gt;&gt; reg = Chain(11).apply_defect_density(0.2, custom_rng)\n    # you may also chain apply_defect_density calls\n    &gt;&gt;&gt; reg.apply_defect_count(0.1, custom_rng)\n    # you can also use apply_defect_density on custom geometries\n    &gt;&gt;&gt; from bloqade import start\n    &gt;&gt;&gt; start.add_position([(0,0), (1,1)])\n    .apply_defect_density(0.5, custom_rng)\n    ```\n\n    - Next possible steps are:\n    - Continuing to build your geometry via:\n        - `...apply_defect_count(defect_counts).add_position(positions)`:\n        to add more positions\n        - `...apply_defect_count(defect_counts).apply_defect_count(n_defects)`:\n        to randomly drop out n_atoms\n        - `...apply_defect_count(defect_counts)\n        .apply_defect_density(defect_probability)`:\n        to drop out atoms with a certain probability\n        - `...apply_defect_count(defect_counts).scale(scale)`:\n        to scale the geometry\n    - Targeting a level coupling once you're done with the atom geometry:\n        - `...apply_defect_count(defect_counts).rydberg`:\n        to specify Rydberg coupling\n        - `...apply_defect_count(defect_counts).hyperfine`:\n        to specify Hyperfine coupling\n    - Visualizing your atom geometry:\n        - `...apply_defect_count(defect_counts).show()`:\n        shows your geometry in your web browser\n    \"\"\"\n    from .list import ListOfLocations\n    from .base import LocationInfo, SiteFilling\n\n    p = min(1, max(0, defect_probability))\n    location_list = []\n\n    for location_info in self.enumerate():\n        if rng.random() &lt; p:\n            location_list.append(\n                LocationInfo(\n                    location_info.position,\n                    (\n                        False\n                        if location_info.filling is SiteFilling.filled\n                        else True\n                    ),\n                )\n            )\n        else:\n            location_list.append(location_info)\n\n    return ListOfLocations(location_list=location_list)\n</code></pre>"},{"location":"reference/bloqade/ir/location/transform/#bloqade.ir.location.transform.TransformTrait.scale","title":"scale","text":"<pre><code>scale(scale)\n</code></pre> <p>Scale the geometry of your atoms.</p>"},{"location":"reference/bloqade/ir/location/transform/#bloqade.ir.location.transform.TransformTrait.scale--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; reg = start.add_position([(0,0), (1,1)])\n# atom positions are now (0,0), (2,2)\n&gt;&gt;&gt; new_reg = reg.scale(2)\n# you may also use scale on pre-defined geometries\n&gt;&gt;&gt; from bloqade.atom_arrangement import Chain\n# atoms in the chain will now be 2 um apart versus\n# the default 1 um\n&gt;&gt;&gt; Chain(11).scale(2)\n</code></pre> <ul> <li>Next possible steps are:</li> <li>Continuing to build your geometry via:<ul> <li><code>...add_position(positions).add_position(positions)</code>:     to add more positions</li> <li><code>...add_position(positions).apply_defect_count(n_defects)</code>: to randomly drop out n_atoms</li> <li><code>...add_position(positions).apply_defect_density(defect_probability)</code>: to drop out atoms with a certain probability</li> <li><code>...add_position(positions).scale(scale)</code>: to scale the geometry</li> </ul> </li> <li>Targeting a level coupling once you're done with the atom geometry:<ul> <li><code>...add_position(positions).rydberg</code>: to specify Rydberg coupling</li> <li><code>...add_position(positions).hyperfine</code>: to specify Hyperfine coupling</li> </ul> </li> <li>Visualizing your atom geometry:<ul> <li><code>...add_position(positions).show()</code>: shows your geometry in your web browser</li> </ul> </li> </ul> Source code in <code>src/bloqade/ir/location/transform.py</code> <pre><code>@beartype\ndef scale(self, scale: ScalarType):\n    \"\"\"\n    Scale the geometry of your atoms.\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; reg = start.add_position([(0,0), (1,1)])\n    # atom positions are now (0,0), (2,2)\n    &gt;&gt;&gt; new_reg = reg.scale(2)\n    # you may also use scale on pre-defined geometries\n    &gt;&gt;&gt; from bloqade.atom_arrangement import Chain\n    # atoms in the chain will now be 2 um apart versus\n    # the default 1 um\n    &gt;&gt;&gt; Chain(11).scale(2)\n    ```\n\n    - Next possible steps are:\n    - Continuing to build your geometry via:\n        - `...add_position(positions).add_position(positions)`:\n            to add more positions\n        - `...add_position(positions).apply_defect_count(n_defects)`:\n        to randomly drop out n_atoms\n        - `...add_position(positions).apply_defect_density(defect_probability)`:\n        to drop out atoms with a certain probability\n        - `...add_position(positions).scale(scale)`: to scale the geometry\n    - Targeting a level coupling once you're done with the atom geometry:\n        - `...add_position(positions).rydberg`:\n        to specify Rydberg coupling\n        - `...add_position(positions).hyperfine`:\n        to specify Hyperfine coupling\n    - Visualizing your atom geometry:\n        - `...add_position(positions).show()`:\n        shows your geometry in your web browser\n\n    \"\"\"\n    from .list import ListOfLocations\n    from .base import LocationInfo\n\n    scale = cast(scale)\n    location_list = []\n    for location_info in self.enumerate():\n        x, y = location_info.position\n        new_position = (scale * x, scale * y)\n        location_list.append(\n            LocationInfo(new_position, bool(location_info.filling.value))\n        )\n\n    return ListOfLocations(location_list)\n</code></pre>"},{"location":"reference/bloqade/ir/routine/","title":"Index","text":""},{"location":"reference/bloqade/ir/routine/base/","title":"Base","text":""},{"location":"reference/bloqade/ir/routine/base/#bloqade.ir.routine.base.Routine","title":"Routine","text":"<p>             Bases: <code>RoutineBase</code></p> <p>Result of parsing a completed Builder string.</p>"},{"location":"reference/bloqade/ir/routine/bloqade/","title":"Bloqade","text":""},{"location":"reference/bloqade/ir/routine/bloqade/#bloqade.ir.routine.bloqade.BloqadePythonRoutine","title":"BloqadePythonRoutine","text":"<p>             Bases: <code>RoutineBase</code></p>"},{"location":"reference/bloqade/ir/routine/bloqade/#bloqade.ir.routine.bloqade.BloqadePythonRoutine.run","title":"run","text":"<pre><code>run(\n    shots,\n    args=(),\n    name=None,\n    blockade_radius=0.0,\n    jit_compiled=False,\n    interaction_picture=False,\n    cache_matrices=False,\n    multiprocessing=False,\n    num_workers=None,\n    solver_name=\"dop853\",\n    atol=1e-14,\n    rtol=1e-07,\n    nsteps=2147483647,\n)\n</code></pre> <p>Run the current program using bloqade python backend</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>number of shots after running state vector simulation</p> required <code>args</code> <code>Tuple[Real, ...]</code> <p>The values for parameters defined</p> <code>()</code> <code>name</code> <code>Optional[str]</code> <p>Name to give this run. Defaults to None.</p> <code>None</code> <code>blockade_radius</code> <code>float</code> <p>Use the Blockade subspace given a</p> <code>0.0</code> <code>jit_compiled</code> <code>bool</code> <p>(bool, optional): Use Numba to compile the waveforms,</p> <code>False</code> <code>interaction_picture</code> <code>bool</code> <p>Use the interaction picture when</p> <code>False</code> <code>cache_matrices</code> <code>bool</code> <p>Reuse previously evaluated matrcies when</p> <code>False</code> <code>multiprocessing</code> <code>bool</code> <p>Use multiple processes to process the</p> <code>False</code> <code>num_workers</code> <code>Optional[int]</code> <p>Number of processes to run with</p> <code>None</code> <code>solver_name</code> <code>str</code> <p>Which SciPy Solver to use. Defaults to</p> <code>'dop853'</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for ODE solver. Defaults to</p> <code>1e-14</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for adaptive step in ODE solver.</p> <code>1e-07</code> <code>nsteps</code> <code>int</code> <p>Maximum number of steps allowed per integration</p> <code>2147483647</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Cannot use multiprocessing and cache_matrices at the same time.</p> <p>Returns:</p> Name Type Description <code>LocalBatch</code> <code>LocalBatch</code> <p>Batch of local tasks that have been executed.</p> Source code in <code>src/bloqade/ir/routine/bloqade.py</code> <pre><code>@beartype\ndef run(\n    self,\n    shots: int,\n    args: Tuple[LiteralType, ...] = (),\n    name: Optional[str] = None,\n    blockade_radius: float = 0.0,\n    jit_compiled: bool = False,\n    interaction_picture: bool = False,\n    cache_matrices: bool = False,\n    multiprocessing: bool = False,\n    num_workers: Optional[int] = None,\n    solver_name: str = \"dop853\",\n    atol: float = 1e-14,\n    rtol: float = 1e-7,\n    nsteps: int = 2_147_483_647,\n) -&gt; LocalBatch:\n    \"\"\"Run the current program using bloqade python backend\n\n    Args:\n        shots (int): number of shots after running state vector simulation\n        args (Tuple[Real, ...], optional): The values for parameters defined\n        in `args`. Defaults to ().\n        name (Optional[str], optional): Name to give this run. Defaults to None.\n        blockade_radius (float, optional): Use the Blockade subspace given a\n        particular radius. Defaults to 0.0.\n        jit_compiled: (bool, optional): Use Numba to compile the waveforms,\n        Defaults to False.\n        interaction_picture (bool, optional): Use the interaction picture when\n        solving schrodinger equation. Defaults to False.\n        cache_matrices (bool, optional): Reuse previously evaluated matrcies when\n        possible. Defaults to False.\n        multiprocessing (bool, optional): Use multiple processes to process the\n        batches. Defaults to False.\n        num_workers (Optional[int], optional): Number of processes to run with\n        multiprocessing. Defaults to None.\n        solver_name (str, optional): Which SciPy Solver to use. Defaults to\n        \"dop853\".\n        atol (float, optional): Absolute tolerance for ODE solver. Defaults to\n        1e-14.\n        rtol (float, optional): Relative tolerance for adaptive step in ODE solver.\n        Defaults to 1e-7.\n        nsteps (int, optional): Maximum number of steps allowed per integration\n        step. Defaults to 2_147_483_647, the maximum value.\n\n    Raises:\n        ValueError: Cannot use multiprocessing and cache_matrices at the same time.\n\n    Returns:\n        LocalBatch: Batch of local tasks that have been executed.\n    \"\"\"\n    if multiprocessing and cache_matrices:\n        raise ValueError(\n            \"Cannot use multiprocessing and cache_matrices at the same time.\"\n        )\n\n    compile_options = dict(\n        shots=shots,\n        args=args,\n        name=name,\n        blockade_radius=blockade_radius,\n        cache_matrices=cache_matrices,\n        jit_compiled=jit_compiled,\n    )\n\n    solver_options = dict(\n        multiprocessing=multiprocessing,\n        num_workers=num_workers,\n        solver_name=solver_name,\n        atol=atol,\n        rtol=rtol,\n        nsteps=nsteps,\n        interaction_picture=interaction_picture,\n    )\n\n    batch = self._compile(**compile_options)\n    batch._run(**solver_options)\n\n    return batch\n</code></pre>"},{"location":"reference/bloqade/ir/routine/braket/","title":"Braket","text":""},{"location":"reference/bloqade/ir/routine/braket/#bloqade.ir.routine.braket.BraketHardwareRoutine","title":"BraketHardwareRoutine","text":"<p>             Bases: <code>RoutineBase</code></p>"},{"location":"reference/bloqade/ir/routine/braket/#bloqade.ir.routine.braket.BraketHardwareRoutine.__call__","title":"__call__","text":"<pre><code>__call__(\n    *args, shots=1, name=None, shuffle=False, **kwargs\n)\n</code></pre> <p>Compile to a RemoteBatch, which contain Braket backend specific tasks, run_async to Braket, and wait until the results are coming back.</p> Note <p>This is sync, and will wait until remote results finished.</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>number of shots</p> <code>1</code> <code>args</code> <code>LiteralType</code> <p>additional arguments for args variables.</p> <code>()</code> <code>name</code> <code>str</code> <p>custom name of the batch</p> <code>None</code> <code>shuffle</code> <code>bool</code> <p>shuffle the order of jobs</p> <code>False</code> Return <p>RemoteBatch</p> Source code in <code>src/bloqade/ir/routine/braket.py</code> <pre><code>@beartype\ndef __call__(\n    self,\n    *args: LiteralType,\n    shots: int = 1,\n    name: Optional[str] = None,\n    shuffle: bool = False,\n    **kwargs,\n):\n    \"\"\"\n    Compile to a RemoteBatch, which contain\n    Braket backend specific tasks, run_async to Braket,\n    and wait until the results are coming back.\n\n    Note:\n        This is sync, and will wait until remote results\n        finished.\n\n    Args:\n        shots (int): number of shots\n        args: additional arguments for args variables.\n        name (str): custom name of the batch\n        shuffle (bool): shuffle the order of jobs\n\n    Return:\n        RemoteBatch\n\n    \"\"\"\n    return self.run(shots, args, name, shuffle, **kwargs)\n</code></pre>"},{"location":"reference/bloqade/ir/routine/braket/#bloqade.ir.routine.braket.BraketHardwareRoutine.run","title":"run","text":"<pre><code>run(shots, args=(), name=None, shuffle=False, **kwargs)\n</code></pre> <p>Compile to a RemoteBatch, which contain Braket backend specific tasks, run_async to Braket, and wait until the results are coming back.</p> Note <p>This is sync, and will wait until remote results finished.</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>number of shots</p> required <code>args</code> <code>Tuple</code> <p>additional arguments</p> <code>()</code> <code>name</code> <code>str</code> <p>custom name of the batch</p> <code>None</code> <code>shuffle</code> <code>bool</code> <p>shuffle the order of jobs</p> <code>False</code> Return <p>RemoteBatch</p> Source code in <code>src/bloqade/ir/routine/braket.py</code> <pre><code>@beartype\ndef run(\n    self,\n    shots: int,\n    args: Tuple[LiteralType, ...] = (),\n    name: Optional[str] = None,\n    shuffle: bool = False,\n    **kwargs,\n) -&gt; RemoteBatch:\n    \"\"\"\n    Compile to a RemoteBatch, which contain\n    Braket backend specific tasks, run_async to Braket,\n    and wait until the results are coming back.\n\n    Note:\n        This is sync, and will wait until remote results\n        finished.\n\n    Args:\n        shots (int): number of shots\n        args (Tuple): additional arguments\n        name (str): custom name of the batch\n        shuffle (bool): shuffle the order of jobs\n\n    Return:\n        RemoteBatch\n\n    \"\"\"\n\n    batch = self.run_async(shots, args, name, shuffle, **kwargs)\n    batch.pull()\n    return batch\n</code></pre>"},{"location":"reference/bloqade/ir/routine/braket/#bloqade.ir.routine.braket.BraketHardwareRoutine.run_async","title":"run_async","text":"<pre><code>run_async(\n    shots, args=(), name=None, shuffle=False, **kwargs\n)\n</code></pre> <p>Compile to a RemoteBatch, which contain Braket backend specific tasks, and run_async to Braket.</p> Note <p>This is async.</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>number of shots</p> required <code>args</code> <code>Tuple</code> <p>Values of the parameter defined in <code>args</code>, defaults to ()</p> <code>()</code> <code>name</code> <code>str | None</code> <p>custom name of the batch, defaults to None</p> <code>None</code> <code>shuffle</code> <code>bool</code> <p>shuffle the order of jobs</p> <code>False</code> Return <p>RemoteBatch</p> Source code in <code>src/bloqade/ir/routine/braket.py</code> <pre><code>@beartype\ndef run_async(\n    self,\n    shots: int,\n    args: Tuple[LiteralType, ...] = (),\n    name: Optional[str] = None,\n    shuffle: bool = False,\n    **kwargs,\n) -&gt; RemoteBatch:\n    \"\"\"\n    Compile to a RemoteBatch, which contain\n    Braket backend specific tasks, and run_async to Braket.\n\n    Note:\n        This is async.\n\n    Args:\n        shots (int): number of shots\n        args (Tuple): Values of the parameter defined in `args`, defaults to ()\n        name (str | None): custom name of the batch, defaults to None\n        shuffle (bool): shuffle the order of jobs\n\n    Return:\n        RemoteBatch\n\n    \"\"\"\n\n    batch = self._compile(shots, args, name)\n    batch._submit(shuffle, **kwargs)\n    return batch\n</code></pre>"},{"location":"reference/bloqade/ir/routine/braket/#bloqade.ir.routine.braket.BraketLocalEmulatorRoutine","title":"BraketLocalEmulatorRoutine","text":"<p>             Bases: <code>RoutineBase</code></p>"},{"location":"reference/bloqade/ir/routine/braket/#bloqade.ir.routine.braket.BraketLocalEmulatorRoutine.__call__","title":"__call__","text":"<pre><code>__call__(\n    *args,\n    shots=1,\n    name=None,\n    multiprocessing=False,\n    num_workers=None,\n    **kwargs\n)\n</code></pre> <p>Compile to a LocalBatch, and run. The LocalBatch contain tasks to run on local emulator.</p> Note <p>This is sync, and will wait until remote results finished.</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>number of shots</p> <code>1</code> <code>args</code> <code>LiteralType</code> <p>additional arguments for args variables.</p> <code>()</code> <code>multiprocessing</code> <code>bool</code> <p>enable multi-process</p> <code>False</code> <code>num_workers</code> <code>int</code> <p>number of workers to run the emulator</p> <code>None</code> Return <p>LocalBatch</p> Source code in <code>src/bloqade/ir/routine/braket.py</code> <pre><code>@beartype\ndef __call__(\n    self,\n    *args: LiteralType,\n    shots: int = 1,\n    name: Optional[str] = None,\n    multiprocessing: bool = False,\n    num_workers: Optional[int] = None,\n    **kwargs,\n):\n    \"\"\"\n    Compile to a LocalBatch, and run.\n    The LocalBatch contain tasks to run on local emulator.\n\n    Note:\n        This is sync, and will wait until remote results\n        finished.\n\n    Args:\n        shots (int): number of shots\n        args: additional arguments for args variables.\n        multiprocessing (bool): enable multi-process\n        num_workers (int): number of workers to run the emulator\n\n    Return:\n        LocalBatch\n\n    \"\"\"\n    return self.run(\n        shots,\n        args,\n        name,\n        multiprocessing=multiprocessing,\n        num_workers=num_workers,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/bloqade/ir/routine/braket/#bloqade.ir.routine.braket.BraketLocalEmulatorRoutine.run","title":"run","text":"<pre><code>run(\n    shots,\n    args=(),\n    name=None,\n    multiprocessing=False,\n    num_workers=None,\n    **kwargs\n)\n</code></pre> <p>Compile to a LocalBatch, and run. The LocalBatch contain tasks to run on local emulator.</p> Note <p>This is sync, and will wait until remote results finished.</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>number of shots</p> required <code>args</code> <code>Tuple[LiteralType, ...]</code> <p>additional arguments for args variables.</p> <code>()</code> <code>multiprocessing</code> <code>bool</code> <p>enable multi-process</p> <code>False</code> <code>num_workers</code> <code>int</code> <p>number of workers to run the emulator</p> <code>None</code> Return <p>LocalBatch</p> Source code in <code>src/bloqade/ir/routine/braket.py</code> <pre><code>@beartype\ndef run(\n    self,\n    shots: int,\n    args: Tuple[LiteralType, ...] = (),\n    name: Optional[str] = None,\n    multiprocessing: bool = False,\n    num_workers: Optional[int] = None,\n    **kwargs,\n) -&gt; LocalBatch:\n    \"\"\"\n    Compile to a LocalBatch, and run.\n    The LocalBatch contain tasks to run on local emulator.\n\n    Note:\n        This is sync, and will wait until remote results\n        finished.\n\n    Args:\n        shots (int): number of shots\n        args: additional arguments for args variables.\n        multiprocessing (bool): enable multi-process\n        num_workers (int): number of workers to run the emulator\n\n    Return:\n        LocalBatch\n\n    \"\"\"\n\n    batch = self._compile(shots, args, name)\n    batch._run(multiprocessing=multiprocessing, num_workers=num_workers, **kwargs)\n    return batch\n</code></pre>"},{"location":"reference/bloqade/ir/routine/params/","title":"Params","text":""},{"location":"reference/bloqade/ir/routine/quera/","title":"Quera","text":""},{"location":"reference/bloqade/ir/routine/quera/#bloqade.ir.routine.quera.QuEraHardwareRoutine","title":"QuEraHardwareRoutine","text":"<p>             Bases: <code>RoutineBase</code></p>"},{"location":"reference/bloqade/ir/routine/quera/#bloqade.ir.routine.quera.QuEraHardwareRoutine.run_async","title":"run_async","text":"<pre><code>run_async(\n    shots, args=(), name=None, shuffle=False, **kwargs\n)\n</code></pre> <p>Compile to a RemoteBatch, which contain     QuEra backend specific tasks,     and run_async through QuEra service.</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>number of shots</p> required <code>args</code> <code>Tuple</code> <p>additional arguments</p> <code>()</code> <code>name</code> <code>str</code> <p>custom name of the batch</p> <code>None</code> <code>shuffle</code> <code>bool</code> <p>shuffle the order of jobs</p> <code>False</code> Return <p>RemoteBatch</p> Source code in <code>src/bloqade/ir/routine/quera.py</code> <pre><code>@beartype\ndef run_async(\n    self,\n    shots: int,\n    args: Tuple[LiteralType, ...] = (),\n    name: Optional[str] = None,\n    shuffle: bool = False,\n    **kwargs,\n) -&gt; RemoteBatch:\n    \"\"\"\n    Compile to a RemoteBatch, which contain\n        QuEra backend specific tasks,\n        and run_async through QuEra service.\n\n    Args:\n        shots (int): number of shots\n        args (Tuple): additional arguments\n        name (str): custom name of the batch\n        shuffle (bool): shuffle the order of jobs\n\n    Return:\n        RemoteBatch\n\n    \"\"\"\n    batch = self._compile(shots, args, name)\n    batch._submit(shuffle, **kwargs)\n    return batch\n</code></pre>"},{"location":"reference/bloqade/submission/","title":"Index","text":""},{"location":"reference/bloqade/submission/base/","title":"Base","text":""},{"location":"reference/bloqade/submission/braket/","title":"Braket","text":""},{"location":"reference/bloqade/submission/load_config/","title":"Load config","text":""},{"location":"reference/bloqade/submission/mock/","title":"Mock","text":""},{"location":"reference/bloqade/submission/quera/","title":"Quera","text":""},{"location":"reference/bloqade/submission/ir/","title":"Index","text":""},{"location":"reference/bloqade/submission/ir/braket/","title":"Braket","text":""},{"location":"reference/bloqade/submission/ir/capabilities/","title":"Capabilities","text":""},{"location":"reference/bloqade/submission/ir/parallel/","title":"Parallel","text":""},{"location":"reference/bloqade/submission/ir/parallel/#bloqade.submission.ir.parallel.ClusterLocationInfo","title":"ClusterLocationInfo","text":"<p>             Bases: <code>BaseModel</code></p> <p>Class that stores the mapping of batched jobs.</p> <p>Parameters:</p> Name Type Description Default <code>cluster_index</code> <code>int</code> <p>the index of the cluster a site belongs to</p> required <code>global_location_index</code> <code>int</code> <p>the index of the site in the multplexed system</p> required <code>cluster_location_index</code> <code>int</code> <p>the index of the site in the original system</p> required"},{"location":"reference/bloqade/submission/ir/task_results/","title":"Task results","text":""},{"location":"reference/bloqade/submission/ir/task_results/#bloqade.submission.ir.task_results.QuEraTaskResults","title":"QuEraTaskResults","text":"<p>             Bases: <code>BaseModel</code></p>"},{"location":"reference/bloqade/submission/ir/task_results/#bloqade.submission.ir.task_results.QuEraTaskResults.export_as_probabilities","title":"export_as_probabilities","text":"<pre><code>export_as_probabilities()\n</code></pre> <p>converts from shot results to probabilities</p> <p>Returns:</p> Name Type Description <code>TaskProbabilities</code> <code>TaskProbabilities</code> <p>The task results as probabilties</p> Source code in <code>src/bloqade/submission/ir/task_results.py</code> <pre><code>def export_as_probabilities(self) -&gt; TaskProbabilities:\n    \"\"\"converts from shot results to probabilities\n\n    Returns:\n        TaskProbabilities: The task results as probabilties\n    \"\"\"\n    counts = dict()\n    nshots = len(self.shot_outputs)\n    for shot_result in self.shot_outputs:\n        pre_sequence_str = \"\".join(str(bit) for bit in shot_result.pre_sequence)\n\n        post_sequence_str = \"\".join(str(bit) for bit in shot_result.post_sequence)\n\n        configuration = (pre_sequence_str, post_sequence_str)\n        # iterative average\n        current_count = counts.get(configuration, 0)\n        counts[configuration] = current_count + 1\n\n    probabilities = [(config, count / nshots) for config, count in counts.items()]\n    return TaskProbabilities(probabilities=probabilities)\n</code></pre>"},{"location":"reference/bloqade/submission/ir/task_specification/","title":"Task specification","text":""},{"location":"reference/bloqade/task/","title":"Index","text":""},{"location":"reference/bloqade/task/base/","title":"Base","text":""},{"location":"reference/bloqade/task/base/#bloqade.task.base.Report","title":"Report","text":"<pre><code>Report(data, metas, geos, name='')\n</code></pre> Source code in <code>src/bloqade/task/base.py</code> <pre><code>def __init__(self, data, metas, geos, name=\"\") -&gt; None:\n    self.dataframe = data  # df\n    self._bitstrings = None  # bitstring cache\n    self._counts = None  # counts cache\n    self.metas = metas\n    self.geos = geos\n    self.name = name + \" \" + str(datetime.datetime.now())\n</code></pre>"},{"location":"reference/bloqade/task/base/#bloqade.task.base.Report.bitstrings","title":"bitstrings","text":"<pre><code>bitstrings(filter_perfect_filling=True)\n</code></pre> <p>Get the bitstrings from the data.</p> <p>Parameters:</p> Name Type Description Default <code>filter_perfect_filling</code> <code>bool</code> <p>whether return will</p> <code>True</code> <p>Returns:</p> Name Type Description <code>bitstrings</code> <code>list of ndarray</code> <p>list corresponding to each</p> <code>List[NDArray]</code> <p>task in the report. Each element is an ndarray of shape</p> <code>List[NDArray]</code> <p>(nshots, nsites) where nshots is the number of shots for</p> <code>List[NDArray]</code> <p>the task and nsites is the number of sites in the task.</p> Note <p>Note that nshots may vary between tasks if filter_perfect_filling is set to True.</p> Source code in <code>src/bloqade/task/base.py</code> <pre><code>def bitstrings(self, filter_perfect_filling: bool = True) -&gt; List[NDArray]:\n    \"\"\"Get the bitstrings from the data.\n\n    Args:\n        filter_perfect_filling (bool): whether return will\n        only contain perfect filling shots. Defaults to True.\n\n    Returns:\n        bitstrings (list of ndarray): list corresponding to each\n        task in the report. Each element is an ndarray of shape\n        (nshots, nsites) where nshots is the number of shots for\n        the task and nsites is the number of sites in the task.\n\n    Note:\n        Note that nshots may vary between tasks if filter_perfect_filling\n        is set to True.\n\n    \"\"\"\n    perfect_sorting = self.dataframe.index.get_level_values(\"perfect_sorting\")\n    pre_sequence = self.dataframe.index.get_level_values(\"pre_sequence\")\n    if filter_perfect_filling:\n        df = self.dataframe[perfect_sorting == pre_sequence]\n    else:\n        df = self.dataframe\n\n    task_numbers = df.index.get_level_values(\"task_number\").unique()\n\n    bitstrings = []\n    for task_number in task_numbers:\n        bitstrings.append(df.loc[task_number, ...].to_numpy())\n\n    return bitstrings\n</code></pre>"},{"location":"reference/bloqade/task/base/#bloqade.task.base.Report.counts","title":"counts","text":"<pre><code>counts(filter_perfect_filling=True)\n</code></pre> <p>Get the counts of unique bit strings.</p> <p>Parameters:</p> Name Type Description Default <code>filter_perfect_filling</code> <code>bool</code> <p>whether return will</p> <code>True</code> <p>Returns:</p> Name Type Description <code>bitstrings</code> <code>list of ndarray</code> <p>list corresponding to each</p> <code>List[OrderedDict[str, int]]</code> <p>task in the report. Each element is an ndarray of shape</p> <code>List[OrderedDict[str, int]]</code> <p>(nshots, nsites) where nshots is the number of shots for</p> <code>List[OrderedDict[str, int]]</code> <p>the task and nsites is the number of sites in the task.</p> Note <p>Note that nshots may vary between tasks if filter_perfect_filling is set to True.</p> Source code in <code>src/bloqade/task/base.py</code> <pre><code>def counts(\n    self, filter_perfect_filling: bool = True\n) -&gt; List[OrderedDict[str, int]]:\n    \"\"\"Get the counts of unique bit strings.\n\n    Args:\n        filter_perfect_filling (bool): whether return will\n        only contain perfect filling shots. Defaults to True.\n\n    Returns:\n        bitstrings (list of ndarray): list corresponding to each\n        task in the report. Each element is an ndarray of shape\n        (nshots, nsites) where nshots is the number of shots for\n        the task and nsites is the number of sites in the task.\n\n    Note:\n        Note that nshots may vary between tasks if filter_perfect_filling\n        is set to True.\n\n    \"\"\"\n    counts = []\n    for bitstring in self.bitstrings(filter_perfect_filling):\n        output = np.unique(bitstring, axis=0, return_counts=True)\n\n        count_list = [\n            (\"\".join(map(str, bitstring)), count)\n            for bitstring, count in zip(*output)\n        ]\n        count_list.sort(key=lambda x: x[1], reverse=True)\n        count = OrderedDict(count_list)\n\n        counts.append(count)\n\n    return counts\n</code></pre>"},{"location":"reference/bloqade/task/base/#bloqade.task.base.Report.list_param","title":"list_param","text":"<pre><code>list_param(field_name)\n</code></pre> <p>List the parameters associate with the given variable field_name for each tasks.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>variable name</p> required Source code in <code>src/bloqade/task/base.py</code> <pre><code>def list_param(self, field_name: str) -&gt; List[Union[Number, None]]:\n    \"\"\"\n    List the parameters associate with the given variable field_name\n    for each tasks.\n\n    Args:\n        field_name (str): variable name\n\n    \"\"\"\n\n    def cast(x):\n        if x is None:\n            return None\n        elif isinstance(x, (list, tuple, np.ndarray)):\n            return list(map(cast, x))\n        else:\n            return float(x)\n\n    return list(map(cast, (meta.get(field_name) for meta in self.metas)))\n</code></pre>"},{"location":"reference/bloqade/task/base/#bloqade.task.base.Report.rydberg_densities","title":"rydberg_densities","text":"<pre><code>rydberg_densities(filter_perfect_filling=True)\n</code></pre> <p>Get rydberg density for each task.</p> <p>Parameters:</p> Name Type Description Default <code>filter_perfect_filling</code> <code>bool</code> <p>whether return will</p> <code>True</code> Return <p>per-site rydberg density for each task as a pandas DataFrame or Series.</p> Source code in <code>src/bloqade/task/base.py</code> <pre><code>def rydberg_densities(self, filter_perfect_filling: bool = True) -&gt; pd.Series:\n    \"\"\"Get rydberg density for each task.\n\n    Args:\n        filter_perfect_filling (bool, optional): whether return will\n        only contain perfect filling shots. Defaults to True.\n\n    Return:\n        per-site rydberg density for each task as a pandas DataFrame or Series.\n\n    \"\"\"\n    # TODO: implement nan for missing task numbers\n    perfect_sorting = self.dataframe.index.get_level_values(\"perfect_sorting\")\n    pre_sequence = self.dataframe.index.get_level_values(\"pre_sequence\")\n\n    if filter_perfect_filling:\n        df = self.dataframe[perfect_sorting == pre_sequence]\n    else:\n        df = self.dataframe\n\n    return 1 - (df.groupby(\"task_number\").mean())\n</code></pre>"},{"location":"reference/bloqade/task/base/#bloqade.task.base.Report.show","title":"show","text":"<pre><code>show()\n</code></pre> <p>Interactive Visualization of the Report</p> Source code in <code>src/bloqade/task/base.py</code> <pre><code>def show(self):\n    \"\"\"\n    Interactive Visualization of the Report\n\n    \"\"\"\n    display_report(self)\n</code></pre>"},{"location":"reference/bloqade/task/batch/","title":"Batch","text":""},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.LocalBatch","title":"LocalBatch  <code>dataclass</code>","text":"<p>             Bases: <code>Serializable</code></p>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.LocalBatch.report","title":"report","text":"<pre><code>report()\n</code></pre> <p>Generate analysis report base on currently completed tasks in the LocalBatch.</p> Return <p>Report</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>def report(self) -&gt; Report:\n    \"\"\"\n    Generate analysis report base on currently\n    completed tasks in the LocalBatch.\n\n    Return:\n        Report\n\n    \"\"\"\n\n    ## this potentially can be specialize/disatch\n    ## offline\n    index = []\n    data = []\n    metas = []\n    geos = []\n\n    for task_number, task in self.tasks.items():\n        geometry = task.geometry\n        perfect_sorting = \"\".join(map(str, geometry.filling))\n        parallel_decoder = geometry.parallel_decoder\n\n        if parallel_decoder:\n            cluster_indices = parallel_decoder.get_cluster_indices()\n        else:\n            cluster_indices = {(0, 0): list(range(len(perfect_sorting)))}\n\n        shot_iter = filter(\n            lambda shot: shot.shot_status == QuEraShotStatusCode.Completed,\n            task.result().shot_outputs,\n        )\n\n        for shot, (cluster_coordinate, cluster_index) in product(\n            shot_iter, cluster_indices.items()\n        ):\n            pre_sequence = \"\".join(\n                map(\n                    str,\n                    (shot.pre_sequence[index] for index in cluster_index),\n                )\n            )\n\n            post_sequence = np.asarray(\n                [shot.post_sequence[index] for index in cluster_index],\n                dtype=np.int8,\n            )\n\n            pfc_sorting = \"\".join(\n                [perfect_sorting[index] for index in cluster_index]\n            )\n\n            key = (\n                task_number,\n                cluster_coordinate,\n                pfc_sorting,\n                pre_sequence,\n            )\n\n            index.append(key)\n            data.append(post_sequence)\n\n        metas.append(task.metadata)\n        geos.append(task.geometry)\n\n    index = pd.MultiIndex.from_tuples(\n        index, names=[\"task_number\", \"cluster\", \"perfect_sorting\", \"pre_sequence\"]\n    )\n\n    df = pd.DataFrame(data, index=index)\n    df.sort_index(axis=\"index\")\n\n    rept = None\n    if self.name is None:\n        rept = Report(df, metas, geos, \"Local\")\n    else:\n        rept = Report(df, metas, geos, self.name)\n\n    return rept\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.LocalBatch.rerun","title":"rerun","text":"<pre><code>rerun(multiprocessing=False, num_workers=None, **kwargs)\n</code></pre> <p>Rerun all the tasks in the LocalBatch.</p> Return <p>Report</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>@beartype\ndef rerun(\n    self, multiprocessing: bool = False, num_workers: Optional[int] = None, **kwargs\n):\n    \"\"\"\n    Rerun all the tasks in the LocalBatch.\n\n    Return:\n        Report\n\n    \"\"\"\n\n    return self._run(\n        multiprocessing=multiprocessing, num_workers=num_workers, **kwargs\n    )\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch","title":"RemoteBatch  <code>dataclass</code>","text":"<p>             Bases: <code>Serializable</code></p>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.total_nshots","title":"total_nshots  <code>property</code>","text":"<pre><code>total_nshots\n</code></pre> <p>Total number of shots of all tasks in the RemoteBatch</p> Return <p>number of shots</p>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.cancel","title":"cancel","text":"<pre><code>cancel()\n</code></pre> <p>Cancel all the tasks in the Batch.</p> Return <p>self</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>def cancel(self) -&gt; \"RemoteBatch\":\n    \"\"\"\n    Cancel all the tasks in the Batch.\n\n    Return:\n        self\n\n    \"\"\"\n    # cancel all jobs\n    for task in self.tasks.values():\n        task.cancel()\n\n    return self\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.fetch","title":"fetch","text":"<pre><code>fetch()\n</code></pre> <p>Fetch the tasks in the Batch.</p> Note <p>Fetching will update the status of tasks, and only pull the results for those tasks that have completed.</p> Return <p>self</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>def fetch(self) -&gt; \"RemoteBatch\":\n    \"\"\"\n    Fetch the tasks in the Batch.\n\n    Note:\n        Fetching will update the status of tasks,\n        and only pull the results for those tasks\n        that have completed.\n\n    Return:\n        self\n\n    \"\"\"\n    # online, non-blocking\n    # pull the results only when its ready\n    for task in self.tasks.values():\n        task.fetch()\n\n    return self\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.get_completed_tasks","title":"get_completed_tasks","text":"<pre><code>get_completed_tasks()\n</code></pre> <p>Create a RemoteBatch object that contain completed tasks from current Batch.</p> <p>Tasks consider completed with following status codes:</p> <ol> <li>Completed</li> <li>Partial</li> </ol> Return <p>RemoteBatch</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>def get_completed_tasks(self) -&gt; \"RemoteBatch\":\n    \"\"\"\n    Create a RemoteBatch object that\n    contain completed tasks from current Batch.\n\n    Tasks consider completed with following status codes:\n\n    1. Completed\n    2. Partial\n\n    Return:\n        RemoteBatch\n\n    \"\"\"\n    statuses = [\n        \"Completed\",\n        \"Partial\",\n    ]\n    return self.get_tasks(*statuses)\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.get_failed_tasks","title":"get_failed_tasks","text":"<pre><code>get_failed_tasks()\n</code></pre> <p>Create a RemoteBatch object that contain failed tasks from current Batch.</p> <p>failed tasks with following status codes:</p> <ol> <li>Failed</li> <li>Unaccepted</li> </ol> Return <p>RemoteBatch</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>def get_failed_tasks(self) -&gt; \"RemoteBatch\":\n    \"\"\"\n    Create a RemoteBatch object that\n    contain failed tasks from current Batch.\n\n    failed tasks with following status codes:\n\n    1. Failed\n    2. Unaccepted\n\n    Return:\n        RemoteBatch\n\n    \"\"\"\n    # statuses that are in a state that are\n    # completed because of an error\n    statuses = [\"Failed\", \"Unaccepted\"]\n    return self.get_tasks(*statuses)\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.get_finished_tasks","title":"get_finished_tasks","text":"<pre><code>get_finished_tasks()\n</code></pre> <p>Create a RemoteBatch object that contain finished tasks from current Batch.</p> <p>Tasks consider finished with following status codes:</p> <ol> <li>Failed</li> <li>Unaccepted</li> <li>Completed</li> <li>Partial</li> <li>Cancelled</li> </ol> Return <p>RemoteBatch</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>def get_finished_tasks(self) -&gt; \"RemoteBatch\":\n    \"\"\"\n    Create a RemoteBatch object that\n    contain finished tasks from current Batch.\n\n    Tasks consider finished with following status codes:\n\n    1. Failed\n    2. Unaccepted\n    3. Completed\n    4. Partial\n    5. Cancelled\n\n    Return:\n        RemoteBatch\n\n    \"\"\"\n    # statuses that are in a state that will\n    # not run going forward for any reason\n    statuses = [\"Completed\", \"Failed\", \"Unaccepted\", \"Partial\", \"Cancelled\"]\n    return self.get_tasks(*statuses)\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.get_tasks","title":"get_tasks","text":"<pre><code>get_tasks(*status_codes)\n</code></pre> <p>Get Tasks with specify status_codes.</p> Return <p>RemoteBatch</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>@beartype\ndef get_tasks(self, *status_codes: str) -&gt; \"RemoteBatch\":\n    \"\"\"\n    Get Tasks with specify status_codes.\n\n    Return:\n        RemoteBatch\n\n    \"\"\"\n    # offline:\n    st_codes = [QuEraTaskStatusCode(x) for x in status_codes]\n\n    new_task_results = OrderedDict()\n    for task_number, task in self.tasks.items():\n        if task.task_result_ir.task_status in st_codes:\n            new_task_results[task_number] = task\n\n    return RemoteBatch(self.source, new_task_results, name=self.name)\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.pull","title":"pull","text":"<pre><code>pull()\n</code></pre> <p>Pull results of the tasks in the Batch.</p> Note <p>Pulling will pull the results for the tasks. If a given task(s) has not been completed, wait until it finished.</p> Return <p>self</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>def pull(self) -&gt; \"RemoteBatch\":\n    \"\"\"\n    Pull results of the tasks in the Batch.\n\n    Note:\n        Pulling will pull the results for the tasks.\n        If a given task(s) has not been completed, wait\n        until it finished.\n\n    Return:\n        self\n    \"\"\"\n    # online, blocking\n    # pull the results. if its not ready, hanging\n    for task in self.tasks.values():\n        task.pull()\n\n    return self\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.remove_failed_tasks","title":"remove_failed_tasks","text":"<pre><code>remove_failed_tasks()\n</code></pre> <p>Create a RemoteBatch object that contain tasks from current Batch, with failed tasks removed.</p> <p>failed tasks with following status codes:</p> <ol> <li>Failed</li> <li>Unaccepted</li> </ol> Return <p>RemoteBatch</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>def remove_failed_tasks(self) -&gt; \"RemoteBatch\":\n    \"\"\"\n    Create a RemoteBatch object that\n    contain tasks from current Batch,\n    with failed tasks removed.\n\n    failed tasks with following status codes:\n\n    1. Failed\n    2. Unaccepted\n\n    Return:\n        RemoteBatch\n\n    \"\"\"\n    # statuses that are in a state that will\n    # not run going forward because of an error\n    statuses = [\"Failed\", \"Unaccepted\"]\n    return self.remove_tasks(*statuses)\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.remove_invalid_tasks","title":"remove_invalid_tasks","text":"<pre><code>remove_invalid_tasks()\n</code></pre> <p>Create a RemoteBatch object that contain tasks from current Batch, with all Unaccepted tasks removed.</p> Return <p>RemoteBatch</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>def remove_invalid_tasks(self) -&gt; \"RemoteBatch\":\n    \"\"\"\n    Create a RemoteBatch object that\n    contain tasks from current Batch,\n    with all Unaccepted tasks removed.\n\n    Return:\n        RemoteBatch\n\n    \"\"\"\n    return self.remove_tasks(\"Unaccepted\")\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.remove_tasks","title":"remove_tasks","text":"<pre><code>remove_tasks(*status_codes)\n</code></pre> <p>Remove Tasks with specify status_codes.</p> Return <p>RemoteBatch</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>@beartype\ndef remove_tasks(self, *status_codes: str) -&gt; \"RemoteBatch\":\n    \"\"\"\n    Remove Tasks with specify status_codes.\n\n    Return:\n        RemoteBatch\n\n    \"\"\"\n    # offline:\n\n    st_codes = [QuEraTaskStatusCode(x) for x in status_codes]\n\n    new_results = OrderedDict()\n    for task_number, task in self.tasks.items():\n        if task.task_result_ir.task_status in st_codes:\n            continue\n\n        new_results[task_number] = task\n\n    return RemoteBatch(self.source, new_results, self.name)\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.report","title":"report","text":"<pre><code>report()\n</code></pre> <p>Generate analysis report base on currently completed tasks in the RemoteBatch.</p> Return <p>Report</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>def report(self) -&gt; \"Report\":\n    \"\"\"\n    Generate analysis report base on currently\n    completed tasks in the RemoteBatch.\n\n    Return:\n        Report\n\n    \"\"\"\n    ## this potentially can be specialize/disatch\n    ## offline\n    index = []\n    data = []\n    metas = []\n    geos = []\n\n    for task_number, task in self.tasks.items():\n        ## fliter not existing results tasks:\n        if (task.task_id is None) or (not task._result_exists()):\n            continue\n\n        ## filter has result but is not correctly completed.\n        if task.task_result_ir.task_status not in [\n            QuEraTaskStatusCode.Completed,\n            QuEraTaskStatusCode.Partial,\n        ]:\n            continue\n\n        geometry = task.geometry\n        perfect_sorting = \"\".join(map(str, geometry.filling))\n        parallel_decoder = geometry.parallel_decoder\n\n        if parallel_decoder:\n            cluster_indices = parallel_decoder.get_cluster_indices()\n        else:\n            cluster_indices = {(0, 0): list(range(len(perfect_sorting)))}\n\n        shot_iter = filter(\n            lambda shot: shot.shot_status == QuEraShotStatusCode.Completed,\n            task.result().shot_outputs,\n        )\n\n        for shot, (cluster_coordinate, cluster_index) in product(\n            shot_iter, cluster_indices.items()\n        ):\n            pre_sequence = \"\".join(\n                map(\n                    str,\n                    (shot.pre_sequence[index] for index in cluster_index),\n                )\n            )\n\n            post_sequence = np.asarray(\n                [shot.post_sequence[index] for index in cluster_index],\n                dtype=np.int8,\n            )\n\n            pfc_sorting = \"\".join(\n                [perfect_sorting[index] for index in cluster_index]\n            )\n\n            key = (\n                task_number,\n                cluster_coordinate,\n                pfc_sorting,\n                pre_sequence,\n            )\n\n            index.append(key)\n            data.append(post_sequence)\n\n        metas.append(task.metadata)\n        geos.append(task.geometry)\n\n    index = pd.MultiIndex.from_tuples(\n        index, names=[\"task_number\", \"cluster\", \"perfect_sorting\", \"pre_sequence\"]\n    )\n\n    df = pd.DataFrame(data, index=index)\n    df.sort_index(axis=\"index\")\n\n    rept = None\n    if self.name is None:\n        rept = Report(df, metas, geos, \"Remote\")\n    else:\n        rept = Report(df, metas, geos, self.name)\n\n    return rept\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.resubmit","title":"resubmit","text":"<pre><code>resubmit(shuffle_submit_order=True)\n</code></pre> <p>Resubmit all the tasks in the RemoteBatch</p> Return <p>self</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>@beartype\ndef resubmit(self, shuffle_submit_order: bool = True) -&gt; \"RemoteBatch\":\n    \"\"\"\n    Resubmit all the tasks in the RemoteBatch\n\n    Return:\n        self\n\n    \"\"\"\n    # online, non-blocking\n    self._submit(shuffle_submit_order, force=True)\n    return self\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.RemoteBatch.tasks_metric","title":"tasks_metric","text":"<pre><code>tasks_metric()\n</code></pre> <p>Get current tasks status metric</p> Return <p>dataframe with [\"task id\", \"status\", \"shots\"]</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>def tasks_metric(self) -&gt; pd.DataFrame:\n    \"\"\"\n    Get current tasks status metric\n\n    Return:\n        dataframe with [\"task id\", \"status\", \"shots\"]\n\n    \"\"\"\n    # [TODO] more info on current status\n    # offline, non-blocking\n    tid = []\n    data = []\n    for int, task in self.tasks.items():\n        tid.append(int)\n\n        dat = [None, None, None]\n        dat[0] = task.task_id\n        if task.task_result_ir is not None:\n            dat[1] = task.task_result_ir.task_status.name\n        dat[2] = task.task_ir.nshots\n        data.append(dat)\n\n    return pd.DataFrame(data, index=tid, columns=[\"task ID\", \"status\", \"shots\"])\n</code></pre>"},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.Serializable","title":"Serializable","text":""},{"location":"reference/bloqade/task/batch/#bloqade.task.batch.Serializable.json","title":"json","text":"<pre><code>json(**options)\n</code></pre> <p>Serialize the object to JSON string.</p> Return <p>JSON string</p> Source code in <code>src/bloqade/task/batch.py</code> <pre><code>def json(self, **options) -&gt; str:\n    \"\"\"\n    Serialize the object to JSON string.\n\n    Return:\n        JSON string\n\n    \"\"\"\n    from bloqade import dumps\n\n    return dumps(self, **options)\n</code></pre>"},{"location":"reference/bloqade/task/bloqade/","title":"Bloqade","text":""},{"location":"reference/bloqade/task/braket/","title":"Braket","text":""},{"location":"reference/bloqade/task/braket_simulator/","title":"Braket simulator","text":""},{"location":"reference/bloqade/task/quera/","title":"Quera","text":""},{"location":"reference/bloqade/transform/","title":"Index","text":""},{"location":"reference/bloqade/transform/common/","title":"Index","text":""},{"location":"reference/bloqade/transform/common/assign_variables/","title":"Assign variables","text":""},{"location":"reference/bloqade/transform/common/normalize/","title":"Normalize","text":""},{"location":"reference/bloqade/transform/python/","title":"Index","text":""},{"location":"reference/bloqade/transform/python/waveform/","title":"Waveform","text":""}]}